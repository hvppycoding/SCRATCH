ðŸš¨ Note: This log may contain personal information such as the contents of your files or terminal output. Please review the contents carefully before sharing.

summarizeConversationHistory-full - 55726a57
Request Messages
System
User
Response
Metadata
requestType      : ChatCompletions
model            : gemini-3-pro-preview
maxPromptTokens  : 82030
maxResponseTokens: 64000
location         : 6
otherOptions     : {"temperature":0,"stream":true}
intent           : undefined
startTime        : 2025-12-27T13:53:19.053Z
endTime          : 2025-12-27T13:53:39.956Z
duration         : 20903ms
ourRequestId     : 592cc5b6-0e21-4a7b-8a33-51e3dcb691c4
requestId        : 592cc5b6-0e21-4a7b-8a33-51e3dcb691c4
serverRequestId  : 592cc5b6-0e21-4a7b-8a33-51e3dcb691c4
timeToFirstToken : 5716ms
resolved model   : gemini-3-pro-preview
usage            : {"completion_tokens":1738,"prompt_tokens":95358,"prompt_tokens_details":{"cached_tokens":0},"total_tokens":97188,"reasoning_tokens":92}
tools            : [
    {
        "function": {
            "name": "create_directory",
            "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
            "parameters": {
                "type": "object",
                "properties": {
                    "dirPath": {
                        "type": "string",
                        "description": "The absolute path to the directory to create."
                    }
                },
                "required": [
                    "dirPath"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_file",
            "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "The absolute path to the file to create."
                    },
                    "content": {
                        "type": "string",
                        "description": "The content to write to the file."
                    }
                },
                "required": [
                    "filePath",
                    "content"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_new_jupyter_notebook",
            "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_new_workspace",
            "description": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "edit_notebook_file",
            "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "cellId": {
                        "type": "string",
                        "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                        "anyOf": [
                            {
                                "type": "string",
                                "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                            },
                            {
                                "type": "array",
                                "items": {
                                    "type": "string",
                                    "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                                }
                            }
                        ]
                    },
                    "language": {
                        "type": "string",
                        "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                        "type": "string",
                        "enum": [
                            "insert",
                            "delete",
                            "edit"
                        ],
                        "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                },
                "required": [
                    "filePath",
                    "editType",
                    "cellId"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "fetch_webpage",
            "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
            "parameters": {
                "type": "object",
                "properties": {
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                        "type": "string",
                        "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                },
                "required": [
                    "urls",
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "file_search",
            "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                        "type": "number",
                        "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "grep_search",
            "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                        "type": "boolean",
                        "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                        "type": "string",
                        "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                        "type": "number",
                        "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                        "type": "boolean",
                        "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                },
                "required": [
                    "query",
                    "isRegexp"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_changed_files",
            "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
            "parameters": {
                "type": "object",
                "properties": {
                    "repositoryPath": {
                        "type": "string",
                        "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": [
                                "staged",
                                "unstaged",
                                "merge-conflicts"
                            ]
                        },
                        "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_errors",
            "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePaths": {
                        "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "copilot_getNotebookSummary",
            "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                },
                "required": [
                    "filePath"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_project_setup_info",
            "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
            "parameters": {
                "type": "object",
                "properties": {
                    "projectType": {
                        "type": "string",
                        "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                },
                "required": [
                    "projectType"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_search_view_results",
            "description": "The results from the search view"
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_vscode_api",
            "description": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "github_repo",
            "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
            "parameters": {
                "type": "object",
                "properties": {
                    "repo": {
                        "type": "string",
                        "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                        "type": "string",
                        "description": "The query to search for repo. Should contain all relevant context."
                    }
                },
                "required": [
                    "repo",
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "install_extension",
            "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
            "parameters": {
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                },
                "required": [
                    "id",
                    "name"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "list_code_usages",
            "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
            "parameters": {
                "type": "object",
                "properties": {
                    "symbolName": {
                        "type": "string",
                        "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                        "type": "array",
                        "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "required": [
                    "symbolName"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "list_dir",
            "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
            "parameters": {
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The absolute path to the directory to list."
                    }
                },
                "required": [
                    "path"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "open_simple_browser",
            "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
            "parameters": {
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                    }
                },
                "required": [
                    "url"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "read_file",
            "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "description": "The absolute path of the file to read.",
                        "type": "string"
                    },
                    "startLine": {
                        "type": "number",
                        "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                        "type": "number",
                        "description": "The inclusive line number to end reading at, 1-based."
                    }
                },
                "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "read_notebook_cell_output",
            "description": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "cellId": {
                        "type": "string",
                        "description": "The ID of the cell for which output should be retrieved."
                    }
                },
                "required": [
                    "filePath",
                    "cellId"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "replace_string_in_file",
            "description": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the file to edit."
                    },
                    "oldString": {
                        "type": "string",
                        "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                    },
                    "newString": {
                        "type": "string",
                        "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                    }
                },
                "required": [
                    "filePath",
                    "oldString",
                    "newString"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "run_notebook_cell",
            "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                        "type": "string",
                        "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                        "type": "string",
                        "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                        "type": "boolean",
                        "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                },
                "required": [
                    "filePath",
                    "cellId"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "run_vscode_command",
            "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
            "parameters": {
                "type": "object",
                "properties": {
                    "commandId": {
                        "type": "string",
                        "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                        "type": "array",
                        "description": "The arguments to pass to the command. This should be an array of strings.",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "required": [
                    "commandId",
                    "name"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "semantic_search",
            "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "test_failure",
            "description": "Includes test failure information in the prompt."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "vscode_searchExtensions_internal",
            "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
            "parameters": {
                "type": "object",
                "properties": {
                    "category": {
                        "type": "string",
                        "description": "The category of extensions to search for",
                        "enum": [
                            "AI",
                            "Azure",
                            "Chat",
                            "Data Science",
                            "Debuggers",
                            "Extension Packs",
                            "Education",
                            "Formatters",
                            "Keymaps",
                            "Language Packs",
                            "Linters",
                            "Machine Learning",
                            "Notebooks",
                            "Programming Languages",
                            "SCM Providers",
                            "Snippets",
                            "Testing",
                            "Themes",
                            "Visualization",
                            "Other"
                        ]
                    },
                    "keywords": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The keywords to search for"
                    },
                    "ids": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The ids of the extensions to search for"
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_and_run_task",
            "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "workspaceFolder": {
                        "type": "string",
                        "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                        "type": "object",
                        "description": "The task to add to the new tasks.json file.",
                        "properties": {
                            "label": {
                                "type": "string",
                                "description": "The label of the task."
                            },
                            "type": {
                                "type": "string",
                                "description": "The type of the task. The only supported value is 'shell'.",
                                "enum": [
                                    "shell"
                                ]
                            },
                            "command": {
                                "type": "string",
                                "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                            },
                            "args": {
                                "type": "array",
                                "description": "The arguments to pass to the command.",
                                "items": {
                                    "type": "string"
                                }
                            },
                            "isBackground": {
                                "type": "boolean",
                                "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                            },
                            "problemMatcher": {
                                "type": "array",
                                "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                                "items": {
                                    "type": "string"
                                }
                            },
                            "group": {
                                "type": "string",
                                "description": "The group to which the task belongs."
                            }
                        },
                        "required": [
                            "label",
                            "type",
                            "command"
                        ]
                    }
                },
                "required": [
                    "task",
                    "workspaceFolder"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_task_output",
            "description": "Get the output of a task",
            "parameters": {
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The task ID for which to get the output."
                    },
                    "workspaceFolder": {
                        "type": "string",
                        "description": "The workspace folder path containing the task"
                    }
                },
                "required": [
                    "id",
                    "workspaceFolder"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_terminal_output",
            "description": "Get the output of a terminal command previously started with run_in_terminal",
            "parameters": {
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the terminal to check."
                    }
                },
                "required": [
                    "id"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "manage_todo_list",
            "description": "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
            "parameters": {
                "type": "object",
                "properties": {
                    "todoList": {
                        "type": "array",
                        "description": "Complete array of all todo items (required for write operation, ignored for read). Must include ALL items - both existing and new.",
                        "items": {
                            "type": "object",
                            "properties": {
                                "id": {
                                    "type": "number",
                                    "description": "Unique identifier for the todo. Use sequential numbers starting from 1."
                                },
                                "title": {
                                    "type": "string",
                                    "description": "Concise action-oriented todo label (3-7 words). Displayed in UI."
                                },
                                "status": {
                                    "type": "string",
                                    "enum": [
                                        "not-started",
                                        "in-progress",
                                        "completed"
                                    ],
                                    "description": "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
                                }
                            },
                            "required": [
                                "id",
                                "title",
                                "status"
                            ]
                        }
                    },
                    "operation": {
                        "type": "string",
                        "enum": [
                            "write",
                            "read"
                        ],
                        "description": "write: Replace entire todo list with new content. read: Retrieve current todo list. ALWAYS provide complete list when writing - partial updates not supported."
                    }
                },
                "required": [
                    "operation"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "run_in_terminal",
            "description": "This tool allows you to execute shell commands in a persistent bash terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Use && to chain simple commands on one line\n- Prefer pipelines | over temporary files for data flow\n- Never create a sub-shell (eg. bash -c \"command\") unless explicitly asked\n\nDirectory Management:\n- Must use absolute paths to avoid navigation issues\n- Use $PWD for current directory references\n- Consider using pushd/popd for directory stack management\n- Supports directory shortcuts like ~ and -\n\nProgram Execution:\n- Supports Python, Node.js, and other executables\n- Install packages via package managers (brew, apt, etc.)\n- Use which or command -v to verify command availability\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true\n- Returns a terminal ID for checking status and runtime later\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use head, tail, grep, awk to filter and limit output size\n- For pager commands, disable paging: git --no-pager or add | cat\n- Use wc -l to count lines before displaying large outputs\n\nBest Practices:\n- Quote variables: \"$var\" instead of $var to handle spaces\n- Use find with -exec or xargs for file operations\n- Be specific with commands to avoid excessive output\n- Use [[ ]] for conditional tests instead of [ ]\n- Prefer $() over backticks for command substitution\n- Use set -e at start of complex commands to exit on errors",
            "parameters": {
                "type": "object",
                "properties": {
                    "command": {
                        "type": "string",
                        "description": "The command to run in the terminal."
                    },
                    "explanation": {
                        "type": "string",
                        "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "isBackground": {
                        "type": "boolean",
                        "description": "Whether the command starts a background process. If true, the command will run in the background and you will not see the output. If false, the tool call will block on the command finishing, and then you will get the output. Examples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    }
                },
                "required": [
                    "command",
                    "explanation",
                    "isBackground"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "run_task",
            "description": "Runs a VS Code task.\n\n- If you see that an appropriate task exists for building or running code, prefer to use this tool to run the task instead of using the run_in_terminal tool.\n- Make sure that any appropriate build or watch task is running before trying to run tests or execute code.\n- If the user asks to run a task, use this tool to do so.",
            "parameters": {
                "type": "object",
                "properties": {
                    "workspaceFolder": {
                        "type": "string",
                        "description": "The workspace folder path containing the task"
                    },
                    "id": {
                        "type": "string",
                        "description": "The task ID to run."
                    }
                },
                "required": [
                    "workspaceFolder",
                    "id"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "runSubagent",
            "description": "Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.\n\n- Agents do not run async or in the background, you will wait for the agent's result.\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n- The agent's outputs should generally be trusted\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent",
            "parameters": {
                "type": "object",
                "properties": {
                    "prompt": {
                        "type": "string",
                        "description": "A detailed description of the task for the agent to perform"
                    },
                    "description": {
                        "type": "string",
                        "description": "A short (3-5 word) description of the task"
                    }
                },
                "required": [
                    "prompt",
                    "description"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "terminal_last_command",
            "description": "Get the last command run in the active terminal."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "terminal_selection",
            "description": "Get the current selection in the active terminal."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "configure_notebook",
            "description": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "description": "The absolute path of the notebook with the active kernel.",
                        "type": "string"
                    }
                },
                "required": [
                    "filePath"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "notebook_install_packages",
            "description": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "description": "The absolute path of the notebook with the active kernel.",
                        "type": "string"
                    },
                    "packageList": {
                        "description": "A list of packages to install.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "required": [
                    "filePath",
                    "packageList"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "notebook_list_packages",
            "description": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "description": "The absolute path of the notebook with the active kernel.",
                        "type": "string"
                    }
                },
                "required": [
                    "filePath"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "configure_python_environment",
            "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                },
                "required": []
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_python_environment_details",
            "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace to get the environment information for."
                    }
                },
                "required": []
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_python_executable_details",
            "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                },
                "required": []
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "install_python_packages",
            "description": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "packageList": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of Python packages to install."
                    },
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                },
                "required": [
                    "packageList"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_container_management_tools",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThis group of tools is focused on managing the lifecycle of containers within a containerization platform. The tools allow users to start, stop, restart, or remove containers using their names or IDs, providing essential control over running applications. Additionally, users can run new containers, enabling the deployment of new instances of applications or services as needed. Together, these tools facilitate the dynamic management of containerized environments, allowing for efficient resource utilization and application scalability.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_image_management_tools",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThe tools in this group are designed for managing container images, which are essential for creating and deploying containers. Users can pull new images from repositories or remove existing ones, ensuring that the local environment is up-to-date with the necessary application versions. The ability to inspect images allows users to understand their configurations and dependencies, while tagging images with new identifiers helps in organizing and versioning them effectively. These functionalities are crucial for maintaining a clean and efficient image repository, supporting continuous integration and deployment workflows.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_container_inspection_and_logging_tools",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThis group provides tools for inspecting and monitoring the performance of containers. Users can inspect containers to retrieve detailed information about their configurations, statuses, and resource usage. Additionally, the ability to view logs for specific containers allows for troubleshooting and performance analysis, helping users identify issues and optimize their applications. By combining inspection and logging capabilities, these tools enable developers and system administrators to maintain the health and efficiency of their containerized applications.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_container_inventory_tools",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThe tools in this group focus on inventory management for containers, images, and volumes. Users can list all containers, including those that are stopped, which aids in monitoring resource usage and managing application states. Similarly, listing container images provides visibility into available images, including untagged and orphaned ones, which can help in cleaning up unused resources. Additionally, listing container volumes allows users to manage persistent data storage associated with containers. Together, these tools provide a comprehensive overview of the container ecosystem, facilitating better resource management and operational efficiency.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_copilot_conta_list_networks",
            "description": "List container networks",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_copilot_conta_prune",
            "description": "Prune unused container resources",
            "parameters": {
                "type": "object",
                "properties": {
                    "pruneTarget": {
                        "type": "string",
                        "enum": [
                            "containers",
                            "images",
                            "volumes",
                            "networks",
                            "all"
                        ],
                        "description": "The type of resource to prune"
                    }
                },
                "required": [
                    "pruneTarget"
                ],
                "additionalProperties": false,
                "$schema": "http://json-schema.org/draft-07/schema#"
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_add_or_commit",
            "description": "Add file contents to the index (git add <pathspec>) OR record changes to the repository (git commit -m <message> [files...]). Use the 'action' parameter to specify which action to perform.",
            "parameters": {
                "type": "object",
                "properties": {
                    "action": {
                        "description": "The action to perform: 'add' or 'commit'",
                        "enum": [
                            "add",
                            "commit"
                        ],
                        "type": "string"
                    },
                    "directory": {
                        "description": "The directory to run git add or commit in",
                        "type": "string"
                    },
                    "files": {
                        "description": "Optional array of files to add or commit. If omitted, all files are added or all staged changes are committed.",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "message": {
                        "description": "The commit message (required if action is 'commit')",
                        "type": "string"
                    }
                },
                "required": [
                    "directory",
                    "action"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_blame",
            "description": "Show what revision and author last modified each line of a file (git blame <file>).",
            "parameters": {
                "type": "object",
                "properties": {
                    "directory": {
                        "description": "The directory to run git blame in",
                        "type": "string"
                    },
                    "file": {
                        "description": "The file to blame",
                        "type": "string"
                    }
                },
                "required": [
                    "directory",
                    "file"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_branch",
            "description": "List or create branches (git branch).",
            "parameters": {
                "type": "object",
                "properties": {
                    "action": {
                        "description": "Git branch action to be executed",
                        "enum": [
                            "create",
                            "list"
                        ],
                        "type": "string"
                    },
                    "branch_name": {
                        "description": "(Optional) Name of the branch to create or delete",
                        "type": "string"
                    },
                    "directory": {
                        "description": "The directory to run git branch in",
                        "type": "string"
                    }
                },
                "required": [
                    "directory",
                    "action"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_checkout",
            "description": "Switch branches or restore working tree files (git checkout <branch>).",
            "parameters": {
                "type": "object",
                "properties": {
                    "branch": {
                        "description": "The branch to checkout. This must be a valid branch name without spaces",
                        "type": "string"
                    },
                    "directory": {
                        "description": "The directory to run git checkout in",
                        "type": "string"
                    }
                },
                "required": [
                    "directory",
                    "branch"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_log_or_diff",
            "description": "Show commit logs or changes between commits (git log --oneline or git diff).",
            "parameters": {
                "type": "object",
                "properties": {
                    "action": {
                        "description": "The action to perform: 'log' for commit logs or 'diff' for changes",
                        "enum": [
                            "log",
                            "diff"
                        ],
                        "type": "string"
                    },
                    "commit": {
                        "description": "Optional commit to compare against HEAD for 'diff', defaults to HEAD",
                        "type": "string"
                    },
                    "directory": {
                        "description": "The directory to run the command in",
                        "type": "string"
                    }
                },
                "required": [
                    "directory",
                    "action"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_push",
            "description": "Update remote refs along with associated objects (git push).",
            "parameters": {
                "type": "object",
                "properties": {
                    "directory": {
                        "description": "The directory to run git push in",
                        "type": "string"
                    }
                },
                "required": [
                    "directory"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_stash",
            "description": "Stash the changes in a dirty working directory (git stash).",
            "parameters": {
                "type": "object",
                "properties": {
                    "directory": {
                        "description": "The directory to run git stash in",
                        "type": "string"
                    },
                    "name": {
                        "description": "Optional name for the stash (used as the stash message)",
                        "type": "string"
                    }
                },
                "required": [
                    "directory"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_status",
            "description": "Show the working tree status (git status).",
            "parameters": {
                "type": "object",
                "properties": {
                    "directory": {
                        "description": "The directory to run git status in",
                        "type": "string"
                    }
                },
                "required": [
                    "directory"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_git_worktree",
            "description": "List or add git worktrees (git worktree <action>).",
            "parameters": {
                "type": "object",
                "properties": {
                    "action": {
                        "description": "Git worktree action to be executed",
                        "enum": [
                            "list",
                            "add"
                        ],
                        "type": "string"
                    },
                    "branch": {
                        "description": "(Optional) Existing branch for the new worktree (used for add)",
                        "type": "string"
                    },
                    "directory": {
                        "description": "The directory to run git worktree in",
                        "type": "string"
                    },
                    "path": {
                        "description": "(Optional) Path for the worktree (required for add)",
                        "type": "string"
                    }
                },
                "required": [
                    "directory",
                    "action"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_gitkraken_workspace_list",
            "description": " Lists all Gitkraken workspaces",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_issues_add_comment",
            "description": "Add a comment to an issue",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_organization": {
                        "description": "Optionally set the Azure DevOps organization name. Required for Azure DevOps",
                        "type": "string"
                    },
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name. Required for Azure DevOps",
                        "type": "string"
                    },
                    "comment": {
                        "description": "The text content of the comment",
                        "type": "string"
                    },
                    "issue_id": {
                        "description": "The ID of the issue to comment on",
                        "type": "string"
                    },
                    "provider": {
                        "description": "Specify the issue provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "jira",
                            "azure",
                            "linear"
                        ],
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Repository name. This is required for GitHub and GitLab",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Organization name. This is required for GitHub and GitLab",
                        "type": "string"
                    }
                },
                "required": [
                    "provider",
                    "issue_id",
                    "comment"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_issues_assigned_to_me",
            "description": "Fetch issues assigned to the user",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_organization": {
                        "description": "Optionally set the Azure DevOps organization name. Required for Azure DevOps",
                        "type": "string"
                    },
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name. Required for Azure DevOps",
                        "type": "string"
                    },
                    "page": {
                        "description": "Optional parameter to specify the page number, defaults to 1",
                        "type": "number"
                    },
                    "provider": {
                        "description": "Specify the issue provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "jira",
                            "azure",
                            "linear"
                        ],
                        "type": "string"
                    }
                },
                "required": [
                    "provider"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_issues_get_detail",
            "description": "Retrieve detailed information about a specific issue by its unique ID",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_organization": {
                        "description": "Optionally set the Azure DevOps organization name. Required for Azure DevOps",
                        "type": "string"
                    },
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name. Required for Azure DevOps",
                        "type": "string"
                    },
                    "issue_id": {
                        "description": "The ID of the issue to retrieve",
                        "type": "string"
                    },
                    "provider": {
                        "description": "Specify the issue provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "jira",
                            "azure",
                            "linear"
                        ],
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Repository name. This is required for GitHub and GitLab",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Organization name. This is required for GitHub and GitLab",
                        "type": "string"
                    }
                },
                "required": [
                    "provider",
                    "issue_id"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_pull_request_assigned_to_me",
            "description": "Search pull requests where you are the assignee, author, or reviewer",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name of the pull request. Required for Azure DevOps",
                        "type": "string"
                    },
                    "is_closed": {
                        "description": "Set to true if you want to search for closed pull requests",
                        "type": "boolean"
                    },
                    "page": {
                        "description": "Optional parameter to specify the page number, defaults to 1",
                        "type": "number"
                    },
                    "provider": {
                        "description": "Specify the git provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "bitbucket",
                            "azure"
                        ],
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Set the repository name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Set the organization name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    }
                },
                "required": [
                    "provider"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_pull_request_create",
            "description": "Create a new pull request",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name of the pull request. Required for Azure DevOps",
                        "type": "string"
                    },
                    "body": {
                        "description": "The body/description of the pull request",
                        "type": "string"
                    },
                    "is_draft": {
                        "description": "Create as draft pull request",
                        "type": "boolean"
                    },
                    "provider": {
                        "description": "Specify the git provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "bitbucket",
                            "azure"
                        ],
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Set the repository name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Set the organization name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    },
                    "source_branch": {
                        "description": "Source branch from which the pull request will be created",
                        "type": "string"
                    },
                    "target_branch": {
                        "description": "Target branch where the pull request will be merged",
                        "type": "string"
                    },
                    "title": {
                        "description": "The title of the pull request",
                        "type": "string"
                    }
                },
                "required": [
                    "repository_name",
                    "repository_organization",
                    "title",
                    "source_branch",
                    "target_branch",
                    "provider"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_pull_request_create_review",
            "description": "Create a review for a pull request",
            "parameters": {
                "type": "object",
                "properties": {
                    "approve": {
                        "description": "Set to true if you want to approve the pull request",
                        "type": "boolean"
                    },
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name of the pull request. Required for Azure DevOps",
                        "type": "string"
                    },
                    "provider": {
                        "description": "Specify the git provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "bitbucket",
                            "azure"
                        ],
                        "type": "string"
                    },
                    "pull_request_id": {
                        "description": "ID of the pull request to create the review for",
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Set the repository name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Set the organization name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    },
                    "review": {
                        "description": "Comment to add to the pull request review",
                        "type": "string"
                    }
                },
                "required": [
                    "repository_name",
                    "repository_organization",
                    "pull_request_id",
                    "review",
                    "provider"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_pull_request_get_comments",
            "description": "Get all the comments in a pull requests",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name of the pull request. Required for Azure DevOps",
                        "type": "string"
                    },
                    "provider": {
                        "description": "Specify the git provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "bitbucket",
                            "azure"
                        ],
                        "type": "string"
                    },
                    "pull_request_id": {
                        "description": "ID of the pull request to add the comment to",
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Set the repository name of the pull request",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Set the organization name of the pull request",
                        "type": "string"
                    }
                },
                "required": [
                    "repository_name",
                    "repository_organization",
                    "pull_request_id",
                    "provider"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_pull_request_get_detail",
            "description": "Get an specific pull request",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name of the pull request. Required for Azure DevOps",
                        "type": "string"
                    },
                    "provider": {
                        "description": "Specify the git provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "bitbucket",
                            "azure"
                        ],
                        "type": "string"
                    },
                    "pull_request_files": {
                        "description": "Set to true if you want to retrieve the files changed in the pull request. Not supported by Azure DevOps.",
                        "type": "boolean"
                    },
                    "pull_request_id": {
                        "description": "ID of the pull request to retrieve",
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Set the repository name of the pull request",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Set the organization name of the pull request",
                        "type": "string"
                    }
                },
                "required": [
                    "pull_request_id",
                    "repository_name",
                    "repository_organization",
                    "provider"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_gitkraken_repository_get_file_content",
            "description": "Get file content from a repository",
            "parameters": {
                "type": "object",
                "properties": {
                    "azure_project": {
                        "description": "Optionally set the Azure DevOps project name of the pull request. Required for Azure DevOps",
                        "type": "string"
                    },
                    "file_path": {
                        "description": "File path to retrieve from the repository",
                        "type": "string"
                    },
                    "provider": {
                        "description": "Specify the git provider",
                        "enum": [
                            "github",
                            "gitlab",
                            "bitbucket",
                            "azure"
                        ],
                        "type": "string"
                    },
                    "ref": {
                        "description": "Set the branch, tag, or commit SHA to retrieve the file from",
                        "type": "string"
                    },
                    "repository_name": {
                        "description": "Set the repository name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    },
                    "repository_organization": {
                        "description": "Set the organization name of the pull request. Required for Azure DevOps and Bitbucket",
                        "type": "string"
                    }
                },
                "required": [
                    "repository_name",
                    "repository_organization",
                    "ref",
                    "file_path",
                    "provider"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_python_code_validation_and_execution",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThis group of tools focuses on validating and executing Python code snippets within a workspace environment. The 'Check Python file for syntax errors' tool allows users to identify syntax issues in Python files, providing detailed error messages that include line numbers and error types. This is particularly useful for debugging and validating code before execution. The 'Execute Python code snippets directly in the workspace environment' tool enables users to run Python code snippets seamlessly, avoiding common issues associated with terminal execution, such as shell escaping. It provides clean output and is ideal for quick testing and validation of code. Additionally, the 'Validate Python code snippets for syntax errors without saving to file' tool allows for quick checks of code snippets, making it easier to validate generated or user-provided code before running it. Together, these tools streamline the process of writing, testing, and debugging Python code in a cohesive workspace setting.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_python_import_analysis_tools",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThis group is dedicated to analyzing and managing Python imports within a workspace. The 'Analyze imports across workspace user files' tool helps users identify all top-level modules that are imported in their project, including both resolved and unresolved imports. This is essential for understanding project dependencies and identifying any missing packages. The 'Get available top-level modules from installed Python packages in environment' tool complements this by providing a list of all modules that can be imported from the installed packages, allowing users to verify the availability of necessary libraries. Together, these tools facilitate a comprehensive understanding of import patterns and dependencies, enabling users to manage their Python projects more effectively.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_python_environment_management",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThis group of tools is focused on managing Python environments within a workspace. The 'Get Python environment information for workspace' tool provides users with insights into the current active Python environment and all available environments, which is crucial for troubleshooting environment-related issues. The 'Get current Python analysis settings and configuration for a workspace' tool allows users to review their Python analysis settings, helping to diagnose any configuration problems that may arise. Additionally, the 'Switch active Python environment for workspace' tool enables users to easily change their active Python environment, whether switching between different Python installations or virtual environments. Together, these tools empower users to effectively manage their Python environments, ensuring that they can work with the correct settings and dependencies for their projects.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "activate_workspace_structure_and_file_management",
            "description": "Call this tool when you need access to a new category of tools. The category of tools is described as follows:\n\nThis group provides tools for understanding and managing the structure of a Python workspace. The 'Get workspace root directories' tool allows users to retrieve the root directories of their workspace, which is essential for navigating and organizing project files. The 'Get list of all user Python files in workspace' tool complements this by providing a comprehensive list of all user-created Python files, excluding library and dependency files. This tool respects user-defined settings for file inclusion and exclusion, making it easier to analyze and operate on relevant code. Together, these tools enhance users' ability to navigate their workspace, manage their files effectively, and gain insights into their project structure, ultimately leading to a more organized and efficient development process.\n\nBe sure to call this tool if you need a capability related to the above."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_pylance_mcp_s_pylanceDocuments",
            "description": "Search Pylance documentation for Python language server help, configuration guidance, feature explanations, and troubleshooting. Returns comprehensive answers about Pylance settings, capabilities, and usage. Use when users ask: How to configure Pylance? What features are available? How to fix Pylance issues?",
            "parameters": {
                "type": "object",
                "properties": {
                    "search": {
                        "type": "string",
                        "description": "Detailed question in natural language. Think of it as a prompt for an LLM. Do not use keyword search terms."
                    }
                },
                "required": [
                    "search"
                ],
                "additionalProperties": false,
                "$schema": "http://json-schema.org/draft-07/schema#"
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_pylance_mcp_s_pylanceInvokeRefactoring",
            "description": "Apply automated code refactoring to Python files. Returns refactored content (does not modify original file) unless mode is \"update\". Use for: extracting functions, organizing imports, improving code structure, applying refactoring patterns.  Optional \"mode\" parameter: \"update\" updates the file, \"edits\" returns a WorkspaceEdit, \"string\" returns updated content as string. If mode is not specified, \"update\" will be used as the default. The \"edits\" mode is helpful for determining if a file needs changes (for example, to remove unused imports or fix import formatting) without making any modifications; if no changes are needed, the result will be either an empty WorkspaceEdit or a message indicating that no text edits were found. Available refactorings: source.unusedImports: - Removes all unused import statements from a Python file. Use when imports are imported but never referenced in the code. Requires fileUri parameter pointing to a Python file with unused imports.\nsource.convertImportFormat: - Converts import statements between absolute and relative formats according to python.analysis.importFormat setting. Use when import format consistency is needed. Requires fileUri parameter pointing to a Python file with imports to convert.\nsource.convertImportStar: - Converts all wildcard imports (from module import *) to explicit imports listing all imported symbols. Use when explicit imports are preferred for better code clarity and IDE support. Requires fileUri parameter pointing to a Python file with wildcard imports.\nsource.addTypeAnnotation: - Adds type annotations to all variables and functions in a Python file that can be inferred from their usage. Use when type hints are needed for better type checking and code clarity. Requires fileUri parameter pointing to a Python file with unannotated variables or functions.\nsource.fixAll.pylance: - Applies all available automatic code fixes from python.analysis.fixAll setting. Use when multiple code issues need to be addressed simultaneously. Requires fileUri parameter pointing to a Python file with fixable issues.",
            "parameters": {
                "type": "object",
                "properties": {
                    "fileUri": {
                        "type": "string",
                        "description": "The uri of the file to invoke the refactoring."
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the refactoring to invoke. This must be one of these [source.unusedImports, source.convertImportFormat, source.convertImportStar, source.addTypeAnnotation, source.fixAll.pylance]"
                    },
                    "mode": {
                        "type": "string",
                        "enum": [
                            "update",
                            "edits",
                            "string"
                        ],
                        "description": "Determines the output mode: \"update\" updates the file directly, \"edits\" returns a WorkspaceEdit, \"string\" returns the updated content as a string. If omitted, \"update\" will be used as the default. The \"edits\" mode is especially useful for checking if any changes are needed (such as unused imports or import formatting issues) without modifying the file, as it will return a WorkspaceEdit only if edits are required."
                    }
                },
                "required": [
                    "fileUri",
                    "name"
                ],
                "additionalProperties": false,
                "$schema": "http://json-schema.org/draft-07/schema#"
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_copilot_conta_list_images",
            "description": "List container images, including untagged and orphaned ones",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_pylance_mcp_s_pylanceWorkspaceRoots",
            "description": "Get workspace root directories. Returns workspace root for specific file or all workspace roots if no file provided. Use for: understanding workspace structure, getting paths for other operations.",
            "parameters": {
                "type": "object",
                "properties": {
                    "fileUri": {
                        "type": "string",
                        "description": "The uri of the file to check its workspace"
                    }
                },
                "additionalProperties": false,
                "$schema": "http://json-schema.org/draft-07/schema#"
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_copilot_conta_act_image",
            "description": "Pull or remove a container image by name or ID",
            "parameters": {
                "type": "object",
                "properties": {
                    "imageNameOrId": {
                        "type": "string",
                        "description": "The container image name or ID"
                    },
                    "action": {
                        "type": "string",
                        "enum": [
                            "pull",
                            "remove"
                        ],
                        "description": "The action to perform on the container image"
                    }
                },
                "required": [
                    "imageNameOrId",
                    "action"
                ],
                "additionalProperties": false,
                "$schema": "http://json-schema.org/draft-07/schema#"
            }
        },
        "type": "function"
    }
]
Request Messages
System
Your task is to create a comprehensive, detailed summary of the entire conversation that captures all essential information needed to seamlessly continue the work without any loss of context. This summary will be used to compact the conversation while preserving critical technical details, decisions, and progress.
## Recent Context Analysis
Pay special attention to the most recent agent commands and tool executions that led to this summarization being triggered. Include:
- **Last Agent Commands**: What specific actions/tools were just executed
- **Tool Results**: Key outcomes from recent tool calls (truncate if very long, but preserve essential information)
- **Immediate State**: What was the system doing right before summarization
- **Triggering Context**: What caused the token budget to be exceeded
## Analysis Process
Before providing your final summary, wrap your analysis in `<analysis>` tags to organize your thoughts systematically:
1. **Chronological Review**: Go through the conversation chronologically, identifying key phases and transitions
2. **Intent Mapping**: Extract all explicit and implicit user requests, goals, and expectations
3. **Technical Inventory**: Catalog all technical concepts, tools, frameworks, and architectural decisions
4. **Code Archaeology**: Document all files, functions, and code patterns that were discussed or modified
5. **Progress Assessment**: Evaluate what has been completed vs. what remains pending
6. **Context Validation**: Ensure all critical information for continuation is captured
7. **Recent Commands Analysis**: Document the specific agent commands and tool results from the most recent operations
## Summary Structure
Your summary must include these sections in order, following the exact format below:
<analysis>
[Chronological Review: Walk through conversation phases: initial request â†’ exploration â†’ implementation â†’ debugging â†’ current state]
[Intent Mapping: List each explicit user request with message context]
[Technical Inventory: Catalog all technologies, patterns, and decisions mentioned]
[Code Archaeology: Document every file, function, and code change discussed]
[Progress Assessment: What's done vs. pending with specific status]
[Context Validation: Verify all continuation context is captured]
[Recent Commands Analysis: Last agent commands executed, tool results (truncated if long), immediate pre-summarization state]

</analysis>

<summary>
1. Conversation Overview:
- Primary Objectives: [All explicit user requests and overarching goals with exact quotes]
- Session Context: [High-level narrative of conversation flow and key phases]
- User Intent Evolution: [How user's needs or direction changed throughout conversation]
2. Technical Foundation:
- [Core Technology 1]: [Version/details and purpose]
- [Framework/Library 2]: [Configuration and usage context]
- [Architectural Pattern 3]: [Implementation approach and reasoning]
- [Environment Detail 4]: [Setup specifics and constraints]
3. Codebase Status:
- [File Name 1]:
- Purpose: [Why this file is important to the project]
- Current State: [Summary of recent changes or modifications]
- Key Code Segments: [Important functions/classes with brief explanations]
- Dependencies: [How this relates to other components]
- [File Name 2]:
- Purpose: [Role in the project]
- Current State: [Modification status]
- Key Code Segments: [Critical code blocks]
- [Additional files as needed]
4. Problem Resolution:
- Issues Encountered: [Technical problems, bugs, or challenges faced]
- Solutions Implemented: [How problems were resolved and reasoning]
- Debugging Context: [Ongoing troubleshooting efforts or known issues]
- Lessons Learned: [Important insights or patterns discovered]
5. Progress Tracking:
- Completed Tasks: [What has been successfully implemented with status indicators]
- Partially Complete Work: [Tasks in progress with current completion status]
- Validated Outcomes: [Features or code confirmed working through testing]
6. Active Work State:
- Current Focus: [Precisely what was being worked on in most recent messages]
- Recent Context: [Detailed description of last few conversation exchanges]
- Working Code: [Code snippets being modified or discussed recently]
- Immediate Context: [Specific problem or feature being addressed before summary]
7. Recent Operations:
- Last Agent Commands: [Specific tools/actions executed just before summarization with exact command names]
- Tool Results Summary: [Key outcomes from recent tool executions - truncate long results but keep essential info]
- Pre-Summary State: [What the agent was actively doing when token budget was exceeded]
- Operation Context: [Why these specific commands were executed and their relationship to user goals]
8. Continuation Plan:
- [Pending Task 1]: [Details and specific next steps with verbatim quotes]
- [Pending Task 2]: [Requirements and continuation context]
- [Priority Information]: [Which tasks are most urgent or logically sequential]
- [Next Action]: [Immediate next step with direct quotes from recent messages]

</summary>

## Quality Guidelines
- **Precision**: Include exact filenames, function names, variable names, and technical terms
- **Completeness**: Capture all context needed to continue without re-reading the full conversation
- **Clarity**: Write for someone who needs to pick up exactly where the conversation left off
- **Verbatim Accuracy**: Use direct quotes for task specifications and recent work context
- **Technical Depth**: Include enough detail for complex technical decisions and code patterns
- **Logical Flow**: Present information in a way that builds understanding progressively
This summary should serve as a comprehensive handoff document that enables seamless continuation of all active work streams while preserving the full technical and contextual richness of the original conversation.

User
<attachments>
<attachment id="COMFYUI_RAW_DOCS.md" isSummarized="true" filePath="c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\COMFYUI_RAW_DOCS.md">
# Server Overview

## Overview

The Comfy server runs on top of the [aiohttp framework](https://docs.aiohttp.org/), which in turn uses [asyncio](https://pypi.org/project/asyncio/).

Messages from the server to the client are sent by socket messages through the `send_sync` method of the server,
which is an instance of `PromptServer` (defined in `server.py`). They are processed
by a socket event listener registered in `api.js`. See [messages](/development/comfyui-server/comms_messages).

Messages from the client to the server are sent by the `api.fetchApi()` method defined in `api.js`,
and are handled by http routes defined by the server. See [routes](/development/comfyui-server/comms_routes).

<Tip>The client submits the whole workflow (widget values and all) when you queue a request.
The server does not receive any changes you make after you send a request to the queue.
If you want to modify server behavior during execution, you'll need routes.</Tip>


---

> To find navigation and other pages in this documentation, fetch the llms.txt file at: https://docs.comfy.org/llms.**txt**


# Messages

## Messages

During execution (or when the state of the queue changes), the `PromptExecutor` sends messages back to the client
through the `send_sync` method of `PromptServer`.

These messages are received by a socket event listener defined in `api.js` (at time of writing around line 90, or search for `this.socket.addEventListener`),
which creates a `CustomEvent` object for any known message type, and dispatches it to any registered listeners.

An extension can register to receive events (normally done in the `setup()` function) following the standard Javascript idiom:

```Javascript  theme={null}
api.addEventListener(message_type, messageHandler);
```

If the `message_type` is not one of the built in ones, it will be added to the list of known message types automatically. The message `messageHandler`
will be called with a `CustomEvent` object, which extends the event raised by the socket to add a `.detail` property, which is a dictionary of
the data sent by the server. So usage is generally along the lines of:

```Javascript  theme={null}
function messageHandler(event) {
    if (event.detail.node == aNodeIdThatIsInteresting) {/* Lines 47-48 omitted */}
}
```

### Built in message types

During execution (or when the state of the queue changes), the `PromptExecutor` sends the following messages back to the client
through the `send_sync` method of `PromptServer`. An extension can register as a listener for any of these.

| event                   | when                                                                       | data                                                                                                    |
| ----------------------- | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| `execution_start`       | When a prompt is about to run                                              | `prompt_id`                                                                                             |
| `execution_error`       | When an error occurs during execution                                      | `prompt_id`, plus additional information                                                                |
| `execution_interrupted` | When execution is stopped by a node raising `InterruptProcessingException` | `prompt_id`, `node_id`, `node_type` and `executed` (a list of executed nodes)                           |
| `execution_cached`      | At the start of execution                                                  | `prompt_id`, `nodes` (a list of nodes which are being skipped because their cached outputs can be used) |
| `execution_success`     | When all nodes from the prompt have been successfully executed             | `prompt_id`, `timestamp`                                                                                |
| `executing`             | When a new node is about to be executed                                    | `node` (node id or `None` to indicate completion), `prompt_id`                                          |
| `executed`              | When a node returns a ui element                                           | `node` (node id), `prompt_id`, `output`                                                                 |
| `progress`              | During execution of a node that implements the required hook               | `node` (node id), `prompt_id`, `value`, `max`                                                           |
| `status`                | When the state of the queue changes                                        | `exec_info`, a dictionary holding `queue_remaining`, the number of entries in the queue                 |

### Using executed

Despite the name, an `executed` message is not sent whenever a node completes execution (unlike `executing`), but only when the node
returns a ui update.

To do this, the main function needs to return a dictionary instead of a tuple:

```python  theme={null}
# at the end of my main method
        return { "ui":a_new_dictionary, "result": the_tuple_of_output_values }
```

`a_new_dictionary` will then be sent as the value of `output` in an `executed` message.
The `result` key can be omitted if the node has no outputs (see, for instance, the code for `SaveImage` in `nodes.py`)

### Custom message types

As indicated above, on the client side, a custom message type can be added simply by registering as a listener for a unique message type name.

```Javascript  theme={null}
api.addEventListener("my.custom.message", messageHandler);
```

On the server, the code is equally simple:

```Python  theme={null}
from server import PromptServer
# then, in your main execution function (normally)
        PromptServer.instance.send_sync("my.custom.message", a_dictionary)
```

#### Getting node\_id

Most of the built-in messages include the current node id in the value of `node`. It's likely that you will want to do the same.

The node\_id is available on the server side through a hidden input, which is obtained with the `hidden` key in the `INPUT_TYPES` dictionary:

```Python  theme={null}
    @classmethod    
```
# Routes

## Routes

The server defines a series of `get` and `post` methods
which can be found by searching for `@routes` in `server.py`. When you submit a workflow
in the web client, it is posted to `/prompt` which validates the prompt and adds it to an execution queue,
returning either a `prompt_id` and `number` (the position in the queue), or `error` and `node_errors` if validation fails.
The prompt queue is defined in `execution.py`, which also defines the `PromptExecutor` class.

### Built in routes

`server.py` defines the following routes:

#### Core API Routes

| path                           | get/post/ws | purpose                                                                   |
| ------------------------------ | ----------- | ------------------------------------------------------------------------- |
| `/`                            | get         | load the comfy webpage                                                    |
| `/ws`                          | websocket   | WebSocket endpoint for real-time communication with the server            |
| `/embeddings`                  | get         | retrieve a list of the names of embeddings available                      |
| `/extensions`                  | get         | retrieve a list of the extensions registering a `WEB_DIRECTORY`           |
| `/features`                    | get         | retrieve server features and capabilities                                 |
| `/models`                      | get         | retrieve a list of available model types                                  |
| `/models/{folder}`             | get         | retrieve models in a specific folder                                      |
| `/workflow_templates`          | get         | retrieve a map of custom node modules and associated template workflows   |
| `/upload/image`                | post        | upload an image                                                           |
| `/upload/mask`                 | post        | upload a mask                                                             |
| `/view`                        | get         | view an image. Lots of options, see `@routes.get("/view")` in `server.py` |
| `/view_metadata`/{folder_name} | get         | retrieve metadata for a model                                             |
| `/system_stats`                | get         | retrieve information about the system (python version, devices, vram etc) |
| `/prompt`                      | get         | retrieve current queue status and execution information                   |
| `/prompt`                      | post        | submit a prompt to the queue                                              |
| `/object_info`                 | get         | retrieve details of all node types                                        |
| `/object_info/{node_class}`    | get         | retrieve details of one node type                                         |
| `/history`                     | get         | retrieve the queue history                                                |
| `/history/{prompt_id}`         | get         | retrieve the queue history for a specific prompt                          |
| `/history`                     | post        | clear history or delete history item                                      |
| `/queue`                       | get         | retrieve the current state of the execution queue                         |
| `/queue`                       | post        | manage queue operations (clear pending/running)                           |
| `/interrupt`                   | post        | stop the current workflow execution                                       |
| `/free`                        | post        | free memory by unloading specified models                                 |
| `/userdata`                    | get         | list user data files in a specified directory                             |
| `/v2/userdata`                 | get         | enhanced version that lists files and directories in structured format    |
| `/userdata/{file}`             | get         | retrieve a specific user data file                                        |
| `/userdata/{file}`             | post        | upload or update a user data file                                         |
| `/userdata/{file}`             | delete      | delete a specific user data file                                          |
| `/userdata/{file}/move/{dest}` | post        | move or rename a user data file                                           |
| `/users`                       | get         | get user information                                                      |
| `/users`                       | post        | create a new user (multi-user mode only)                                  |

### WebSocket Communication

The `/ws` endpoint provides real-time bidirectional communication between the client and server. This is used for:

* Receiving execution progress updates
* Getting node execution status in real-time
* Receiving error messages and debugging information
* Live updates when queue status changes

The WebSocket connection sends JSON messages with different types such as:

* `status` - Overall system status updates
* `execution_start` - When a prompt execution begins
* `execution_cached` - When cached results are used
* `executing` - Updates during node execution
* `progress` - Progress updates for long-running operations
* `executed` - When a node completes execution

### Custom routes

If you want to send a message from the client to the server during execution, you will need to add a custom route to the server.
For anything complicated, you will need to dive into the [aiohttp framework docs](https://docs.aiohttp.org/), but most cases can
be handled as follows:

```Python  theme={null}
from server import PromptServer
from aiohttp import web
routes = PromptServer.instance.routes
@routes.post('/my_new_path')
async def my_function(request):
    the_data = await request.post()
    /* Lines 198-200 omitted */
    return web.json_response({})
```

<Tip>Unless you know what you are doing, don't try to define `my_function` within a class.
The `@routes.post` decorator does a lot of work! Instead, define the function as above
and then call a classmethod.</Tip>

<Tip>You can also define a `@routes.get` if you aren't changing anything.</Tip>

The client can use this new route by sending a `FormData` object with code something like this,
which would result in `the_data`, in the above code, containing `message` and `node_id` keys:

```Javascript  theme={null}
import { api } from "../../scripts/api.js";
function send_message(node_id, message) {
    const body = new FormData();
    /* Lines 216-218 omitted */
    api.fetchApi("/my_new_path", { method: "POST", body, });
}
```
# Execution Model Inversion Guide

[PR #2666](https://github.com/comfyanonymous/ComfyUI/pull/2666) inverts the execution model from a back-to-front recursive model to a front-to-back topological sort. While most custom nodes should continue to "just work", this page is intended to serve as a guide for custom node creators to the things that *could* break.

## Breaking Changes

### Monkey Patching

Any code that monkey patched the execution model is likely to stop working. Note that the performance of execution with this PR exceeds that with the most popular monkey patches, so many of them will be unnecessary.

### Optional Input Validation

Prior to this PR, only nodes that were connected to outputs exclusively through a string of `"required"` inputs were actually validated. If you had custom nodes that were only ever connected to `"optional"` inputs, you previously wouldn't have been seeing that they failed validation.

<Tip>If your nodes' outputs could already be connected to `"required"` inputs, it is unlikely that anything in this section applies to you. It will primarily apply to custom node authors who use custom types and exclusively use `"optional"` inputs.</Tip>

Here are some of the things that could cause you to fail validation along with recommended solutions:

* Use of reserved [Additional Parameters](/custom-nodes/backend/datatypes#additional-parameters) like `min` and `max` on types that aren't comparable (e.g. dictionaries) in order to configure custom widgets.
  * Change the additional parameters used to non-reserved keys like `uiMin` and `uiMax`. *(Recommended Solution)*

* Use of composite types (e.g. `CUSTOM_A,CUSTOM_B`)
  * (When used as output) Define and use a wrapper like `MakeSmartType` [seen here in the PR's unit tests](https://github.com/comfyanonymous/ComfyUI/pull/2666/files#diff-714643f1fdb6f8798c45f77ab10d212ca7f41dd71bbe55069f1f9f146a8f0cb9R2)

* The use of lists (e.g. `[1, 2, 3]`) as constants in the graph definition (e.g. to represent a const `VEC3` input). This would have required a front-end extension before. Previously, lists of size exactly `2` would have failed anyway -- they would have been treated as broken links.
  * Wrap the lists in a dictionary like `{ "value": [1, 2, 3] }`

### Execution Order

Execution order has always changed depending on which nodes happen to have which IDs, but it may now change depending on which values are cached as well. In general, the execution order should be considered non-deterministic and subject to change (beyond what is enforced by the graph's structure).

Don't rely on the execution order.

*HIC SUNT DRACONES*

## New Functionality

### Validation Changes

A number of features were added to the `VALIDATE_INPUTS` function in order to lessen the impact of the [Optional Input Validation](#optional-input-validation) mentioned above.

* Default validation will now be skipped for inputs which are received by the `VALIDATE_INPUTS` function.
* The `VALIDATE_INPUTS` function can now take `**kwargs` which causes all inputs to be treated as validated by the node creator.
* The `VALIDATE_INPUTS` function can take an input named `input_types`. This input will be a dict mapping each input (connected via a link) to the type of the connected output. When this argument exists, type validation for the node's inputs is skipped.

You can read more at [VALIDATE\_INPUTS](/custom-nodes/backend/server_overview#validate-inputs).

### Lazy Evaluation

Inputs can be evaluated lazily (i.e. you can wait to see if they are needed before evaluating the attached node and all its ancestors). See [Lazy Evaluation](/custom-nodes/backend/lazy_evaluation) for more information.

### Node Expansion

At runtime, nodes can expand into a subgraph of nodes. This is what allows loops to be implemented (via tail-recursion). See [Node Expansion](/custom-nodes/backend/expansion) for more information.


# Overview

Custom nodes allow you to implement new features and share them with the wider community.

A custom node is like any Comfy node: it takes input, does something to it, and produces an output.
While some custom nodes perform highly complex tasks, many just do one thing. Here's an example of a
simple node that takes an image and inverts it.

<img src="https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=8088073e29e8af1bc700937ecb3b77e9" alt="Unique Images Node" data-og-width="564" width="564" data-og-height="279" height="279" data-path="images/invert_image_node.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=280&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=6fa9f912f38ec608ee43f4e456cedf42 280w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=560&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=aeae6dd8bc6393935ebabe3de4b8ed85 560w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=840&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=3dbe92afa58705aca5f218df9f5c5a52 840w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=1100&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=dfda0a7b67616219ac9b7ec9742cb0d4 1100w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=1650&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=a3b84be0acf1b9248b9ac0086a49bd53 1650w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=2500&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=2113625a7743f680050980330f4f928d 2500w" />

Custom node examplesï¼š

* [cookiecutter-comfy-extension](https://github.com/Comfy-Org/cookiecutter-comfy-extension)
* [ComfyUI-React-Extension-Template](https://github.com/Comfy-Org/ComfyUI-React-Extension-Template)
* [ComfyUI\_frontend\_vue\_basic](https://github.com/jtydhr88/ComfyUI_frontend_vue_basic)

## Client-Server Model

Comfy runs in a client-server model. The server, written in Python, handles all the real work: data-processing, models, image diffusion etc. The client, written in Javascript, handles the user interface.

Comfy can also be used in API mode, in which a workflow is sent to the server by a non-Comfy client (such as another UI, or a command line script).

Custom nodes can be placed into one of four categories:

### Server side only

The majority of Custom Nodes run purely on the server side, by defining a Python class that specifies the input and output types, and provides a function that can be called to process inputs and produce an output.

### Client side only

A few Custom Nodes provide a modification to the client UI, but do not add core functionality. Despite the name, they may not even add new nodes to the system.

### Independent Client and Server

Custom nodes may provide additional server features, and additional (related) UI features (such as a new widget to deal with a new data type). In most cases, communication between the client and server can be handled by the Comfy data flow control.

### Connected Client and Server

In a small number of cases, the UI features and the server need to interact with each other directly.

<Warning>Any node that requires Client-Server communication will not be compatible with use through the API.</Warning>

# Getting Started

This page will take you step-by-step through the process of creating a custom node.

Our example will take a batch of images, and return one of the images. Initially, the node
will return the image which is, on average, the lightest in color; we'll then extend
it to have a range of selection criteria, and then finally add some client side code.

This page assumes very little knowledge of Python or Javascript.

After this walkthrough, dive into the details of [backend code](./backend/server_overview), and
[frontend code](./backend/server_overview).

## Write a basic node

### Prerequisites

* A working ComfyUI [installation](/installation/manual_install). For development, we recommend installing ComfyUI manually.
* A working comfy-cli [installation](/comfy-cli/getting-started).

### Setting up

```bash  theme={null}
cd ComfyUI/custom_nodes
comfy node scaffold
```

After answering a few questions, you'll have a new directory set up.

```bash  theme={null}
 ~  % comfy node scaffold
You've downloaded .cookiecutters/cookiecutter-comfy-extension before. Is it okay to delete and re-download it? [y/n] (y): y
  [1/9] full_name (): Comfy
  /* Lines 406-420 omitted */
  [9/9] include_web_directory_for_custom_javascript [y/n] (n): y
Initialized empty Git repository in firstcomfynode/.git/
âœ“ Custom node project created successfully!
```

### Defining the node

Add the following code to the end of `src/nodes.py`:

```Python src/nodes.py theme={null}
class ImageSelector:
    CATEGORY = "example"
    /* Lines 432-436 omitted */
    FUNCTION = "choose_image"
```

<Info>The basic structure of a custom node is described in detail [here](/custom-nodes/backend/server_overview). </Info>

A custom node is defined using a Python class, which must include these four things: `CATEGORY`,
which specifies where in the add new node menu the custom node will be located,
`INPUT_TYPES`, which is a class method defining what inputs the node will take
(see [later](/custom-nodes/backend/server_overview#input-types) for details of the dictionary returned),
`RETURN_TYPES`, which defines what outputs the node will produce, and `FUNCTION`, the name
of the function that will be called when the node is executed.

<Tip>Notice that the data type for input and output is `IMAGE` (singular) even though
we expect to receive a batch of images, and return just one. In Comfy, `IMAGE` means
image batch, and a single image is treated as a batch of size 1.</Tip>

### The main function

The main function, `choose_image`, receives named arguments as defined in `INPUT_TYPES`, and
returns a `tuple` as defined in `RETURN_TYPES`. Since we're dealing with images, which are internally
stored as `torch.Tensor`,

```Python  theme={null}
import torch
```

Then add the function to your class. The datatype for image is `torch.Tensor` with shape `[B,H,W,C]`,
where `B` is the batch size and `C` is the number of channels - 3, for RGB. If we iterate over such
a tensor, we will get a series of `B` tensors of shape `[H,W,C]`. The `.flatten()` method turns
this into a one dimensional tensor, of length `H*W*C`, `torch.mean()` takes the mean, and `.item()`
turns a single value tensor into a Python float.

```Python  theme={null}
def choose_image(self, images):
    brightness = list(torch.mean(image.flatten()).item() for image in images)
    /* Lines 471-473 omitted */
    return (result,)
```

Notes on those last two lines:

* `images[brightest]` will return a Tensor of shape `[H,W,C]`. `unsqueeze` is used to insert a (length 1) dimension at, in this case, dimension zero, to give
  us `[B,H,W,C]` with `B=1`: a single image.
* in `return (result,)`, the trailing comma is essential to ensure you return a tuple.

### Register the node

To make Comfy recognize the new node, it must be available at the package level. Modify the `NODE_CLASS_MAPPINGS` variable at the end of `src/nodes.py`. You must restart ComfyUI to see any changes.

```Python src/nodes.py theme={null}

NODE_CLASS_MAPPINGS = {
    "Example" : Example,
    "Image Selector" : ImageSelector,
}

# Optionally, you can rename the node in the `NODE_DISPLAY_NAME_MAPPINGS` dictionary.
NODE_DISPLAY_NAME_MAPPINGS = {
    "Example": "Example Node",
    "Image Selector": "Image Selector",
}
```

<Info>For a detailed explanation of how ComfyUI discovers and loads custom nodes, see the [node lifecycle documentation](/custom-nodes/backend/lifecycle).</Info>

## Add some options

That node is maybe a bit boring, so we might add some options; a widget that allows you to
choose the brightest image, or the reddest, bluest, or greenest. Edit your `INPUT_TYPES` to look like:

```Python  theme={null}
@classmethod    
def INPUT_TYPES(s):
    return { "required":  { "images": ("IMAGE",), 
```

Then update the main function. We'll use a fairly naive definition of 'reddest' as being the average
`R` value of the pixels divided by the average of all three colors. So:

```Python  theme={null}
def choose_image(self, images, mode):
    batch_size = images.shape[0]
    /* Lines 520-529 omitted */
    return (result,)
```

## Tweak the UI

Maybe we'd like a bit of visual feedback, so let's send a little text message to be displayed.

### Send a message from server

This requires two lines to be added to the Python code:

```Python  theme={null}
from server import PromptServer
```

and, at the end of the `choose_image` method, add a line to send a message to the front end (`send_sync` takes a message
type, which should be unique, and a dictionary)

```Python  theme={null}
PromptServer.instance.send_sync("example.imageselector.textmessage", {"message":f"Picked image {best+1}"})
return (result,)
```

### Write a client extension

To add some Javascript to the client, create a subdirectory, `web/js` in your custom node directory, and modify the end of `__init__.py`
to tell Comfy about it by exporting `WEB_DIRECTORY`:

```Python  theme={null}
WEB_DIRECTORY = "./web/js"
__all__ = ['NODE_CLASS_MAPPINGS', 'WEB_DIRECTORY']
```

The client extension is saved as a `.js` file in the `web/js` subdirectory, so create `image_selector/web/js/imageSelector.js` with the
code below. (For more, see [client side coding](./js/javascript_overview)).

```Javascript  theme={null}
import { app } from "../../scripts/app.js";
app.registerExtension({
	name: "example.imageselector",
    /* Lines 569-572 omitted */
    },
})
```

All we've done is register an extension and add a listener for the message type we are sending in the `setup()` method. This reads the dictionary we sent (which is stored in `event.detail`).

Stop the Comfy server, start it again, reload the webpage, and run your workflow.

### The complete example

The complete example is available [here](https://gist.github.com/robinjhuang/fbf54b7715091c7b478724fc4dffbd03). You can download the example workflow [JSON file](https://github.com/Comfy-Org/docs/blob/main/public/workflow.json) or view it below:

<div align="center">
  <img src="https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=a6f6c26f0dba136f864c59044909c55c" alt="Image Selector Workflow" width="100%" data-og-width="2264" data-og-height="1202" data-path="images/firstnodeworkflow.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=280&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=f2f67b0396e9d25543aeb3f3e3bb520c 280w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=560&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=9559b4d018dd5853f8a94bccf8056f45 560w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=840&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=0ce3e3b832cfe24004f61109ed025930 840w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=1100&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=2e82d92552ce1ae1315d35724f81db67 1100w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=1650&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=a61bedab96b65b0ef4c1d80650720821 1650w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=2500&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=b5363f7ee4b36b0c132f1691e886c6d1 2500w" />
</div>

# Backend

# Properties

> Properties of a custom node

### Simple Example

Here's the code for the Invert Image Node, which gives an overview of the key concepts in custom node development.

```python  theme={null}
class InvertImageNode:
    @classmethod
```

### Main properties

Every custom node is a Python class, with the following key properties:

#### INPUT\_TYPES

`INPUT_TYPES`, as the name suggests, defines the inputs for the node. The method returns a `dict`
which *must* contain the key `required`, and *may* also include the keys `optional` and/or `hidden`. The only difference
between `required` and `optional` inputs is that `optional` inputs can be left unconnected.
For more information on `hidden` inputs, see [Hidden Inputs](./more_on_inputs#hidden-inputs).

Each key has, as its value, another `dict`, in which key-value pairs specify the names and types of the inputs.
The types are defined by a `tuple`, the first element of which defines the data type,
and the second element of which is a `dict` of additional parameters.

Here we have just one required input, named `image_in`, of type `IMAGE`, with no additional parameters.

Note that unlike the next few attributes, this `INPUT_TYPES` is a `@classmethod`. This is so
that the options in dropdown widgets (like the name of the checkpoint to be loaded) can be
computed by Comfy at run time. We'll go into this more later. {/* TODO link when written */}

#### RETURN\_TYPES

A `tuple` of `str` defining the data types returned by the node.
If the node has no outputs this must still be provided `RETURN_TYPES = ()`
<Warning>If you have exactly one output, remember the trailing comma: `RETURN_TYPES = ("IMAGE",)`.
This is required for Python to make it a `tuple`</Warning>

#### RETURN\_NAMES

The names to be used to label the outputs. This is optional; if omitted, the names are simply the `RETURN_TYPES` in lowercase.

#### CATEGORY

Where the node will be found in the ComfyUI **Add Node** menu. Submenus can be specified as a path, eg. `examples/trivial`.

#### FUNCTION

The name of the Python function in the class that should be called when the node is executed.

The function is called with named arguments. All `required` (and `hidden`) inputs will be included;
`optional` inputs will be included only if they are connected, so you should provide default values for them in the function
definition (or capture them with `**kwargs`).

The function returns a tuple corresponding to the `RETURN_TYPES`. This is required even if nothing is returned (`return ()`).
Again, if you only have one output, remember that trailing comma `return (image_out,)`!

### Execution Control Extras

A great feature of Comfy is that it caches outputs,
and only executes nodes that might produce a different result than the previous run.
This can greatly speed up lots of workflows.

In essence this works by identifying which nodes produce an output (these, notably the Image Preview and Save Image nodes, are always executed), and then working
backwards to identify which nodes provide data that might have changed since the last run.

Two optional features of a custom node assist in this process.

#### OUTPUT\_NODE

By default, a node is not considered an output. Set `OUTPUT_NODE = True` to specify that it is.

#### IS\_CHANGED

By default, Comfy considers that a node has changed if any of its inputs or widgets have changed.
This is normally correct, but you may need to override this if, for instance, the node uses a random
number (and does not specify a seed - it's best practice to have a seed input in this case so that
the user can control reproducibility and avoid unnecessary execution), or loads an input that may have
changed externally, or sometimes ignores inputs (so doesn't need to execute just because those inputs changed).

<Warning>Despite the name, IS\_CHANGED should not return a `bool`</Warning>

`IS_CHANGED` is passed the same arguments as the main function defined by `FUNCTION`, and can return any
Python object. This object is compared with the one returned in the previous run (if any) and the node
will be considered to have changed if `is_changed != is_changed_old` (this code is in `execution.py` if you need to dig).

Since `True == True`, a node that returns `True` to say it has changed will be considered not to have! I'm sure this would
be changed in the Comfy code if it wasn't for the fact that it might break existing nodes to do so.

To specify that your node should always be considered to have changed (which you should avoid if possible, since it
stops Comfy optimising what gets run), `return float("NaN")`. This returns a `NaN` value, which is not equal
to anything, even another `NaN`.

A good example of actually checking for changes is the code from the built-in LoadImage node, which loads the image and returns a hash

```python  theme={null}
    @classmethod
```

### Other attributes

There are three other attributes that can be used to modify the default Comfy treatment of a node.

#### INPUT\_IS\_LIST, OUTPUT\_IS\_LIST

These are used to control sequential processing of data, and are described [later](./lists).

### VALIDATE\_INPUTS

If a class method `VALIDATE_INPUTS` is defined, it will be called before the workflow begins execution.
`VALIDATE_INPUTS` should return `True` if the inputs are valid, or a message (as a `str`) describing the error (which will prevent execution).

#### Validating Constants

<Warning>Note that `VALIDATE_INPUTS` will only receive inputs that are defined as constants within the workflow. Any inputs that are received from other nodes will *not* be available in `VALIDATE_INPUTS`.</Warning>

`VALIDATE_INPUTS` is called with only the inputs that its signature requests (those returned by `inspect.getfullargspec(obj_class.VALIDATE_INPUTS).args`). Any inputs which are received in this way will *not* run through the default validation rules. For example, in the following snippet, the front-end will use the specified `min` and `max` values of the `foo` input, but the back-end will not enforce it.

```python  theme={null}
class CustomNode:
    @classmethod
```

Additionally, if the function takes a `**kwargs` input, it will receive *all* available inputs and all of them will skip validation as if specified explicitly.

#### Validating Types

If the `VALIDATE_INPUTS` method receives an argument named `input_types`, it will be passed a dictionary in which the key is the name of each input which is connected to an output from another node and the value is the type of that output.

When this argument is present, all default validation of input types is skipped. Here's an example making use of the fact that the front-end allows for the specification of multiple types:

```python  theme={null}
class AddNumbers:
    @classmethod
```

# Lifecycle

## How Comfy loads custom nodes

When Comfy starts, it scans the directory `custom_nodes` for Python modules, and attempts to load them.
If the module exports `NODE_CLASS_MAPPINGS`, it will be treated as a custom node.
<Tip>A python module is a directory containing an `__init__.py` file.
The module exports whatever is listed in the `__all__` attribute defined in `__init__.py`.</Tip>

### **init**.py

`__init__.py` is executed when Comfy attempts to import the module. For a module to be recognized as containing
custom node definitions, it needs to export `NODE_CLASS_MAPPINGS`. If it does (and if nothing goes wrong in the import),
the nodes defined in the module will be available in Comfy. If there is an error in your code,
Comfy will continue, but will report the module as having failed to load. So check the Python console!

A very simple `__init__.py` file would look like this:

```python  theme={null}
from .python_file import MyCustomNode
NODE_CLASS_MAPPINGS = { "My Custom Node" : MyCustomNode }
__all__ = ["NODE_CLASS_MAPPINGS"]
```

#### NODE\_CLASS\_MAPPINGS

`NODE_CLASS_MAPPINGS` must be a `dict` mapping custom node names (unique across the Comfy install)
to the corresponding node class.

#### NODE\_DISPLAY\_NAME\_MAPPINGS

`__init__.py` may also export `NODE_DISPLAY_NAME_MAPPINGS`, which maps the same unique name to a display name for the node.
If `NODE_DISPLAY_NAME_MAPPINGS` is not provided, Comfy will use the unique name as the display name.

#### WEB\_DIRECTORY

If you are deploying client side code, you will also need to export the path, relative to the module, in which the
JavaScript files are to be found. It is conventional to place these in a subdirectory of your custom node named `js`.
<Tip>*Only* `.js` files will be served; you can't deploy `.css` or other types in this way</Tip>

<Warning>In previous versions of Comfy, `__init__.py` was required to copy the JavaScript files into the main Comfy web
subdirectory. You will still see code that does this. Don't.</Warning>

# Datatypes

These are the most important built in datatypes. You can also [define your own](./more_on_inputs#custom-datatypes).

Datatypes are used on the client side to prevent a workflow from passing the wrong form of data into a node - a bit like strong typing.
The JavaScript client side code will generally not allow a node output to be connected to an input of a different datatype,
although a few exceptions are noted below.

## Comfy datatypes

### COMBO

* No additional parameters in `INPUT_TYPES`

* Python datatype: defined as `list[str]`, output value is `str`

Represents a dropdown menu widget.
Unlike other datatypes, `COMBO` it is not specified in `INPUT_TYPES` by a `str`, but by a `list[str]`
corresponding to the options in the dropdown list, with the first option selected by default.

`COMBO` inputs are often dynamically generated at run time. For instance, in the built-in `CheckpointLoaderSimple` node, you find

```
"ckpt_name": (folder_paths.get_filename_list("checkpoints"), )
```

or they might just be a fixed list of options,

```
"play_sound": (["no","yes"], {}),
```

### Primitive and reroute

Primitive and reroute nodes only exist on the client side. They do not have an intrinsic datatype, but when connected they take on
the datatype of the input or output to which they have been connected (which is why they can't connect to a `*` input...)

## Python datatypes

### INT

* Additional parameters in `INPUT_TYPES`:

  /* Lines 860-862 omitted */
  * `min` and `max` are optional

* Python datatype `int`

### FLOAT

* Additional parameters in `INPUT_TYPES`:

  /* Lines 870-872 omitted */
  * `min`, `max`, `step` are optional

* Python datatype `float`

### STRING

* Additional parameters in `INPUT_TYPES`:

  * `default` is required

* Python datatype `str`

### BOOLEAN

* Additional parameters in `INPUT_TYPES`:

  * `default` is required

* Python datatype `bool`

## Tensor datatypes

### IMAGE

* No additional parameters in `INPUT_TYPES`

* Python datatype `torch.Tensor` with *shape* \[B,H,W,C]

A batch of `B` images, height `H`, width `W`, with `C` channels (generally `C=3` for `RGB`).

### LATENT

* No additional parameters in `INPUT_TYPES`

* Python datatype `dict`, containing a `torch.Tensor` with *shape* \[B,C,H,W]

The `dict` passed contains the key `samples`, which is a `torch.Tensor` with *shape* \[B,C,H,W] representing
a batch of `B` latents, with `C` channels (generally `C=4` for existing stable diffusion models), height `H`, width `W`.

The height and width are 1/8 of the corresponding image size (which is the value you set in the Empty Latent Image node).

Other entries in the dictionary contain things like latent masks.

{/* TODO new SD models might have different C values? */}

### MASK

* No additional parameters in `INPUT_TYPES`

* Python datatype `torch.Tensor` with *shape* \[H,W] or \[B,C,H,W]

### AUDIO

* No additional parameters in `INPUT_TYPES`

* Python datatype `dict`, containing a `torch.Tensor` with *shape* \[B, C, T] and a sample rate.

The `dict` passed contains the key `waveform`, which is a `torch.Tensor` with *shape* \[B, C, T] representing a batch of `B` audio samples, with `C` channels (`C=2` for stereo and `C=1` for mono), and `T` time steps (i.e., the number of audio samples).

The `dict` contains another key `sample_rate`, which indicates the sampling rate of the audio.

## Custom Sampling datatypes

### Noise

The `NOISE` datatype represents a *source* of noise (not the actual noise itself). It can be represented by any Python object
that provides a method to generate noise, with the signature `generate_noise(self, input_latent:Tensor) -> Tensor`, and a
property, `seed:Optional[int]`.

<Tip>The `seed` is passed into `sample` guider in the `SamplerCustomAdvanced`, but does not appear to be used in any of the standard guiders.
It is Optional, so you can generally set it to None.</Tip>

When noise is to be added, the latent is passed into this method, which should return a `Tensor` of the same shape containing the noise.

See the [noise mixing example](./snippets#creating-noise-variations)

### Sampler

The `SAMPLER` datatype represents a sampler, which is represented as a Python object providing a `sample` method.
Stable diffusion sampling is beyond the scope of this guide; see `comfy/samplers.py` if you want to dig into this part of the code.

### Sigmas

The `SIGMAS` datatypes represents the values of sigma before and after each step in the sampling process, as produced by a scheduler.
This is represented as a one-dimensional tensor, of length `steps+1`, where each element represents the noise expected to be present
before the corresponding step, with the final value representing the noise present after the final step.

A `normal` scheduler, with 20 steps and denoise of 1, for an SDXL model, produces:

```
tensor([14.6146, 10.7468,  8.0815,  6.2049,  4.8557,  
         3.8654,  3.1238,  2.5572,  2.1157,  1.7648,  
         /* Lines 964-965 omitted */  
         0.5964,  0.4736,  0.3555,  0.2322,  0.0292,  0.0000])
```

<Tip>The starting value of sigma depends on the model, which is why a scheduler node requires a `MODEL` input to produce a SIGMAS output</Tip>

### Guider

A `GUIDER` is a generalisation of the denoising process, as 'guided' by a prompt or any other form of conditioning. In Comfy the guider is
represented by a `callable` Python object providing a `__call__(*args, **kwargs)` method which is called by the sample.

The `__call__` method takes (in `args[0]`) a batch of noisy latents (tensor `[B,C,H,W]`), and returns a prediction of the noise (a tensor of the same shape).

## Model datatypes

There are a number of more technical datatypes for stable diffusion models. The most significant ones are `MODEL`, `CLIP`, `VAE` and `CONDITIONING`.
Working with these is (for the time being) beyond the scope of this guide! {/* TODO but maybe not forever */}

## Additional Parameters

Below is a list of officially supported keys that can be used in the 'extra options' portion of an input definition.

<Warning>You can use additional keys for your own custom widgets, but should *not* reuse any of the keys below for other purposes.</Warning>

| Key              | Description                                                                                                                                                                                      |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `default`        | The default value of the widget                                                                                                                                                                  |
| `min`            | The minimum value of a number (`FLOAT` or `INT`)                                                                                                                                                 |
| `max`            | The maximum value of a number (`FLOAT` or `INT`)                                                                                                                                                 |
| `step`           | The amount to increment or decrement a widget                                                                                                                                                    |
| `label_on`       | The label to use in the UI when the bool is `True` (`BOOL`)                                                                                                                                      |
| `label_off`      | The label to use in the UI when the bool is `False` (`BOOL`)                                                                                                                                     |
| `defaultInput`   | Defaults to an input socket rather than a supported widget                                                                                                                                       |
| `forceInput`     | `defaultInput` and also don't allow converting to a widget                                                                                                                                       |
| `multiline`      | Use a multiline text box (`STRING`)                                                                                                                                                              |
| `placeholder`    | Placeholder text to display in the UI when empty (`STRING`)                                                                                                                                      |
| `dynamicPrompts` | Causes the front-end to evaluate dynamic prompts                                                                                                                                                 |
| `lazy`           | Declares that this input uses [Lazy Evaluation](./lazy_evaluation)                                                                                                                               |
| `rawLink`        | When a link exists, rather than receiving the evaluated value, you will receive the link (i.e. `["nodeId", <outputIndex>]`). Primarily useful when your node uses [Node Expansion](./expansion). |

# Images, Latents, and Masks

When working with these datatypes, you will need to know about the `torch.Tensor` class.
Complete documentation is [here](https://pytorch.org/docs/stable/tensors.html), or
an introduction to the key concepts required for Comfy [here](./tensors).

<Warning>If your node has a single output which is a tensor, remember to return `(image,)` not `(image)`</Warning>

Most of the concepts below are illustrated in the [example code snippets](./snippets).

## Images

An IMAGE is a `torch.Tensor` with shape `[B,H,W,C]`, `C=3`. If you are going to save or load images, you will
need to convert to and from `PIL.Image` format - see the code snippets below! Note that some `pytorch` operations
offer (or expect) `[B,C,H,W]`, known as 'channel first', for reasons of computational efficiency. Just be careful.

### Working with PIL.Image

If you want to load and save images, you'll want to use PIL:

```python  theme={null}
from PIL import Image, ImageOps
```

## Masks

A MASK is a `torch.Tensor` with shape `[B,H,W]`.
In many contexts, masks have binary values (0 or 1), which are used to indicate which pixels should undergo specific operations.
In some cases values between 0 and 1 are used indicate an extent of masking, (for instance, to alter transparency, adjust filters, or composite layers).

### Masks from the Load Image Node

The `LoadImage` node uses an image's alpha channel (the "A" in "RGBA") to create MASKs.
The values from the alpha channel are normalized to the range \[0,1] (torch.float32) and then inverted.
The `LoadImage` node always produces a MASK output when loading an image. Many images (like JPEGs) don't have an alpha channel.
In these cases, `LoadImage` creates a default mask with the shape `[1, 64, 64]`.

### Understanding Mask Shapes

In libraries like `numpy`, `PIL`, and many others, single-channel images (like masks) are typically represented as 2D arrays, shape `[H,W]`.
This means the `C` (channel) dimension is implicit, and thus unlike IMAGE types, batches of MASKs have only three dimensions: `[B, H, W]`.
It is not uncommon to encounter a mask which has had the `B` dimension implicitly squeezed, giving a tensor `[H,W]`.

To use a MASK, you will often have to match shapes by unsqueezing to produce a shape `[B,H,W,C]` with `C=1`
To unsqueezing the `C` dimension, so you should `unsqueeze(-1)`, to unsqueeze `B`, you `unsqueeze(0)`.
If your node receives a MASK as input, you would be wise to always check `len(mask.shape)`.

## Latents

A LATENT is a `dict`; the latent sample is referenced by the key `samples` and has shape `[B,C,H,W]`, with `C=4`.

<Tip>LATENT is channel first, IMAGE is channel last</Tip>

# Hidden and Flexible inputs

## Hidden inputs

Alongside the `required` and `optional` inputs, which create corresponding inputs or widgets on the client-side,
there are three `hidden` input options which allow the custom node to request certain information from the server.

These are accessed by returning a value for `hidden` in the `INPUT_TYPES` `dict`, with the signature `dict[str,str]`,
containing one or more of `PROMPT`, `EXTRA_PNGINFO`, or `UNIQUE_ID`

```python  theme={null}
@classmethod
def INPUT_TYPES(s):
    return {/* Lines 1071-1078 omitted */}
```

### UNIQUE\_ID

`UNIQUE_ID` is the unique identifier of the node, and matches the `id` property of the node on the client side.
It is commonly used in client-server communications (see [messages](/development/comfyui-server/comms_messages#getting-node-id)).

### PROMPT

`PROMPT` is the complete prompt sent by the client to the server.
See [the prompt object](/custom-nodes/js/javascript_objects_and_hijacking#prompt) for a full description.

### EXTRA\_PNGINFO

`EXTRA_PNGINFO` is a dictionary that will be copied into the metadata of any `.png` files saved. Custom nodes can store additional
information in this dictionary for saving (or as a way to communicate with a downstream node).

<Tip>Note that if Comfy is started with the `disable_metadata` option, this data won't be saved.</Tip>

### DYNPROMPT

`DYNPROMPT` is an instance of `comfy_execution.graph.DynamicPrompt`. It differs from `PROMPT` in that it may mutate during the course of execution in response to [Node Expansion](/custom-nodes/backend/expansion).
<Tip>`DYNPROMPT` should only be used for advanced cases (like implementing loops in custom nodes).</Tip>

## Flexible inputs

### Custom datatypes

If you want to pass data between your own custom nodes, you may find it helpful to define a custom datatype. This is (almost) as simple as
just choosing a name for the datatype, which should be a unique string in upper case, such as `CHEESE`.

You can then use `CHEESE` in your node `INPUT_TYPES` and `RETURN_TYPES`, and the Comfy client will only allow `CHEESE` outputs to connect to a `CHEESE` input.
`CHEESE` can be any python object.

The only point to note is that because the Comfy client doesn't know about `CHEESE` you need (unless you define a custom widget for `CHEESE`,
which is a topic for another day), to force it to be an input rather than a widget. This can be done with the `forceInput` option in the input options dictionary:

```python  theme={null}
@classmethod
def INPUT_TYPES(s):
    return {/* Lines 1120-1121 omitted */}
```

### Wildcard inputs
</attachment>

</attachments>
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
ì´ íŒŒì¼ì€ ComfyUIì˜ Custom Node ê°œë°œ ê´€ë ¨ ë¬¸ì„œë¥¼ ëª¨ë‘ í•©ì³ë†“ì€ê±°ì•¼.
ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì•žìœ¼ë¡œ Agentê°€ ê°œë°œ ì‹œ ì°¸ê³ í•  ë¬¸ì„œë¡œ ìž‘ì„±í•˜ëŠ” ê²ƒì´ ë„ˆì˜ ì—…ë¬´ì•¼.

ì•žìœ¼ë¡œ ì»¤ìŠ¤í…€ ë…¸ë“œ ê°œë°œí•  ë•Œ ë„ˆê°€ ìž‘ì„±í•œ ë¬¸ì„œë¥¼ ì½ìœ¼ë©´ì„œ ë™ìž‘í•˜ê²Œ ë ê±°ë‹ˆ ì±…ìž„ê°ìžˆê²Œ í•„ìš”í•œ ë‚´ìš©ì„ ìž˜ ìž‘ì„±í•´ì¤˜.

í´ë”ì™€ íŒŒì¼ì„ ë‚˜ëˆ ì•¼í•œë‹¤ë©´ AGENTS_DOC í´ë”ë¥¼ ë§Œë“¤ê³  ê·¸ ì•ˆì— ì—¬ëŸ¬ íŒŒì¼ì„ ë§Œë“¤ì–´ë„ ì¢‹ì•„.
ì•„ë‹ˆë¼ë©´ í•˜ë‚˜ì˜ íŒŒì¼ AGENTS_DOC.md ë¡œ ë§Œë“¤ì–´.

</userRequest>

Assistant

ðŸ› ï¸ read_file (call_MHxaem1qYzBWNWhJdVVWcFd1dVA) {
  "endLine": 1200,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\COMFYUI_RAW_DOCS.md",
  "startLine": 1
}
Tool
ðŸ› ï¸ call_MHxaem1qYzBWNWhJdVVWcFd1dVA
File: `c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md`. Lines 1 to 1200 (4378 lines total): 
````markdown
# Server Overview

## Overview

The Comfy server runs on top of the [aiohttp framework](https://docs.aiohttp.org/), which in turn uses [asyncio](https://pypi.org/project/asyncio/).

Messages from the server to the client are sent by socket messages through the `send_sync` method of the server,
which is an instance of `PromptServer` (defined in `server.py`). They are processed
by a socket event listener registered in `api.js`. See [messages](/development/comfyui-server/comms_messages).

Messages from the client to the server are sent by the `api.fetchApi()` method defined in `api.js`,
and are handled by http routes defined by the server. See [routes](/development/comfyui-server/comms_routes).

<Tip>The client submits the whole workflow (widget values and all) when you queue a request.
The server does not receive any changes you make after you send a request to the queue.
If you want to modify server behavior during execution, you'll need routes.</Tip>


---

> To find navigation and other pages in this documentation, fetch the llms.txt file at: https://docs.comfy.org/llms.**txt**


# Messages

## Messages

During execution (or when the state of the queue changes), the `PromptExecutor` sends messages back to the client
through the `send_sync` method of `PromptServer`.

These messages are received by a socket event listener defined in `api.js` (at time of writing around line 90, or search for `this.socket.addEventListener`),
which creates a `CustomEvent` object for any known message type, and dispatches it to any registered listeners.

An extension can register to receive events (normally done in the `setup()` function) following the standard Javascript idiom:

```Javascript  theme={null}
api.addEventListener(message_type, messageHandler);
```

If the `message_type` is not one of the built in ones, it will be added to the list of known message types automatically. The message `messageHandler`
will be called with a `CustomEvent` object, which extends the event raised by the socket to add a `.detail` property, which is a dictionary of
the data sent by the server. So usage is generally along the lines of:

```Javascript  theme={null}
function messageHandler(event) {
    if (event.detail.node == aNodeIdThatIsInteresting) {
        // do something with event.detail.other_things
    }
}
```

### Built in message types

During execution (or when the state of the queue changes), the `PromptExecutor` sends the following messages back to the client
through the `send_sync` method of `PromptServer`. An extension can register as a listener for any of these.

| event                   | when                                                                       | data                                                                                                    |
| ----------------------- | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| `execution_start`       | When a prompt is about to run                                              | `prompt_id`                                                                                             |
| `execution_error`       | When an error occurs during execution                                      | `prompt_id`, plus additional information                                                                |
| `execution_interrupted` | When execution is stopped by a node raising `InterruptProcessingException` | `prompt_id`, `node_id`, `node_type` and `executed` (a list of executed nodes)                           |
| `execution_cached`      | At the start of execution                                                  | `prompt_id`, `nodes` (a list of nodes which are being skipped because their cached outputs can be used) |
| `execution_success`     | When all nodes from the prompt have been successfully executed             | `prompt_id`, `timestamp`                                                                                |
| `executing`             | When a new node is about to be executed                                    | `node` (node id or `None` to indicate completion), `prompt_id`                                          |
| `executed`              | When a node returns a ui element                                           | `node` (node id), `prompt_id`, `output`                                                                 |
| `progress`              | During execution of a node that implements the required hook               | `node` (node id), `prompt_id`, `value`, `max`                                                           |
| `status`                | When the state of the queue changes                                        | `exec_info`, a dictionary holding `queue_remaining`, the number of entries in the queue                 |

### Using executed

Despite the name, an `executed` message is not sent whenever a node completes execution (unlike `executing`), but only when the node
returns a ui update.

To do this, the main function needs to return a dictionary instead of a tuple:

```python  theme={null}
# at the end of my main method
        return { "ui":a_new_dictionary, "result": the_tuple_of_output_values }
```

`a_new_dictionary` will then be sent as the value of `output` in an `executed` message.
The `result` key can be omitted if the node has no outputs (see, for instance, the code for `SaveImage` in `nodes.py`)

### Custom message types

As indicated above, on the client side, a custom message type can be added simply by registering as a listener for a unique message type name.

```Javascript  theme={null}
api.addEventListener("my.custom.message", messageHandler);
```

On the server, the code is equally simple:

```Python  theme={null}
from server import PromptServer
# then, in your main execution function (normally)
        PromptServer.instance.send_sync("my.custom.message", a_dictionary)
```

#### Getting node\_id

Most of the built-in messages include the current node id in the value of `node`. It's likely that you will want to do the same.

The node\_id is available on the server side through a hidden input, which is obtained with the `hidden` key in the `INPUT_TYPES` dictionary:

```Python  theme={null}
    @classmethod    
    def INPUT_TYPES(s):
        return {"required" : { }, # whatever your required inputs are 
                "hidden": { "node_id": "UNIQUE_ID" } } # Add the hidden key

    def my_main_function(self, required_inputs, node_id):
        # do some things
        PromptServer.instance.send_sync("my.custom.message", {"node": node_id, "other_things": etc})
```
# Routes

## Routes

The server defines a series of `get` and `post` methods
which can be found by searching for `@routes` in `server.py`. When you submit a workflow
in the web client, it is posted to `/prompt` which validates the prompt and adds it to an execution queue,
returning either a `prompt_id` and `number` (the position in the queue), or `error` and `node_errors` if validation fails.
The prompt queue is defined in `execution.py`, which also defines the `PromptExecutor` class.

### Built in routes

`server.py` defines the following routes:

#### Core API Routes

| path                           | get/post/ws | purpose                                                                   |
| ------------------------------ | ----------- | ------------------------------------------------------------------------- |
| `/`                            | get         | load the comfy webpage                                                    |
| `/ws`                          | websocket   | WebSocket endpoint for real-time communication with the server            |
| `/embeddings`                  | get         | retrieve a list of the names of embeddings available                      |
| `/extensions`                  | get         | retrieve a list of the extensions registering a `WEB_DIRECTORY`           |
| `/features`                    | get         | retrieve server features and capabilities                                 |
| `/models`                      | get         | retrieve a list of available model types                                  |
| `/models/{folder}`             | get         | retrieve models in a specific folder                                      |
| `/workflow_templates`          | get         | retrieve a map of custom node modules and associated template workflows   |
| `/upload/image`                | post        | upload an image                                                           |
| `/upload/mask`                 | post        | upload a mask                                                             |
| `/view`                        | get         | view an image. Lots of options, see `@routes.get("/view")` in `server.py` |
| `/view_metadata`/{folder_name} | get         | retrieve metadata for a model                                             |
| `/system_stats`                | get         | retrieve information about the system (python version, devices, vram etc) |
| `/prompt`                      | get         | retrieve current queue status and execution information                   |
| `/prompt`                      | post        | submit a prompt to the queue                                              |
| `/object_info`                 | get         | retrieve details of all node types                                        |
| `/object_info/{node_class}`    | get         | retrieve details of one node type                                         |
| `/history`                     | get         | retrieve the queue history                                                |
| `/history/{prompt_id}`         | get         | retrieve the queue history for a specific prompt                          |
| `/history`                     | post        | clear history or delete history item                                      |
| `/queue`                       | get         | retrieve the current state of the execution queue                         |
| `/queue`                       | post        | manage queue operations (clear pending/running)                           |
| `/interrupt`                   | post        | stop the current workflow execution                                       |
| `/free`                        | post        | free memory by unloading specified models                                 |
| `/userdata`                    | get         | list user data files in a specified directory                             |
| `/v2/userdata`                 | get         | enhanced version that lists files and directories in structured format    |
| `/userdata/{file}`             | get         | retrieve a specific user data file                                        |
| `/userdata/{file}`             | post        | upload or update a user data file                                         |
| `/userdata/{file}`             | delete      | delete a specific user data file                                          |
| `/userdata/{file}/move/{dest}` | post        | move or rename a user data file                                           |
| `/users`                       | get         | get user information                                                      |
| `/users`                       | post        | create a new user (multi-user mode only)                                  |

### WebSocket Communication

The `/ws` endpoint provides real-time bidirectional communication between the client and server. This is used for:

* Receiving execution progress updates
* Getting node execution status in real-time
* Receiving error messages and debugging information
* Live updates when queue status changes

The WebSocket connection sends JSON messages with different types such as:

* `status` - Overall system status updates
* `execution_start` - When a prompt execution begins
* `execution_cached` - When cached results are used
* `executing` - Updates during node execution
* `progress` - Progress updates for long-running operations
* `executed` - When a node completes execution

### Custom routes

If you want to send a message from the client to the server during execution, you will need to add a custom route to the server.
For anything complicated, you will need to dive into the [aiohttp framework docs](https://docs.aiohttp.org/), but most cases can
be handled as follows:

```Python  theme={null}
from server import PromptServer
from aiohttp import web
routes = PromptServer.instance.routes
@routes.post('/my_new_path')
async def my_function(request):
    the_data = await request.post()
    # the_data now holds a dictionary of the values sent
    MyClass.handle_my_message(the_data)
    return web.json_response({})
```

<Tip>Unless you know what you are doing, don't try to define `my_function` within a class.
The `@routes.post` decorator does a lot of work! Instead, define the function as above
and then call a classmethod.</Tip>

<Tip>You can also define a `@routes.get` if you aren't changing anything.</Tip>

The client can use this new route by sending a `FormData` object with code something like this,
which would result in `the_data`, in the above code, containing `message` and `node_id` keys:

```Javascript  theme={null}
import { api } from "../../scripts/api.js";
function send_message(node_id, message) {
    const body = new FormData();
    body.append('message',message);
    body.append('node_id', node_id);
    api.fetchApi("/my_new_path", { method: "POST", body, });
}
```
# Execution Model Inversion Guide

[PR #2666](https://github.com/comfyanonymous/ComfyUI/pull/2666) inverts the execution model from a back-to-front recursive model to a front-to-back topological sort. While most custom nodes should continue to "just work", this page is intended to serve as a guide for custom node creators to the things that *could* break.

## Breaking Changes

### Monkey Patching

Any code that monkey patched the execution model is likely to stop working. Note that the performance of execution with this PR exceeds that with the most popular monkey patches, so many of them will be unnecessary.

### Optional Input Validation

Prior to this PR, only nodes that were connected to outputs exclusively through a string of `"required"` inputs were actually validated. If you had custom nodes that were only ever connected to `"optional"` inputs, you previously wouldn't have been seeing that they failed validation.

<Tip>If your nodes' outputs could already be connected to `"required"` inputs, it is unlikely that anything in this section applies to you. It will primarily apply to custom node authors who use custom types and exclusively use `"optional"` inputs.</Tip>

Here are some of the things that could cause you to fail validation along with recommended solutions:

* Use of reserved [Additional Parameters](/custom-nodes/backend/datatypes#additional-parameters) like `min` and `max` on types that aren't comparable (e.g. dictionaries) in order to configure custom widgets.
  * Change the additional parameters used to non-reserved keys like `uiMin` and `uiMax`. *(Recommended Solution)*
    ```python  theme={null}
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "my_size": ("VEC2", {"uiMin": 0.0, "uiMax": 1.0}),
            }
        }
    ```

  * Define a custom [VALIDATE\_INPUTS](/custom-nodes/backend/server_overview#validate-inputs) function with this input so validation of it is skipped. *(Quick Solution)*
    ```python  theme={null}
    @classmethod
    def VALIDATE_INPUTS(cls, my_size):
        return True
    ```

* Use of composite types (e.g. `CUSTOM_A,CUSTOM_B`)
  * (When used as output) Define and use a wrapper like `MakeSmartType` [seen here in the PR's unit tests](https://github.com/comfyanonymous/ComfyUI/pull/2666/files#diff-714643f1fdb6f8798c45f77ab10d212ca7f41dd71bbe55069f1f9f146a8f0cb9R2)
    ```python  theme={null}
    class MyCustomNode:

        @classmethod
        def INPUT_TYPES(cls):
            return {
                "required": {
                    "input": (MakeSmartType("FOO,BAR"), {}),
                }
            }

        RETURN_TYPES = (MakeSmartType("FOO,BAR"),)

        # ...
    ```
  * (When used as input) Define a custom[VALIDATE\_INPUTS](/custom-nodes/backend/server_overview#validate-inputs) function that takes a `input_types` argument so type validation is skipped.
    ```python  theme={null}
    @classmethod
    def VALIDATE_INPUTS(cls, input_types):
        return True
    ```
  * (Supports both, convenient) Define and use the `@VariantSupport` decorator [seen here in the PR's unit tests](https://github.com/comfyanonymous/ComfyUI/pull/2666/files#diff-714643f1fdb6f8798c45f77ab10d212ca7f41dd71bbe55069f1f9f146a8f0cb9R15)
    ```python  theme={null}
    @VariantSupport
    class MyCustomNode:

        @classmethod
        def INPUT_TYPES(cls):
            return {
                "required": {
                    "input": ("FOO,BAR", {}),
                }
            }
        
        RETURN_TYPES = (MakeSmartType("FOO,BAR"),)

        # ...
    ```

* The use of lists (e.g. `[1, 2, 3]`) as constants in the graph definition (e.g. to represent a const `VEC3` input). This would have required a front-end extension before. Previously, lists of size exactly `2` would have failed anyway -- they would have been treated as broken links.
  * Wrap the lists in a dictionary like `{ "value": [1, 2, 3] }`

### Execution Order

Execution order has always changed depending on which nodes happen to have which IDs, but it may now change depending on which values are cached as well. In general, the execution order should be considered non-deterministic and subject to change (beyond what is enforced by the graph's structure).

Don't rely on the execution order.

*HIC SUNT DRACONES*

## New Functionality

### Validation Changes

A number of features were added to the `VALIDATE_INPUTS` function in order to lessen the impact of the [Optional Input Validation](#optional-input-validation) mentioned above.

* Default validation will now be skipped for inputs which are received by the `VALIDATE_INPUTS` function.
* The `VALIDATE_INPUTS` function can now take `**kwargs` which causes all inputs to be treated as validated by the node creator.
* The `VALIDATE_INPUTS` function can take an input named `input_types`. This input will be a dict mapping each input (connected via a link) to the type of the connected output. When this argument exists, type validation for the node's inputs is skipped.

You can read more at [VALIDATE\_INPUTS](/custom-nodes/backend/server_overview#validate-inputs).

### Lazy Evaluation

Inputs can be evaluated lazily (i.e. you can wait to see if they are needed before evaluating the attached node and all its ancestors). See [Lazy Evaluation](/custom-nodes/backend/lazy_evaluation) for more information.

### Node Expansion

At runtime, nodes can expand into a subgraph of nodes. This is what allows loops to be implemented (via tail-recursion). See [Node Expansion](/custom-nodes/backend/expansion) for more information.


# Overview

Custom nodes allow you to implement new features and share them with the wider community.

A custom node is like any Comfy node: it takes input, does something to it, and produces an output.
While some custom nodes perform highly complex tasks, many just do one thing. Here's an example of a
simple node that takes an image and inverts it.

<img src="https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=8088073e29e8af1bc700937ecb3b77e9" alt="Unique Images Node" data-og-width="564" width="564" data-og-height="279" height="279" data-path="images/invert_image_node.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=280&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=6fa9f912f38ec608ee43f4e456cedf42 280w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=560&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=aeae6dd8bc6393935ebabe3de4b8ed85 560w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=840&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=3dbe92afa58705aca5f218df9f5c5a52 840w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=1100&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=dfda0a7b67616219ac9b7ec9742cb0d4 1100w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=1650&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=a3b84be0acf1b9248b9ac0086a49bd53 1650w, https://mintcdn.com/dripart/NmGUk_QSXQXRVtZP/images/invert_image_node.png?w=2500&fit=max&auto=format&n=NmGUk_QSXQXRVtZP&q=85&s=2113625a7743f680050980330f4f928d 2500w" />

Custom node examplesï¼š

* [cookiecutter-comfy-extension](https://github.com/Comfy-Org/cookiecutter-comfy-extension)
* [ComfyUI-React-Extension-Template](https://github.com/Comfy-Org/ComfyUI-React-Extension-Template)
* [ComfyUI\_frontend\_vue\_basic](https://github.com/jtydhr88/ComfyUI_frontend_vue_basic)

## Client-Server Model

Comfy runs in a client-server model. The server, written in Python, handles all the real work: data-processing, models, image diffusion etc. The client, written in Javascript, handles the user interface.

Comfy can also be used in API mode, in which a workflow is sent to the server by a non-Comfy client (such as another UI, or a command line script).

Custom nodes can be placed into one of four categories:

### Server side only

The majority of Custom Nodes run purely on the server side, by defining a Python class that specifies the input and output types, and provides a function that can be called to process inputs and produce an output.

### Client side only

A few Custom Nodes provide a modification to the client UI, but do not add core functionality. Despite the name, they may not even add new nodes to the system.

### Independent Client and Server

Custom nodes may provide additional server features, and additional (related) UI features (such as a new widget to deal with a new data type). In most cases, communication between the client and server can be handled by the Comfy data flow control.

### Connected Client and Server

In a small number of cases, the UI features and the server need to interact with each other directly.

<Warning>Any node that requires Client-Server communication will not be compatible with use through the API.</Warning>

# Getting Started

This page will take you step-by-step through the process of creating a custom node.

Our example will take a batch of images, and return one of the images. Initially, the node
will return the image which is, on average, the lightest in color; we'll then extend
it to have a range of selection criteria, and then finally add some client side code.

This page assumes very little knowledge of Python or Javascript.

After this walkthrough, dive into the details of [backend code](./backend/server_overview), and
[frontend code](./backend/server_overview).

## Write a basic node

### Prerequisites

* A working ComfyUI [installation](/installation/manual_install). For development, we recommend installing ComfyUI manually.
* A working comfy-cli [installation](/comfy-cli/getting-started).

### Setting up

```bash  theme={null}
cd ComfyUI/custom_nodes
comfy node scaffold
```

After answering a few questions, you'll have a new directory set up.

```bash  theme={null}
 ~  % comfy node scaffold
You've downloaded .cookiecutters/cookiecutter-comfy-extension before. Is it okay to delete and re-download it? [y/n] (y): y
  [1/9] full_name (): Comfy
  [2/9] email (you@gmail.com): me@comfy.org
  [3/9] github_username (your_github_username): comfy
  [4/9] project_name (My Custom Nodepack): FirstComfyNode
  [5/9] project_slug (firstcomfynode): 
  [6/9] project_short_description (A collection of custom nodes for ComfyUI): 
  [7/9] version (0.0.1): 
  [8/9] Select open_source_license
    1 - GNU General Public License v3
    2 - MIT license
    3 - BSD license
    4 - ISC license
    5 - Apache Software License 2.0
    6 - Not open source
    Choose from [1/2/3/4/5/6] (1): 1
  [9/9] include_web_directory_for_custom_javascript [y/n] (n): y
Initialized empty Git repository in firstcomfynode/.git/
âœ“ Custom node project created successfully!
```

### Defining the node

Add the following code to the end of `src/nodes.py`:

```Python src/nodes.py theme={null}
class ImageSelector:
    CATEGORY = "example"
    @classmethod    
    def INPUT_TYPES(s):
        return { "required":  { "images": ("IMAGE",), } }
    RETURN_TYPES = ("IMAGE",)
    FUNCTION = "choose_image"
```

<Info>The basic structure of a custom node is described in detail [here](/custom-nodes/backend/server_overview). </Info>

A custom node is defined using a Python class, which must include these four things: `CATEGORY`,
which specifies where in the add new node menu the custom node will be located,
`INPUT_TYPES`, which is a class method defining what inputs the node will take
(see [later](/custom-nodes/backend/server_overview#input-types) for details of the dictionary returned),
`RETURN_TYPES`, which defines what outputs the node will produce, and `FUNCTION`, the name
of the function that will be called when the node is executed.

<Tip>Notice that the data type for input and output is `IMAGE` (singular) even though
we expect to receive a batch of images, and return just one. In Comfy, `IMAGE` means
image batch, and a single image is treated as a batch of size 1.</Tip>

### The main function

The main function, `choose_image`, receives named arguments as defined in `INPUT_TYPES`, and
returns a `tuple` as defined in `RETURN_TYPES`. Since we're dealing with images, which are internally
stored as `torch.Tensor`,

```Python  theme={null}
import torch
```

Then add the function to your class. The datatype for image is `torch.Tensor` with shape `[B,H,W,C]`,
where `B` is the batch size and `C` is the number of channels - 3, for RGB. If we iterate over such
a tensor, we will get a series of `B` tensors of shape `[H,W,C]`. The `.flatten()` method turns
this into a one dimensional tensor, of length `H*W*C`, `torch.mean()` takes the mean, and `.item()`
turns a single value tensor into a Python float.

```Python  theme={null}
def choose_image(self, images):
    brightness = list(torch.mean(image.flatten()).item() for image in images)
    brightest = brightness.index(max(brightness))
    result = images[brightest].unsqueeze(0)
    return (result,)
```

Notes on those last two lines:

* `images[brightest]` will return a Tensor of shape `[H,W,C]`. `unsqueeze` is used to insert a (length 1) dimension at, in this case, dimension zero, to give
  us `[B,H,W,C]` with `B=1`: a single image.
* in `return (result,)`, the trailing comma is essential to ensure you return a tuple.

### Register the node

To make Comfy recognize the new node, it must be available at the package level. Modify the `NODE_CLASS_MAPPINGS` variable at the end of `src/nodes.py`. You must restart ComfyUI to see any changes.

```Python src/nodes.py theme={null}

NODE_CLASS_MAPPINGS = {
    "Example" : Example,
    "Image Selector" : ImageSelector,
}

# Optionally, you can rename the node in the `NODE_DISPLAY_NAME_MAPPINGS` dictionary.
NODE_DISPLAY_NAME_MAPPINGS = {
    "Example": "Example Node",
    "Image Selector": "Image Selector",
}
```

<Info>For a detailed explanation of how ComfyUI discovers and loads custom nodes, see the [node lifecycle documentation](/custom-nodes/backend/lifecycle).</Info>

## Add some options

That node is maybe a bit boring, so we might add some options; a widget that allows you to
choose the brightest image, or the reddest, bluest, or greenest. Edit your `INPUT_TYPES` to look like:

```Python  theme={null}
@classmethod    
def INPUT_TYPES(s):
    return { "required":  { "images": ("IMAGE",), 
                            "mode": (["brightest", "reddest", "greenest", "bluest"],)} }
```

Then update the main function. We'll use a fairly naive definition of 'reddest' as being the average
`R` value of the pixels divided by the average of all three colors. So:

```Python  theme={null}
def choose_image(self, images, mode):
    batch_size = images.shape[0]
    brightness = list(torch.mean(image.flatten()).item() for image in images)
    if (mode=="brightest"):
        scores = brightness
    else:
        channel = 0 if mode=="reddest" else (1 if mode=="greenest" else 2)
        absolute = list(torch.mean(image[:,:,channel].flatten()).item() for image in images)
        scores = list( absolute[i]/(brightness[i]+1e-8) for i in range(batch_size) )
    best = scores.index(max(scores))
    result = images[best].unsqueeze(0)
    return (result,)
```

## Tweak the UI

Maybe we'd like a bit of visual feedback, so let's send a little text message to be displayed.

### Send a message from server

This requires two lines to be added to the Python code:

```Python  theme={null}
from server import PromptServer
```

and, at the end of the `choose_image` method, add a line to send a message to the front end (`send_sync` takes a message
type, which should be unique, and a dictionary)

```Python  theme={null}
PromptServer.instance.send_sync("example.imageselector.textmessage", {"message":f"Picked image {best+1}"})
return (result,)
```

### Write a client extension

To add some Javascript to the client, create a subdirectory, `web/js` in your custom node directory, and modify the end of `__init__.py`
to tell Comfy about it by exporting `WEB_DIRECTORY`:

```Python  theme={null}
WEB_DIRECTORY = "./web/js"
__all__ = ['NODE_CLASS_MAPPINGS', 'WEB_DIRECTORY']
```

The client extension is saved as a `.js` file in the `web/js` subdirectory, so create `image_selector/web/js/imageSelector.js` with the
code below. (For more, see [client side coding](./js/javascript_overview)).

```Javascript  theme={null}
import { app } from "../../scripts/app.js";
app.registerExtension({
	name: "example.imageselector",
    async setup() {
        function messageHandler(event) { alert(event.detail.message); }
        app.api.addEventListener("example.imageselector.textmessage", messageHandler);
    },
})
```

All we've done is register an extension and add a listener for the message type we are sending in the `setup()` method. This reads the dictionary we sent (which is stored in `event.detail`).

Stop the Comfy server, start it again, reload the webpage, and run your workflow.

### The complete example

The complete example is available [here](https://gist.github.com/robinjhuang/fbf54b7715091c7b478724fc4dffbd03). You can download the example workflow [JSON file](https://github.com/Comfy-Org/docs/blob/main/public/workflow.json) or view it below:

<div align="center">
  <img src="https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=a6f6c26f0dba136f864c59044909c55c" alt="Image Selector Workflow" width="100%" data-og-width="2264" data-og-height="1202" data-path="images/firstnodeworkflow.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=280&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=f2f67b0396e9d25543aeb3f3e3bb520c 280w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=560&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=9559b4d018dd5853f8a94bccf8056f45 560w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=840&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=0ce3e3b832cfe24004f61109ed025930 840w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=1100&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=2e82d92552ce1ae1315d35724f81db67 1100w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=1650&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=a61bedab96b65b0ef4c1d80650720821 1650w, https://mintcdn.com/dripart/EgZuQyCGLVUEw53Z/images/firstnodeworkflow.png?w=2500&fit=max&auto=format&n=EgZuQyCGLVUEw53Z&q=85&s=b5363f7ee4b36b0c132f1691e886c6d1 2500w" />
</div>

# Backend

# Properties

> Properties of a custom node

### Simple Example

Here's the code for the Invert Image Node, which gives an overview of the key concepts in custom node development.

```python  theme={null}
class InvertImageNode:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": { "image_in" : ("IMAGE", {}) },
        }

    RETURN_TYPES = ("IMAGE",)
    RETURN_NAMES = ("image_out",)
    CATEGORY = "examples"
    FUNCTION = "invert"

    def invert(self, image_in):
        image_out = 1 - image_in
        return (image_out,)
```

### Main properties

Every custom node is a Python class, with the following key properties:

#### INPUT\_TYPES

`INPUT_TYPES`, as the name suggests, defines the inputs for the node. The method returns a `dict`
which *must* contain the key `required`, and *may* also include the keys `optional` and/or `hidden`. The only difference
between `required` and `optional` inputs is that `optional` inputs can be left unconnected.
For more information on `hidden` inputs, see [Hidden Inputs](./more_on_inputs#hidden-inputs).

Each key has, as its value, another `dict`, in which key-value pairs specify the names and types of the inputs.
The types are defined by a `tuple`, the first element of which defines the data type,
and the second element of which is a `dict` of additional parameters.

Here we have just one required input, named `image_in`, of type `IMAGE`, with no additional parameters.

Note that unlike the next few attributes, this `INPUT_TYPES` is a `@classmethod`. This is so
that the options in dropdown widgets (like the name of the checkpoint to be loaded) can be
computed by Comfy at run time. We'll go into this more later. {/* TODO link when written */}

#### RETURN\_TYPES

A `tuple` of `str` defining the data types returned by the node.
If the node has no outputs this must still be provided `RETURN_TYPES = ()`
<Warning>If you have exactly one output, remember the trailing comma: `RETURN_TYPES = ("IMAGE",)`.
This is required for Python to make it a `tuple`</Warning>

#### RETURN\_NAMES

The names to be used to label the outputs. This is optional; if omitted, the names are simply the `RETURN_TYPES` in lowercase.

#### CATEGORY

Where the node will be found in the ComfyUI **Add Node** menu. Submenus can be specified as a path, eg. `examples/trivial`.

#### FUNCTION

The name of the Python function in the class that should be called when the node is executed.

The function is called with named arguments. All `required` (and `hidden`) inputs will be included;
`optional` inputs will be included only if they are connected, so you should provide default values for them in the function
definition (or capture them with `**kwargs`).

The function returns a tuple corresponding to the `RETURN_TYPES`. This is required even if nothing is returned (`return ()`).
Again, if you only have one output, remember that trailing comma `return (image_out,)`!

### Execution Control Extras

A great feature of Comfy is that it caches outputs,
and only executes nodes that might produce a different result than the previous run.
This can greatly speed up lots of workflows.

In essence this works by identifying which nodes produce an output (these, notably the Image Preview and Save Image nodes, are always executed), and then working
backwards to identify which nodes provide data that might have changed since the last run.

Two optional features of a custom node assist in this process.

#### OUTPUT\_NODE

By default, a node is not considered an output. Set `OUTPUT_NODE = True` to specify that it is.

#### IS\_CHANGED

By default, Comfy considers that a node has changed if any of its inputs or widgets have changed.
This is normally correct, but you may need to override this if, for instance, the node uses a random
number (and does not specify a seed - it's best practice to have a seed input in this case so that
the user can control reproducibility and avoid unnecessary execution), or loads an input that may have
changed externally, or sometimes ignores inputs (so doesn't need to execute just because those inputs changed).

<Warning>Despite the name, IS\_CHANGED should not return a `bool`</Warning>

`IS_CHANGED` is passed the same arguments as the main function defined by `FUNCTION`, and can return any
Python object. This object is compared with the one returned in the previous run (if any) and the node
will be considered to have changed if `is_changed != is_changed_old` (this code is in `execution.py` if you need to dig).

Since `True == True`, a node that returns `True` to say it has changed will be considered not to have! I'm sure this would
be changed in the Comfy code if it wasn't for the fact that it might break existing nodes to do so.

To specify that your node should always be considered to have changed (which you should avoid if possible, since it
stops Comfy optimising what gets run), `return float("NaN")`. This returns a `NaN` value, which is not equal
to anything, even another `NaN`.

A good example of actually checking for changes is the code from the built-in LoadImage node, which loads the image and returns a hash

```python  theme={null}
    @classmethod
    def IS_CHANGED(s, image):
        image_path = folder_paths.get_annotated_filepath(image)
        m = hashlib.sha256()
        with open(image_path, 'rb') as f:
            m.update(f.read())
        return m.digest().hex()
```

### Other attributes

There are three other attributes that can be used to modify the default Comfy treatment of a node.

#### INPUT\_IS\_LIST, OUTPUT\_IS\_LIST

These are used to control sequential processing of data, and are described [later](./lists).

### VALIDATE\_INPUTS

If a class method `VALIDATE_INPUTS` is defined, it will be called before the workflow begins execution.
`VALIDATE_INPUTS` should return `True` if the inputs are valid, or a message (as a `str`) describing the error (which will prevent execution).

#### Validating Constants

<Warning>Note that `VALIDATE_INPUTS` will only receive inputs that are defined as constants within the workflow. Any inputs that are received from other nodes will *not* be available in `VALIDATE_INPUTS`.</Warning>

`VALIDATE_INPUTS` is called with only the inputs that its signature requests (those returned by `inspect.getfullargspec(obj_class.VALIDATE_INPUTS).args`). Any inputs which are received in this way will *not* run through the default validation rules. For example, in the following snippet, the front-end will use the specified `min` and `max` values of the `foo` input, but the back-end will not enforce it.

```python  theme={null}
class CustomNode:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": { "foo" : ("INT", {"min": 0, "max": 10}) },
        }

    @classmethod
    def VALIDATE_INPUTS(cls, foo):
        # YOLO, anything goes!
        return True
```

Additionally, if the function takes a `**kwargs` input, it will receive *all* available inputs and all of them will skip validation as if specified explicitly.

#### Validating Types

If the `VALIDATE_INPUTS` method receives an argument named `input_types`, it will be passed a dictionary in which the key is the name of each input which is connected to an output from another node and the value is the type of that output.

When this argument is present, all default validation of input types is skipped. Here's an example making use of the fact that the front-end allows for the specification of multiple types:

```python  theme={null}
class AddNumbers:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "input1" : ("INT,FLOAT", {"min": 0, "max": 1000})
                "input2" : ("INT,FLOAT", {"min": 0, "max": 1000})
            },
        }

    @classmethod
    def VALIDATE_INPUTS(cls, input_types):
        # The min and max of input1 and input2 are still validated because
        # we didn't take `input1` or `input2` as arguments
        if input_types["input1"] not in ("INT", "FLOAT"):
            return "input1 must be an INT or FLOAT type"
        if input_types["input2"] not in ("INT", "FLOAT"):
            return "input2 must be an INT or FLOAT type"
        return True
```

# Lifecycle

## How Comfy loads custom nodes

When Comfy starts, it scans the directory `custom_nodes` for Python modules, and attempts to load them.
If the module exports `NODE_CLASS_MAPPINGS`, it will be treated as a custom node.
<Tip>A python module is a directory containing an `__init__.py` file.
The module exports whatever is listed in the `__all__` attribute defined in `__init__.py`.</Tip>

### **init**.py

`__init__.py` is executed when Comfy attempts to import the module. For a module to be recognized as containing
custom node definitions, it needs to export `NODE_CLASS_MAPPINGS`. If it does (and if nothing goes wrong in the import),
the nodes defined in the module will be available in Comfy. If there is an error in your code,
Comfy will continue, but will report the module as having failed to load. So check the Python console!

A very simple `__init__.py` file would look like this:

```python  theme={null}
from .python_file import MyCustomNode
NODE_CLASS_MAPPINGS = { "My Custom Node" : MyCustomNode }
__all__ = ["NODE_CLASS_MAPPINGS"]
```

#### NODE\_CLASS\_MAPPINGS

`NODE_CLASS_MAPPINGS` must be a `dict` mapping custom node names (unique across the Comfy install)
to the corresponding node class.

#### NODE\_DISPLAY\_NAME\_MAPPINGS

`__init__.py` may also export `NODE_DISPLAY_NAME_MAPPINGS`, which maps the same unique name to a display name for the node.
If `NODE_DISPLAY_NAME_MAPPINGS` is not provided, Comfy will use the unique name as the display name.

#### WEB\_DIRECTORY

If you are deploying client side code, you will also need to export the path, relative to the module, in which the
JavaScript files are to be found. It is conventional to place these in a subdirectory of your custom node named `js`.
<Tip>*Only* `.js` files will be served; you can't deploy `.css` or other types in this way</Tip>

<Warning>In previous versions of Comfy, `__init__.py` was required to copy the JavaScript files into the main Comfy web
subdirectory. You will still see code that does this. Don't.</Warning>

# Datatypes

These are the most important built in datatypes. You can also [define your own](./more_on_inputs#custom-datatypes).

Datatypes are used on the client side to prevent a workflow from passing the wrong form of data into a node - a bit like strong typing.
The JavaScript client side code will generally not allow a node output to be connected to an input of a different datatype,
although a few exceptions are noted below.

## Comfy datatypes

### COMBO

* No additional parameters in `INPUT_TYPES`

* Python datatype: defined as `list[str]`, output value is `str`

Represents a dropdown menu widget.
Unlike other datatypes, `COMBO` it is not specified in `INPUT_TYPES` by a `str`, but by a `list[str]`
corresponding to the options in the dropdown list, with the first option selected by default.

`COMBO` inputs are often dynamically generated at run time. For instance, in the built-in `CheckpointLoaderSimple` node, you find

```
"ckpt_name": (folder_paths.get_filename_list("checkpoints"), )
```

or they might just be a fixed list of options,

```
"play_sound": (["no","yes"], {}),
```

### Primitive and reroute

Primitive and reroute nodes only exist on the client side. They do not have an intrinsic datatype, but when connected they take on
the datatype of the input or output to which they have been connected (which is why they can't connect to a `*` input...)

## Python datatypes

### INT

* Additional parameters in `INPUT_TYPES`:

  * `default` is required

  * `min` and `max` are optional

* Python datatype `int`

### FLOAT

* Additional parameters in `INPUT_TYPES`:

  * `default` is required

  * `min`, `max`, `step` are optional

* Python datatype `float`

### STRING

* Additional parameters in `INPUT_TYPES`:

  * `default` is required

* Python datatype `str`

### BOOLEAN

* Additional parameters in `INPUT_TYPES`:

  * `default` is required

* Python datatype `bool`

## Tensor datatypes

### IMAGE

* No additional parameters in `INPUT_TYPES`

* Python datatype `torch.Tensor` with *shape* \[B,H,W,C]

A batch of `B` images, height `H`, width `W`, with `C` channels (generally `C=3` for `RGB`).

### LATENT

* No additional parameters in `INPUT_TYPES`

* Python datatype `dict`, containing a `torch.Tensor` with *shape* \[B,C,H,W]

The `dict` passed contains the key `samples`, which is a `torch.Tensor` with *shape* \[B,C,H,W] representing
a batch of `B` latents, with `C` channels (generally `C=4` for existing stable diffusion models), height `H`, width `W`.

The height and width are 1/8 of the corresponding image size (which is the value you set in the Empty Latent Image node).

Other entries in the dictionary contain things like latent masks.

{/* TODO new SD models might have different C values? */}

### MASK

* No additional parameters in `INPUT_TYPES`

* Python datatype `torch.Tensor` with *shape* \[H,W] or \[B,C,H,W]

### AUDIO

* No additional parameters in `INPUT_TYPES`

* Python datatype `dict`, containing a `torch.Tensor` with *shape* \[B, C, T] and a sample rate.

The `dict` passed contains the key `waveform`, which is a `torch.Tensor` with *shape* \[B, C, T] representing a batch of `B` audio samples, with `C` channels (`C=2` for stereo and `C=1` for mono), and `T` time steps (i.e., the number of audio samples).

The `dict` contains another key `sample_rate`, which indicates the sampling rate of the audio.

## Custom Sampling datatypes

### Noise

The `NOISE` datatype represents a *source* of noise (not the actual noise itself). It can be represented by any Python object
that provides a method to generate noise, with the signature `generate_noise(self, input_latent:Tensor) -> Tensor`, and a
property, `seed:Optional[int]`.

<Tip>The `seed` is passed into `sample` guider in the `SamplerCustomAdvanced`, but does not appear to be used in any of the standard guiders.
It is Optional, so you can generally set it to None.</Tip>

When noise is to be added, the latent is passed into this method, which should return a `Tensor` of the same shape containing the noise.

See the [noise mixing example](./snippets#creating-noise-variations)

### Sampler

The `SAMPLER` datatype represents a sampler, which is represented as a Python object providing a `sample` method.
Stable diffusion sampling is beyond the scope of this guide; see `comfy/samplers.py` if you want to dig into this part of the code.

### Sigmas

The `SIGMAS` datatypes represents the values of sigma before and after each step in the sampling process, as produced by a scheduler.
This is represented as a one-dimensional tensor, of length `steps+1`, where each element represents the noise expected to be present
before the corresponding step, with the final value representing the noise present after the final step.

A `normal` scheduler, with 20 steps and denoise of 1, for an SDXL model, produces:

```
tensor([14.6146, 10.7468,  8.0815,  6.2049,  4.8557,  
         3.8654,  3.1238,  2.5572,  2.1157,  1.7648,  
         1.4806,  1.2458,  1.0481,  0.8784,  0.7297,  
         0.5964,  0.4736,  0.3555,  0.2322,  0.0292,  0.0000])
```

<Tip>The starting value of sigma depends on the model, which is why a scheduler node requires a `MODEL` input to produce a SIGMAS output</Tip>

### Guider

A `GUIDER` is a generalisation of the denoising process, as 'guided' by a prompt or any other form of conditioning. In Comfy the guider is
represented by a `callable` Python object providing a `__call__(*args, **kwargs)` method which is called by the sample.

The `__call__` method takes (in `args[0]`) a batch of noisy latents (tensor `[B,C,H,W]`), and returns a prediction of the noise (a tensor of the same shape).

## Model datatypes

There are a number of more technical datatypes for stable diffusion models. The most significant ones are `MODEL`, `CLIP`, `VAE` and `CONDITIONING`.
Working with these is (for the time being) beyond the scope of this guide! {/* TODO but maybe not forever */}

## Additional Parameters

Below is a list of officially supported keys that can be used in the 'extra options' portion of an input definition.

<Warning>You can use additional keys for your own custom widgets, but should *not* reuse any of the keys below for other purposes.</Warning>

| Key              | Description                                                                                                                                                                                      |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `default`        | The default value of the widget                                                                                                                                                                  |
| `min`            | The minimum value of a number (`FLOAT` or `INT`)                                                                                                                                                 |
| `max`            | The maximum value of a number (`FLOAT` or `INT`)                                                                                                                                                 |
| `step`           | The amount to increment or decrement a widget                                                                                                                                                    |
| `label_on`       | The label to use in the UI when the bool is `True` (`BOOL`)                                                                                                                                      |
| `label_off`      | The label to use in the UI when the bool is `False` (`BOOL`)                                                                                                                                     |
| `defaultInput`   | Defaults to an input socket rather than a supported widget                                                                                                                                       |
| `forceInput`     | `defaultInput` and also don't allow converting to a widget                                                                                                                                       |
| `multiline`      | Use a multiline text box (`STRING`)                                                                                                                                                              |
| `placeholder`    | Placeholder text to display in the UI when empty (`STRING`)                                                                                                                                      |
| `dynamicPrompts` | Causes the front-end to evaluate dynamic prompts                                                                                                                                                 |
| `lazy`           | Declares that this input uses [Lazy Evaluation](./lazy_evaluation)                                                                                                                               |
| `rawLink`        | When a link exists, rather than receiving the evaluated value, you will receive the link (i.e. `["nodeId", <outputIndex>]`). Primarily useful when your node uses [Node Expansion](./expansion). |

# Images, Latents, and Masks

When working with these datatypes, you will need to know about the `torch.Tensor` class.
Complete documentation is [here](https://pytorch.org/docs/stable/tensors.html), or
an introduction to the key concepts required for Comfy [here](./tensors).

<Warning>If your node has a single output which is a tensor, remember to return `(image,)` not `(image)`</Warning>

Most of the concepts below are illustrated in the [example code snippets](./snippets).

## Images

An IMAGE is a `torch.Tensor` with shape `[B,H,W,C]`, `C=3`. If you are going to save or load images, you will
need to convert to and from `PIL.Image` format - see the code snippets below! Note that some `pytorch` operations
offer (or expect) `[B,C,H,W]`, known as 'channel first', for reasons of computational efficiency. Just be careful.

### Working with PIL.Image

If you want to load and save images, you'll want to use PIL:

```python  theme={null}
from PIL import Image, ImageOps
```

## Masks

A MASK is a `torch.Tensor` with shape `[B,H,W]`.
In many contexts, masks have binary values (0 or 1), which are used to indicate which pixels should undergo specific operations.
In some cases values between 0 and 1 are used indicate an extent of masking, (for instance, to alter transparency, adjust filters, or composite layers).

### Masks from the Load Image Node

The `LoadImage` node uses an image's alpha channel (the "A" in "RGBA") to create MASKs.
The values from the alpha channel are normalized to the range \[0,1] (torch.float32) and then inverted.
The `LoadImage` node always produces a MASK output when loading an image. Many images (like JPEGs) don't have an alpha channel.
In these cases, `LoadImage` creates a default mask with the shape `[1, 64, 64]`.

### Understanding Mask Shapes

In libraries like `numpy`, `PIL`, and many others, single-channel images (like masks) are typically represented as 2D arrays, shape `[H,W]`.
This means the `C` (channel) dimension is implicit, and thus unlike IMAGE types, batches of MASKs have only three dimensions: `[B, H, W]`.
It is not uncommon to encounter a mask which has had the `B` dimension implicitly squeezed, giving a tensor `[H,W]`.

To use a MASK, you will often have to match shapes by unsqueezing to produce a shape `[B,H,W,C]` with `C=1`
To unsqueezing the `C` dimension, so you should `unsqueeze(-1)`, to unsqueeze `B`, you `unsqueeze(0)`.
If your node receives a MASK as input, you would be wise to always check `len(mask.shape)`.

## Latents

A LATENT is a `dict`; the latent sample is referenced by the key `samples` and has shape `[B,C,H,W]`, with `C=4`.

<Tip>LATENT is channel first, IMAGE is channel last</Tip>

# Hidden and Flexible inputs

## Hidden inputs

Alongside the `required` and `optional` inputs, which create corresponding inputs or widgets on the client-side,
there are three `hidden` input options which allow the custom node to request certain information from the server.

These are accessed by returning a value for `hidden` in the `INPUT_TYPES` `dict`, with the signature `dict[str,str]`,
containing one or more of `PROMPT`, `EXTRA_PNGINFO`, or `UNIQUE_ID`

```python  theme={null}
@classmethod
def INPUT_TYPES(s):
    return {
        "required": {...},
        "optional": {...},
        "hidden": {
            "unique_id": "UNIQUE_ID",
            "prompt": "PROMPT", 
            "extra_pnginfo": "EXTRA_PNGINFO",
        }
    }
```

### UNIQUE\_ID

`UNIQUE_ID` is the unique identifier of the node, and matches the `id` property of the node on the client side.
It is commonly used in client-server communications (see [messages](/development/comfyui-server/comms_messages#getting-node-id)).

### PROMPT

`PROMPT` is the complete prompt sent by the client to the server.
See [the prompt object](/custom-nodes/js/javascript_objects_and_hijacking#prompt) for a full description.

### EXTRA\_PNGINFO

`EXTRA_PNGINFO` is a dictionary that will be copied into the metadata of any `.png` files saved. Custom nodes can store additional
information in this dictionary for saving (or as a way to communicate with a downstream node).

<Tip>Note that if Comfy is started with the `disable_metadata` option, this data won't be saved.</Tip>

### DYNPROMPT

`DYNPROMPT` is an instance of `comfy_execution.graph.DynamicPrompt`. It differs from `PROMPT` in that it may mutate during the course of execution in response to [Node Expansion](/custom-nodes/backend/expansion).
<Tip>`DYNPROMPT` should only be used for advanced cases (like implementing loops in custom nodes).</Tip>

## Flexible inputs

### Custom datatypes

If you want to pass data between your own custom nodes, you may find it helpful to define a custom datatype. This is (almost) as simple as
just choosing a name for the datatype, which should be a unique string in upper case, such as `CHEESE`.

You can then use `CHEESE` in your node `INPUT_TYPES` and `RETURN_TYPES`, and the Comfy client will only allow `CHEESE` outputs to connect to a `CHEESE` input.
`CHEESE` can be any python object.

The only point to note is that because the Comfy client doesn't know about `CHEESE` you need (unless you define a custom widget for `CHEESE`,
which is a topic for another day), to force it to be an input rather than a widget. This can be done with the `forceInput` option in the input options dictionary:

```python  theme={null}
@classmethod
def INPUT_TYPES(s):
    return {
        "required": { "my_cheese": ("CHEESE", {"forceInput":True}) }
    }
```

### Wildcard inputs

```python  theme={null}
@classmethod
def INPUT_TYPES(s):
    return {
        "required": { "anything": ("*",{})},
    }

@classmethod
def VALIDATE_INPUTS(s, input_types):
    return True
```

The frontend allows `*` to indicate that an input can be connected to any source. Because this is not officially supported by the backend, you can skip the backend validation of types by accepting a parameter named `input_types` in your `VALIDATE_INPUTS` function. (See [VALIDATE\_INPUTS](./server_overview#validate-inputs) for more information.)
It's up to the node to make sense of the data that is passed.

### Dynamically created inputs

If inputs are dynamically created on the client side, they can't be defined in the Python source code.
In order to access this data we need an `optional` dictionary that allows Comfy to pass data with
arbitrary names. Since the Comfy server

```python  theme={null}
class ContainsAnyDict(dict):
    def __contains__(self, key):
        return True
...

@classmethod
def INPUT_TYPES(s):
    return {
        "required": {},
        "optional": ContainsAnyDict()
    }
...

def main_method(self, **kwargs):
    # the dynamically created input data will be in the dictionary kwargs

```

<Tip>Hat tip to rgthree for this pythonic trick!</Tip>

# Lazy Evaluation

## Lazy Evaluation

By default, all `required` and `optional` inputs are evaluated before a node can be run. Sometimes, however, an
input won't necessarily be used and evaluating it would result in unnecessary processing. Here are some examples
of nodes where lazy evaluation may be beneficial:

1. A `ModelMergeSimple` node where the ratio is either `0.0` (in which case the first model doesn't need to be loaded)
   or `1.0` (in which case the second model doesn't need to be loaded).
2. Interpolation between two images where the ratio (or mask) is either entirely `0.0` or entirely `1.0`.
3. A Switch node where one input determines which of the other inputs will be passed through.

<Tip>There is very little cost in making an input lazy. If it's something you can do, you generally should.</Tip>

### Creating Lazy Inputs

There are two steps to making an input a "lazy" input. They are:

1. Mark the input as lazy in the dictionary returned by `INPUT_TYPES`
2. Define a method named `check_lazy_status` (note: *not* a class method) that will be called prior to evaluation to determine if any more inputs are necessary.

To demonstrate these, we'll make a "MixImages" node that interpolates between two images according to a mask. If the entire mask is `0.0`, we don't need to evaluate any part of the tree leading up to the second image. If the entire mask is `1.0`, we can skip evaluating the first image.

#### Defining `INPUT_TYPES`

Declaring that an input is lazy is as simple as adding a `lazy: True` key-value pair to the input's options dictionary.

```python  theme={null}
@classmethod
def INPUT_TYPES(cls):
    return {
        "required": {
````
Assistant

ðŸ› ï¸ read_file (call_MHw4WHRHbUw1ZDdmR0RnalRBYlo) {
  "endLine": 2400,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\COMFYUI_RAW_DOCS.md",
  "startLine": 1201
}
Tool
ðŸ› ï¸ call_MHw4WHRHbUw1ZDdmR0RnalRBYlo
File: `c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md`. Lines 1201 to 2400 (4378 lines total): 
````markdown
            "image1": ("IMAGE",{"lazy": True}),
            "image2": ("IMAGE",{"lazy": True}),
            "mask": ("MASK",),
        },
    }
```

In this example, `image1` and `image2` are both marked as lazy inputs, but `mask` will always be evaluated.

#### Defining `check_lazy_status`

A `check_lazy_status` method is called if there are one or more lazy inputs that are not yet available. This method receives the same arguments as the standard execution function. All available inputs are passed in with their final values while unavailable lazy inputs have a value of `None`.

The responsibility of the `check_lazy_status` function is to return a list of the names of any lazy inputs that are needed to proceed. If all lazy inputs are available, the function should return an empty list.

Note that `check_lazy_status` may be called multiple times. (For example, you might find after evaluating one lazy input that you need to evaluate another.)

<Tip>Note that because the function uses actual input values, it is *not* a class method.</Tip>

```python  theme={null}
def check_lazy_status(self, mask, image1, image2):
    mask_min = mask.min()
    mask_max = mask.max()
    needed = []
    if image1 is None and (mask_min != 1.0 or mask_max != 1.0):
        needed.append("image1")
    if image2 is None and (mask_min != 0.0 or mask_max != 0.0):
        needed.append("image2")
    return needed
```

### Full Example

```python  theme={null}
class LazyMixImages:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image1": ("IMAGE",{"lazy": True}),
                "image2": ("IMAGE",{"lazy": True}),
                "mask": ("MASK",),
            },
        }

    RETURN_TYPES = ("IMAGE",)
    FUNCTION = "mix"

    CATEGORY = "Examples"

    def check_lazy_status(self, mask, image1, image2):
        mask_min = mask.min()
        mask_max = mask.max()
        needed = []
        if image1 is None and (mask_min != 1.0 or mask_max != 1.0):
            needed.append("image1")
        if image2 is None and (mask_min != 0.0 or mask_max != 0.0):
            needed.append("image2")
        return needed

    # Not trying to handle different batch sizes here just to keep the demo simple
    def mix(self, mask, image1, image2):
        mask_min = mask.min()
        mask_max = mask.max()
        if mask_min == 0.0 and mask_max == 0.0:
            return (image1,)
        elif mask_min == 1.0 and mask_max == 1.0:
            return (image2,)

        result = image1 * (1. - mask) + image2 * mask,
        return (result[0],)
```

## Execution Blocking

While Lazy Evaluation is the recommended way to "disable" part of a graph, there are times when you want to disable an `OUTPUT` node that doesn't implement lazy evaluation itself. If it's an output node that you developed yourself, you should just add lazy evaluation as follows:

1. Add a required (if this is a new node) or optional (if you care about backward compatibility) input for `enabled` that defaults to `True`
2. Make all other inputs `lazy` inputs
3. Only evaluate the other inputs if `enabled` is `True`

If it's not a node you control, you can make use of a `comfy_execution.graph.ExecutionBlocker`. This special object can be returned as an output from any socket. Any nodes which receive an `ExecutionBlocker` as input will skip execution and return that `ExecutionBlocker` for any outputs.

<Tip>**There is intentionally no way to stop an ExecutionBlocker from propagating forward.** If you think you want this, you should really be using Lazy Evaluation.</Tip>

### Usage

There are two ways to construct and use an `ExecutionBlocker`

1. Pass `None` into the constructor to silently block execution. This is useful for cases where blocking execution is part of a successful run -- like disabling an output.

```python  theme={null}
def silent_passthrough(self, passthrough, blocked):
    if blocked:
        return (ExecutionBlocker(None),)
    else:
        return (passthrough,)
```

2. Pass a string into the constructor to display an error message when a node is blocked due to receiving the object. This can be useful if you want to display a meaningful error message if someone uses a meaningless output -- for example, the `VAE` output when loading a model that doesn't contain VAEs.

```python  theme={null}
def load_checkpoint(self, ckpt_name):
    ckpt_path = folder_paths.get_full_path("checkpoints", ckpt_name)
    model, clip, vae = load_checkpoint(ckpt_path)
    if vae is None:
        # This error is more useful than a "'NoneType' has no attribute" error
        # in a later node
        vae = ExecutionBlocker(f"No VAE contained in the loaded model {ckpt_name}")
    return (model, clip, vae)
```
# Node Expansion

## Node Expansion

Normally, when a node is executed, that execution function immediately returns the output results of that node. "Node Expansion" is a relatively advanced technique that allows nodes to return a new subgraph of nodes that should take its place in the graph. This technique is what allows custom nodes to implement loops.

### A Simple Example

First, here's a simple example of what node expansion looks like:

<Tip>We highly recommend using the `GraphBuilder` class when creating subgraphs. It isn't mandatory, but it prevents you from making many easy mistakes.</Tip>

```python  theme={null}
def load_and_merge_checkpoints(self, checkpoint_path1, checkpoint_path2, ratio):
    from comfy_execution.graph_utils import GraphBuilder # Usually at the top of the file
    graph = GraphBuilder()
    checkpoint_node1 = graph.node("CheckpointLoaderSimple", checkpoint_path=checkpoint_path1)
    checkpoint_node2 = graph.node("CheckpointLoaderSimple", checkpoint_path=checkpoint_path2)
    merge_model_node = graph.node("ModelMergeSimple", model1=checkpoint_node1.out(0), model2=checkpoint_node2.out(0), ratio=ratio)
    merge_clip_node = graph.node("ClipMergeSimple", clip1=checkpoint_node1.out(1), clip2=checkpoint_node2.out(1), ratio=ratio)
    return {
        # Returning (MODEL, CLIP, VAE) outputs
        "result": (merge_model_node.out(0), merge_clip_node.out(0), checkpoint_node1.out(2)),
        "expand": graph.finalize(),
    }
```

While this same node could previously be implemented by manually calling into ComfyUI internals, using expansion means that each subnode will be cached separately (so if you change `model2`, you don't have to reload `model1`).

### Requirements

In order to perform node expansion, a node must return a dictionary with the following keys:

1. `result`: A tuple of the outputs of the node. This may be a mix of finalized values (like you would return from a normal node) and node outputs.
2. `expand`: The finalized graph to perform expansion on. See below if you are not using the `GraphBuilder`.

#### Additional Requirements if not using GraphBuilder

The format expected from the `expand` key is the same as the ComfyUI API format. The following requirements are handled by the `GraphBuilder`, but must be handled manually if you choose to forego it:

1. Node IDs must be unique across the entire graph. (This includes between multiple executions of the same node due to the use of lists.)
2. Node IDs must be deterministic and consistent between multiple executions of the graph (including partial executions due to caching).

Even if you don't want to use the `GraphBuilder` for actually building the graph (e.g. because you're loading the raw json of the graph from a file), you can use the `GraphBuilder.alloc_prefix()` function to generate a prefix and `comfy.graph_utils.add_graph_prefix` to fix existing graphs to meet these requirements.

### Efficient Subgraph Caching

While you can pass non-literal inputs to nodes within the subgraph (like torch tensors), this can inhibit caching *within* the subgraph. When possible, you should pass links to subgraph objects rather than the node itself. (You can declare an input as a `rawLink` within the input's [Additional Parameters](./datatypes#additional-parameters) to do this easily.)

# Data lists

## Length one processing

Internally, the Comfy server represents data flowing from one node to the next as a Python `list`, normally length 1, of the relevant datatype.
In normal operation, when a node returns an output, each element in the output `tuple` is separately wrapped in a list (length 1); then when the
next node is called, the data is unwrapped and passed to the main function.

<Tip>You generally don't need to worry about this, since Comfy does the wrapping and unwrapping.</Tip>

<Tip>This isn't about batches. A batch (of, for instance, latents, or images) is a *single entry* in the list (see [tensor datatypes](./images_and_masks))</Tip>

## List processing

In some circumstance, multiple data instances are processed in a single workflow, in which case the internal data will be a list containing the data instances.
An example of this might be processing a series of images one at a time to avoid running out of VRAM, or handling images of different sizes.

By default, Comfy will process the values in the list sequentially:

* if the inputs are `list`s of different lengths, the shorter ones are padded by repeating the last value
* the main method is called once for each value in the input lists
* the outputs are `list`s, each of which is the same length as the longest input

The relevant code can be found in the method `map_node_over_list` in `execution.py`.

However, as Comfy wraps node outputs into a `list` of length one, if the `tuple` returned by
a custom node contains a `list`, that `list` will be wrapped, and treated as a single piece of data.
In order to tell Comfy that the list being returned should not be wrapped, but treated as a series of data for sequential processing,
the node should provide a class attribute `OUTPUT_IS_LIST`, which is a `tuple[bool]`, of the same length as `RETURN_TYPES`, specifying
which outputs which should be so treated.

A node can also override the default input behaviour and receive the whole list in a single call. This is done by setting a class attribute
`INPUT_IS_LIST` to `True`.

Here's a (lightly annotated) example from the built in nodes - `ImageRebatch` takes one or more batches of images (received as a list, because `INPUT_IS_LIST - True`)
and rebatches them into batches of the requested size.

<Tip>`INPUT_IS_LIST` is node level - all inputs get the same treatment. So the value of the `batch_size` widget is given by `batch_size[0]`.</Tip>

```Python  theme={null}

class ImageRebatch:
    @classmethod
    def INPUT_TYPES(s):
        return {"required": { "images": ("IMAGE",),
                              "batch_size": ("INT", {"default": 1, "min": 1, "max": 4096}) }}
    RETURN_TYPES = ("IMAGE",)
    INPUT_IS_LIST = True
    OUTPUT_IS_LIST = (True, )
    FUNCTION = "rebatch"
    CATEGORY = "image/batch"

    def rebatch(self, images, batch_size):
        batch_size = batch_size[0]    # everything comes as a list, so batch_size is list[int]

        output_list = []
        all_images = []
        for img in images:                    # each img is a batch of images
            for i in range(img.shape[0]):     # each i is a single image
                all_images.append(img[i:i+1])

        for i in range(0, len(all_images), batch_size): # take batch_size chunks and turn each into a new batch
            output_list.append(torch.cat(all_images[i:i+batch_size], dim=0))  # will die horribly if the image batches had different width or height!

        return (output_list,)
```
# Annotated Examples

A growing collection of fragments of example code...

## Images and Masks

### Load an image

Load an image into a batch of size 1 (based on `LoadImage` source code in `nodes.py`)

```python  theme={null}
i = Image.open(image_path)
i = ImageOps.exif_transpose(i)
if i.mode == 'I':
    i = i.point(lambda i: i * (1 / 255))
image = i.convert("RGB")
image = np.array(image).astype(np.float32) / 255.0
image = torch.from_numpy(image)[None,]
```

### Save an image batch

Save a batch of images (based on `SaveImage` source code in `nodes.py`)

```python  theme={null}
for (batch_number, image) in enumerate(images):
    i = 255. * image.cpu().numpy()
    img = Image.fromarray(np.clip(i, 0, 255).astype(np.uint8))
    filepath = # some path that takes the batch number into account
    img.save(filepath)
```

### Invert a mask

Inverting a mask is a straightforward process. Since masks are normalised to the range \[0,1]:

```python  theme={null}
mask = 1.0 - mask
```

### Convert a mask to Image shape

```Python  theme={null}
# We want [B,H,W,C] with C = 1
if len(mask.shape)==2: # we have [H,W], so insert B and C as dimension 1
    mask = mask[None,:,:,None]
elif len(mask.shape)==3 and mask.shape[2]==1: # we have [H,W,C]
    mask = mask[None,:,:,:]
elif len(mask.shape)==3:                      # we have [B,H,W]
    mask = mask[:,:,:,None]
```

### Using Masks as Transparency Layers

When used for tasks like inpainting or segmentation, the MASK's values will eventually be rounded to the nearest integer so that they are binary â€” 0 indicating regions to be ignored and 1 indicating regions to be targeted. However, this doesn't happen until the MASK is passed to those nodes. This flexibility allows you to use MASKs as you would in digital photography contexts as a transparency layer:

```python  theme={null}
# Invert mask back to original transparency layer
mask = 1.0 - mask

# Unsqueeze the `C` (channels) dimension
mask = mask.unsqueeze(-1)

# Concatenate ("cat") along the `C` dimension
rgba_image = torch.cat((rgb_image, mask), dim=-1)
```

## Noise

### Creating noise variations

Here's an example of creating a noise object which mixes the noise from two sources. This could be used to create slight noise variations by varying `weight2`.

```python  theme={null}
class Noise_MixedNoise:
    def __init__(self, nosie1, noise2, weight2):
        self.noise1  = noise1
        self.noise2  = noise2
        self.weight2 = weight2

    @property
    def seed(self): return self.noise1.seed

    def generate_noise(self, input_latent:torch.Tensor) -> torch.Tensor:
        noise1 = self.noise1.generate_noise(input_latent)
        noise2 = self.noise2.generate_noise(input_latent)
        return noise1 * (1.0-self.weight2) + noise2 * (self.weight2)
```

# Working with torch.Tensor

## pytorch, tensors, and torch.Tensor

All the core number crunching in Comfy is done by [pytorch](https://pytorch.org/). If your custom nodes are going
to get into the guts of stable diffusion you will need to become familiar with this library, which is way beyond
the scope of this introduction.

However, many custom nodes will need to manipulate images, latents and masks, each of which are represented internally
as `torch.Tensor`, so you'll want to bookmark the
[documentation for torch.Tensor](https://pytorch.org/docs/stable/tensors.html).

### What is a Tensor?

`torch.Tensor` represents a tensor, which is the mathematical generalization of a vector or matrix to any number of dimensions.
A tensor's *rank* is the number of dimensions it has (so a vector has *rank* 1, a matrix *rank* 2); its *shape* describes the
size of each dimension.

So an RGB image (of height H and width W) might be thought of as three arrays (one for each color channel), each measuring H x W,
which could be represented as a tensor with *shape* `[H,W,3]`. In Comfy images almost always come in a batch (even if the batch
only contains a single image). `torch` always places the batch dimension first, so Comfy images have *shape* `[B,H,W,3]`, generally
written as `[B,H,W,C]` where C stands for Channels.

### squeeze, unsqueeze, and reshape

If a tensor has a dimension of size 1 (known as a collapsed dimension), it is equivalent to the same tensor with that dimension removed
(a batch with 1 image is just an image). Removing such a collapsed dimension is referred to as squeezing, and
inserting one is known as unsqueezing.

<Warning>Some torch code, and some custom node authors, will return a squeezed tensor when a dimension is collapsed - such
as when a batch has only one member. This is a common cause of bugs!</Warning>

To represent the same data in a different shape is referred to as reshaping. This often requires you to know
the underlying data structure, so handle with care!

### Important notation

`torch.Tensor` supports most Python slice notation, iteration, and other common list-like operations. A tensor
also has a `.shape` attribute which returns its size as a `torch.Size` (which is a subclass of `tuple` and can
be treated as such).

There are some other important bits of notation you'll often see (several of these are less common
standard Python notation, seen much more frequently when dealing with tensors)

* `torch.Tensor` supports the use of `None` in slice notation
  to indicate the insertion of a dimension of size 1.

* `:` is frequently used when slicing a tensor; this simply means 'keep the whole dimension'.
  It's like using `a[start:end]` in Python, but omitting the start point and end point.

* `...` represents 'the whole of an unspecified number of dimensions'. So `a[0, ...]` would extract the first
  item from a batch regardless of the number of dimensions.

* in methods which require a shape to be passed, it is often passed as a `tuple` of the dimensions, in
  which a single dimension can be given the size `-1`, indicating that the size of this dimension should
  be calculated based on the total size of the data.

```python  theme={null}
>>> a = torch.Tensor((1,2))
>>> a.shape
torch.Size([2])
>>> a[:,None].shape 
torch.Size([2, 1])
>>> a.reshape((1,-1)).shape
torch.Size([1, 2])
```

### Elementwise operations

Many binary on `torch.Tensor` (including '+', '-', '\*', '/' and '==') are applied elementwise (independently applied to each element).
The operands must be *either* two tensors of the same shape, *or* a tensor and a scalar. So:

```python  theme={null}
>>> import torch
>>> a = torch.Tensor((1,2))
>>> b = torch.Tensor((3,2))
>>> a*b
tensor([3., 4.])
>>> a/b
tensor([0.3333, 1.0000])
>>> a==b
tensor([False,  True])
>>> a==1
tensor([ True, False])
>>> c = torch.Tensor((3,2,1)) 
>>> a==c
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: The size of tensor a (2) must match the size of tensor b (3) at non-singleton dimension 0
```

### Tensor truthiness

<Warning>The 'truthiness' value of a Tensor is not the same as that of Python lists.</Warning>

You may be familiar with the truthy value of a Python list as `True` for any non-empty list, and `False` for `None` or `[]`.
By contrast A `torch.Tensor` (with more than one elements) does not have a defined truthy value. Instead you need to use
`.all()` or `.any()` to combine the elementwise truthiness:

```python  theme={null}
>>> a = torch.Tensor((1,2))
>>> print("yes" if a else "no")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: Boolean value of Tensor with more than one value is ambiguous
>>> a.all()
tensor(False)
>>> a.any()
tensor(True)
```

This also means that you need to use `if a is not None:` not `if a:` to determine if a tensor variable has been set.

# UI

# Javascript Extensions

## Extending the Comfy Client

Comfy can be modified through an extensions mechanism. To add an extension you need to:

* Export `WEB_DIRECTORY` from your Python module,
* Place one or more `.js` files into that directory,
* Use `app.registerExtension` to register your extension.

These three steps are below. Once you know how to add an extension, look
through the [hooks](/custom-nodes/js/javascript_hooks) available to get your code called,
a description of various [Comfy objects](/custom-nodes/js/javascript_objects_and_hijacking) you might need,
or jump straight to some [example code snippets](/custom-nodes/js/javascript_examples).

### Exporting `WEB_DIRECTORY`

The Comfy web client can be extended by creating a subdirectory in your custom node directory, conventionally called `js`, and
exporting `WEB_DIRECTORY` - so your `__init_.py` will include something like:

```python  theme={null}
WEB_DIRECTORY = "./js"
__all__ = ["NODE_CLASS_MAPPINGS", "NODE_DISPLAY_NAME_MAPPINGS", "WEB_DIRECTORY"]
```

### Including `.js` files

<Tip>All Javascript `.js` files will be loaded by the browser as the Comfy webpage loads. You don't need to specify the file
your extension is in.</Tip>

*Only* `.js` files will be added to the webpage. Other resources (such as `.css` files) can be accessed
at `extensions/custom_node_subfolder/the_file.css` and added programmatically.

<Warning>That path does *not* include the name of the subfolder. The value of `WEB_DIRECTORY` is inserted by the server.</Warning>

### Registering an extension

The basic structure of an extension follows is to import the main Comfy `app` object, and call `app.registerExtension`,
passing a dictionary that contains a unique `name`,
and one or more functions to be called by hooks in the Comfy code.

A complete, trivial, and annoying, extension might look like this:

```Javascript  theme={null}
import { app } from "../../scripts/app.js";
app.registerExtension({ 
	name: "a.unique.name.for.a.useless.extension",
	async setup() { 
		alert("Setup complete!")
	},
})
```
# Comfy Hooks

## Extension hooks

At various points during Comfy execution, the application calls
`#invokeExtensionsAsync` or `#invokeExtensions` with the name of a hook.
These invoke, on all registered extensions, the appropriately named method (if present), such as `setup`
in the example above.

Comfy provides a variety of hooks for custom extension code to use to modify client behavior.

<Tip>These hooks are called during creation and modification of the Comfy client side elements.
<br />Events during workflow execution are handled by
the `apiUpdateHandlers`</Tip> {/* TODO link when written */}

A few of the most significant hooks are described below.
As Comfy is being actively developed, from time to time additional hooks are added, so
search for `#invokeExtensions` in `app.js` to find all available hooks.

See also the [sequence](#call-sequences) in which hooks are invoked.

### Commonly used hooks

Start with `beforeRegisterNodeDef`, which is used by the majority of extensions, and is often the only one needed.

#### beforeRegisterNodeDef()

Called once for each node type (the list of nodes available in the `AddNode` menu), and is used to
modify the behaviour of the node.

```Javascript  theme={null}
async beforeRegisterNodeDef(nodeType, nodeData, app) 
```

The object passed in the `nodeType` parameter essentially serves as a template
for all nodes that will be created of this type, so modifications made to `nodeType.prototype` will apply
to all nodes of this type. `nodeData` is an encapsulation of aspects of the node defined in the Python code,
such as its category, inputs, and outputs. `app` is a reference to the main Comfy app object (which you
have already imported anyway!)

<Tip>This method is called, on each registered extension, for *every* node type, not just the ones added by that extension.</Tip>

The usual idiom is to check `nodeType.ComfyClass`, which holds the Python class name corresponding to this node,
to see if you need to modify the node. Often this means modifying the custom nodes that you have added,
although you may sometimes need to modify the behavior of other nodes (or other custom nodes
might modify yours!), in which case care should be taken to ensure interoperability.

<Tip>Since other extensions may also modify nodes, aim to write code that makes as few assumptions as possible.
And play nicely - isolate your changes wherever possible.</Tip>

A very common idiom in `beforeRegisterNodeDef` is to 'hijack' an existing method:

<Note>
  **Deprecated:** The prototype hijacking pattern shown below is deprecated and subject to change at any point in the near future. For context menus, use the official [Context Menu API](/custom-nodes/js/context-menu-migration) instead. For other use cases, prefer using the official [extension hooks](/custom-nodes/js/javascript_hooks) where available.
</Note>

```Javascript  theme={null}
async beforeRegisterNodeDef(nodeType, nodeData, app) {
	if (nodeType.comfyClass=="MyNodeClass") { 
		const onConnectionsChange = nodeType.prototype.onConnectionsChange;
		nodeType.prototype.onConnectionsChange = function (side,slot,connect,link_info,output) {     
			const r = onConnectionsChange?.apply(this, arguments);   
			console.log("Someone changed my connection!");
			return r;
		}
	}
}
```

In this idiom the existing prototype method is stored, and then replaced. The replacement calls the
original method (the `?.apply` ensures that if there wasn't one this is still safe) and then
performs additional operations. Depending on your code logic, you may need to place the `apply` elsewhere in your replacement code,
or even make calling it conditional.

When hijacking a method in this way, you will want to look at the core comfy code (breakpoints are your friend) to check
and conform with the method signature.

<Warning>This approach is fragile and may break with future ComfyUI updates. Use official APIs whenever possible.</Warning>

#### nodeCreated()

```Javascript  theme={null}
async nodeCreated(node)
```

Called when a specific instance of a node gets created
(right at the end of the `ComfyNode()` function on `nodeType` which serves as a constructor).
In this hook you can make modifications to individual instances of your node.

<Tip>Changes that apply to all instances are better added to the prototype in `beforeRegisterNodeDef` as described above.</Tip>

#### init()

```Javascript  theme={null}
async init()
```

Called when the Comfy webpage is loaded (or reloaded). The call is made after the graph object has been created, but before any
nodes are registered or created. It can be used to modify core Comfy behavior by hijacking methods of the app, or of the
graph (a `LiteGraph` object). This is discussed further in [Comfy Objects](./javascript_objects_and_hijacking).

<Warning>With great power comes great responsibility. Hijacking core behavior makes it more likely your nodes
will be incompatible with other custom nodes, or future Comfy updates</Warning>

#### setup()

```Javascript  theme={null}
async setup()
```

Called at the end of the startup process. A good place to add event listeners (either for Comfy events, or DOM events),
or adding to the global menus, both of which are discussed elsewhere. {/* TODO link when written */}

<Tip>To do something when a workflow has loaded, use `afterConfigureGraph`, not `setup`</Tip>

### Call sequences

These sequences were obtained by insert logging code into the Comfy `app.js` file. You may find similar code helpful
in understanding the execution flow.

```Javascript  theme={null}
/* approx line 220 at time of writing: */
	#invokeExtensions(method, ...args) {
		console.log(`invokeExtensions      ${method}`) // this line added
		// ...
	}
/* approx line 250 at time of writing: */
	async #invokeExtensionsAsync(method, ...args) {
		console.log(`invokeExtensionsAsync ${method}`) // this line added
		// ...
	}
```

#### Web page load

```
invokeExtensionsAsync init
invokeExtensionsAsync addCustomNodeDefs
invokeExtensionsAsync getCustomWidgets
invokeExtensionsAsync beforeRegisterNodeDef    [repeated multiple times]
invokeExtensionsAsync registerCustomNodes
invokeExtensionsAsync beforeConfigureGraph
invokeExtensionsAsync nodeCreated
invokeExtensions      loadedGraphNode
invokeExtensionsAsync afterConfigureGraph
invokeExtensionsAsync setup
```

#### Loading workflow

```
invokeExtensionsAsync beforeConfigureGraph
invokeExtensionsAsync beforeRegisterNodeDef   [zero, one, or multiple times]
invokeExtensionsAsync nodeCreated             [repeated multiple times]
invokeExtensions      loadedGraphNode         [repeated multiple times]
invokeExtensionsAsync afterConfigureGraph
```

#### Adding new node

```
invokeExtensionsAsync nodeCreated
```

# Comfy Objects

## LiteGraph

The Comfy UI is built on top of [LiteGraph](https://github.com/jagenjo/litegraph.js).
Much of the Comfy functionality is provided by LiteGraph, so if developing more complex
nodes you will probably find it helpful to clone that repository and browse the documentation,
which can be found at `doc/index.html`.

## ComfyApp

The `app` object (always accessible by `import { app } from "../../scripts/app.js";`) represents the Comfy application running in the browser,
and contains a number of useful properties and functions, some of which are listed below.

<Note>
  **Deprecated:** Hijacking/monkey-patching functions on `app` or prototypes is deprecated and subject to change at any point in the near future. Use the official [extension hooks](/custom-nodes/js/javascript_hooks) and [Context Menu API](/custom-nodes/js/context-menu-migration) instead.
</Note>

<Warning>Hijacking functions on `app` is not recommended, as Comfy is under constant development, and core behavior may change.</Warning>

### Properties

Important properties of `app` include (this is not an exhaustive list):

| property        | contents                                                                                                                                                        |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `canvas`        | An LGraphCanvas object, representing the current user interface. It contains some potentially interesting properties, such as `node_over` and `selected_nodes`. |
| `canvasEl`      | The DOM `<canvas>` element                                                                                                                                      |
| `graph`         | A reference to the LGraph object describing the current graph                                                                                                   |
| `runningNodeId` | During execution, the node currently being executed                                                                                                             |
| `ui`            | Provides access to some UI elements, such as the queue, menu, and dialogs                                                                                       |

`canvas` (for graphical elements) and `graph` (for logical connections) are probably the ones you are most likely to want to access.

### Functions

Again, there are many. A few significant ones are:

| function          | notes                                                                 |
| ----------------- | --------------------------------------------------------------------- |
| graphToPrompt     | Convert the graph into a prompt that can be sent to the Python server |
| loadGraphData     | Load a graph                                                          |
| queuePrompt       | Submit a prompt to the queue                                          |
| registerExtension | You've seen this one - used to add an extension                       |

## LGraph

The `LGraph` object is part of the LiteGraph framework, and represents the current logical state of the graph (nodes and links).
If you want to manipulate the graph, the LiteGraph documentation (at `doc/index.html` if you clone `https://github.com/jagenjo/litegraph.js`)
describes the functions you will need.

You can use `graph` to obtain details of nodes and links, for example:

```Javascript  theme={null}
const ComfyNode_object_for_my_node = app.graph._nodes_by_id(my_node_id) 
ComfyNode_object_for_my_node.inputs.forEach(input => {
    const link_id = input.link;
    if (link_id) {
        const LLink_object = app.graph.links[link_id]
        const id_of_upstream_node = LLink_object.origin_id
        // etc
    }
});
```

## LLink

The `LLink` object, accessible through `graph.links`, represents a single link in the graph, from node `link.origin_id` output slot `link.origin_slot`
to node `link.target_id` slot `link.target_slot`. It also has a string representing the data type, in `link.type`, and `link.id`.

`LLink`s are created in the `connect` method of a `LGraphNode` (of which `ComfyNode` is a subclass).

<Tip>Avoid creating your own LLink objects - use the LiteGraph functions instead.</Tip>

## ComfyNode

`ComfyNode` is a subclass of `LGraphNode`, and the LiteGraph documentation is therefore helpful for more generic
operations. However, Comfy has significantly extended the LiteGraph core behavior, and also does not make
use of all LiteGraph functionality.

<Tip>The description that follows applies to a normal node.
Group nodes, primitive nodes, notes, and redirect nodes have different properties.</Tip>

A `ComfyNode` object represents a node in the current workflow. It has a number of important properties
that you may wish to make use of, a very large number of functions that you may wish to use, or hijack to
modify behavior.

<Note>
  **Deprecated:** Hijacking prototype methods on `ComfyNode` or `LGraphNode` is deprecated and subject to change at any point in the near future. Use the official [extension hooks](/custom-nodes/js/javascript_hooks) where available, such as `getNodeMenuItems` for context menus. See the [Context Menu Migration Guide](/custom-nodes/js/context-menu-migration) for examples.
</Note>

To get a more complete sense of the node object, you may find it helpful to insert the following
code into your extension and place a breakpoint on the `console.log` command. When you then create a new node
you can use your favorite debugger to interrogate the node.

```Javascript  theme={null}
async nodeCreated(node) {
    console.log("nodeCreated")
}
```

### Properties

| property          | contents                                                                                                                            |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `bgcolor`         | The background color of the node, or undefined for the default                                                                      |
| `comfyClass`      | The Python class representing the node                                                                                              |
| `flags`           | A dictionary that may contain flags related to the state of the node. In particular, `flags.collapsed` is true for collapsed nodes. |
| `graph`           | A reference to the LGraph object                                                                                                    |
| `id`              | A unique id                                                                                                                         |
| `input_type`      | A list of the input types (eg "STRING", "MODEL", "CLIP" etc). Generally matches the Python INPUT\_TYPES                             |
| `inputs`          | A list of inputs (discussed below)                                                                                                  |
| `mode`            | Normally 0, set to 2 if the node is muted and 4 if the node is bypassed. Values of 1 and 3 are not used by Comfy                    |
| `order`           | The node's position in the execution order. Set by `LGraph.computeExecutionOrder()` when the prompt is submitted                    |
| `pos`             | The \[x,y] position of the node on the canvas                                                                                       |
| `properties`      | A dictionary containing `"Node name for S&R"`, used by LiteGraph                                                                    |
| `properties_info` | The type and default value of entries in `properties`                                                                               |
| `size`            | The width and height of the node on the canvas                                                                                      |
| `title`           | Display Title                                                                                                                       |
| `type`            | The unique name (from Python) of the node class                                                                                     |
| `widgets`         | A list of widgets (discussed below)                                                                                                 |
| `widgets_values`  | A list of the current values of widgets                                                                                             |

### Functions

There are a very large number of functions (85, last time I counted). A selection are listed below.
Most of these functions are unmodified from the LiteGraph core code.

#### Inputs, Outputs, Widgets

| function               | notes                                                                                              |
| ---------------------- | -------------------------------------------------------------------------------------------------- |
| Inputs / Outputs       | Most have output methods with the equivalent names: s/In/Out/                                      |
| `addInput`             | Create a new input, defined by name and type                                                       |
| `addInputs`            | Array version of `addInput`                                                                        |
| `findInputSlot`        | Find the slot index from the input name                                                            |
| `findInputSlotByType`  | Find an input matching the type. Options to prefer, or only use, free slots                        |
| `removeInput`          | By slot index                                                                                      |
| `getInputNode`         | Get the node connected to this input. The output equivalent is `getOutputNodes` and returns a list |
| `getInputLink`         | Get the LLink connected to this input. No output equivalent                                        |
| Widgets                |                                                                                                    |
| `addWidget`            | Add a standard Comfy widget                                                                        |
| `addCustomWidget`      | Add a custom widget (defined in the `getComfyWidgets` hook)                                        |
| `addDOMWidget`         | Add a widget defined by a DOM element                                                              |
| `convertWidgetToInput` | Convert a widget to an input if allowed by `isConvertableWidget` (in `widgetInputs.js`)            |

#### Connections

| function              | notes                                                                                             |
| --------------------- | ------------------------------------------------------------------------------------------------- |
| `connect`             | Connect this node's output to another node's input                                                |
| `connectByType`       | Connect output to another node by specifying the type - connects to first available matching slot |
| `connectByTypeOutput` | Connect input to another node output by type                                                      |
| `disconnectInput`     | Remove any link into the input (specified by name or index)                                       |
| `disconnectOutput`    | Disconnect an output from a specified node's input                                                |
| `onConnectionChange`  | Called on each node. `side==1` if it's an input on this node                                      |
| `onConnectInput`      | Called *before* a connection is made. If this returns `false`, the connection is refused          |

#### Display

| function           | notes                                                                                                  |
| ------------------ | ------------------------------------------------------------------------------------------------------ |
| `setDirtyCanvas`   | Specify that the foreground (nodes) and/or background (links and images) need to be redrawn            |
| `onDrawBackground` | Called with a `CanvasRenderingContext2D` object to draw the background. Used by Comfy to render images |
| `onDrawForeground` | Called with a `CanvasRenderingContext2D` object to draw the node.                                      |
| `getTitle`         | The title to be displayed.                                                                             |
| `collapse`         | Toggles the collapsed state of the node.                                                               |

<Warning>`collapse` is badly named; it *toggles* the collapsed state.
It takes a boolean parameter, which can be used to override
`node.collapsable === false`.</Warning>

#### Other

| function     | notes                                                              |
| ------------ | ------------------------------------------------------------------ |
| `changeMode` | Use to set the node to bypassed (`mode == 4`) or not (`mode == 0`) |

## Inputs and Widgets

Inputs and Widgets represent the two ways that data can be fed into a node. In general a widget can be
converted to an input, but not all inputs can be converted to a widget (as many datatypes can't be
entered through a UI element).

`node.inputs` is a list of the current inputs (colored dots on the left hand side of the node),
specifying their `.name`, `.type`, and `.link` (a reference to the connected `LLink` in `app.graph.links`).

If an input is a widget which has been converted, it also holds a reference to the, now inactive, widget in `.widget`.

`node.widgets` is a list of all widgets, whether or not they have been converted to an input. A widget has:

| property/function | notes                                                                     |
| ----------------- | ------------------------------------------------------------------------- |
| `callback`        | A function called when the widget value is changed                        |
| `last_y`          | The vertical position of the widget in the node                           |
| `name`            | The (unique within a node) widget name                                    |
| `options`         | As specified in the Python code (such as default, min, and max)           |
| `type`            | The name of the widget type (see below) in lowercase                      |
| `value`           | The current widget value. This is a property with `get` and `set` methods |

### Widget Types

`app.widgets` is a dictionary of currently registered widget types, keyed in the UPPER CASE version of the name of the type.
Build in Comfy widgets types include the self explanatory `BOOLEAN`, `INT`, and `FLOAT`,
as well as `STRING` (which comes in two flavours, single line and multiline),
`COMBO` for dropdown selection from a list, and `IMAGEUPLOAD`, used in Load Image nodes.

Custom widget types can be added by providing a `getCustomWidgets` method in your extension.

### Linked widgets

Widgets can also be linked - the built in behavior of `seed` and `control_after_generate`, for example.
A linked widget has `.type = 'base_widget_type:base_widget_name'`; so `control_after_generate` may have
type `int:seed`.

## Prompt

When you press the `Queue Prompt` button in Comfy, the `app.graphToPrompt()` method is called to convert the
current graph into a prompt that can be sent to the server.

`app.graphToPrompt` returns an object (referred to herein as `prompt`) with two properties, `output` and `workflow`.

### output

`prompt.output` maps from the `node_id` of each node in the graph to an object with two properties.

* `prompt.output[node_id].class_type`, the unique name of the custom node class, as defined in the Python code
* `prompt.output[node_id].inputs`, which contains the value of each input (or widget) as a map from the input name to:
  * the selected value, if it is a widget, or
  * an array containing (`upstream_node_id`, `upstream_node_output_slot`) if there is a link connected to the input, or
  * undefined, if it is a widget that has been converted to an input and is not connected
  * other unconnected inputs are not included in `.inputs`

<Tip>Note that the `upstream_node_id` in the array describing a connected input is represented as a string, not an integer.</Tip>

### workflow

`prompt.workflow` contains the following properties:

* `config` - a dictionary of additional configuration options (empty by default)
* `extra` - a dictionary containing extra information about the workflow. By default it contains:
  * `extra.ds` - describes the current view of the graph (`scale` and `offset`)
* `groups` - all groups in the workflow
* `last_link_id` - the id of the last link added
* `last_node_id` - the id of the last node added
* `links` - a list of all links in the graph. Each entry is an array of five integers and one string:
  * (`link_id`, `upstream_node_id`, `upstream_node_output_slot`, `downstream_node_id`, `downstream_node_input_slot`, `data type`)
* `nodes` - a list of all nodes in the graph. Each entry is a map of a subset of the properties of the node as described [above](#comfynode)
  * The following properties are included: `flags`, `id`, `inputs`, `mode`, `order`, `pos`, `properties`, `size`, `type`, `widgets_values`
  * In addition, unless a node has no outputs, there is an `outputs` property, which is a list of the outputs of the node, each of which contains:
    * `name` - the name of the output
    * `type` - the data type of the output
    * `links` - a list of the `link_id` of all links from this output (if there are no connections, may be an empty list, or null),
    * `shape` - the shape used to draw the output (default 3 for a dot)
    * `slot_index` - the slot number of the output
* `version` - the LiteGraph version number (at time of writing, `0.4`)

<Tip>`nodes.output` is absent for nodes with no outputs, not an empty list.</Tip>

# Settings

You can provide a settings object to ComfyUI that will show up when the user
opens the ComfyUI settings panel.

## Basic operation

### Add a setting

```javascript  theme={null}
import { app } from "../../scripts/app.js";

app.registerExtension({
    name: "My Extension",
    settings: [
        {
            id: "example.boolean",
            name: "Example boolean setting",
            type: "boolean",
            defaultValue: false,
        },
    ],
});
```

The `id` must be unique across all extensions and will be used to fetch values.

If you do not [provide a category](#categories), then the `id` will be split by
`.` to determine where it appears in the settings panel.

* If your `id` doesn't contain any `.` then it will appear in the "Other"
  category and your `id` will be used as the section heading.
* If your `id` contains at least one `.` then the leftmost part will be used
  as the setting category and the second part will be used as the section
  heading. Any further parts are ignored.

### Read a setting

```javascript  theme={null}
import { app } from "../../scripts/app.js";

if (app.extensionManager.setting.get('example.boolean')) {
    console.log("Setting is enabled.");
} else {
    console.log("Setting is disabled.");
}
```

### React to changes

The `onChange()` event handler will be called as soon as the user changes the
setting in the settings panel.

This will also be called when the extension is registered, on every page load.

```javascript  theme={null}
{
    id: "example.boolean",
    name: "Example boolean setting",
    type: "boolean",
    defaultValue: false,
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Write a setting

```javascript  theme={null}
import { app } from "../../scripts/app.js";

try {
    await app.extensionManager.setting.set("example.boolean", true);
} catch (error) {
    console.error(`Error changing setting: ${error}`);
}
```

### Extra configuration

The setting types are based on [PrimeVue](https://primevue.org/) components.
Props described in the PrimeVue documentation can be defined for ComfyUI
settings by adding them in an `attrs` field.

For instance, this adds increment/decrement buttons to a number input:

```javascript  theme={null}
{
    id: "example.number",
    name: "Example number setting",
    type: "number",
    defaultValue: 0,
    attrs: {
        showButtons: true,
    },
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

## Types

### Boolean

This shows an on/off toggle.

Based on the [ToggleSwitch PrimeVue
component](https://primevue.org/toggleswitch/).

```javascript  theme={null}
{
    id: "example.boolean",
    name: "Example boolean setting",
    type: "boolean",
    defaultValue: false,
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Text

This is freeform text.

Based on the [InputText PrimeVue component](https://primevue.org/inputtext/).

```javascript  theme={null}
{
    id: "example.text",
    name: "Example text setting",
    type: "text",
    defaultValue: "Foo",
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Number

This for entering numbers.

To allow decimal places, set the `maxFractionDigits` attribute to a number greater than zero.

Based on the [InputNumber PrimeVue
component](https://primevue.org/inputnumber/).

```javascript  theme={null}
{
    id: "example.number",
    name: "Example number setting",
    type: "number",
    defaultValue: 42,
    attrs: {
        showButtons: true,
        maxFractionDigits: 1,
    },
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Slider

This lets the user enter a number directly or via a slider.

Based on the [Slider PrimeVue component](https://primevue.org/slider/). Ranges
are not supported.

```javascript  theme={null}
{
    id: "example.slider",
    name: "Example slider setting",
    type: "slider",
    attrs: {
        min: -10,
        max: 10,
        step: 0.5,
    },
    defaultValue: 0,
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Combo

This lets the user pick from a drop-down list of values.

You can provide options either as a plain string or as an object with `text`
and `value` fields. If you only provide a plain string, then it will be used
for both.

You can let the user enter freeform text by supplying the `editable: true`
attribute, or search by supplying the `filter: true` attribute.

Based on the [Select PrimeVue component](https://primevue.org/select/). Groups
are not supported.

```javascript  theme={null}
{
    id: "example.combo",
    name: "Example combo setting",
    type: "combo",
    defaultValue: "first",
    options: [
        { text: "My first option", value: "first" },
        "My second option",
    ],
    attrs: {
        editable: true,
        filter: true,
    },
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Color

This lets the user select a color from a color picker or type in a hex
reference.

Note that the format requires six full hex digits - three digit shorthand does
not work.

Based on the [ColorPicker PrimeVue
component](https://primevue.org/colorpicker/).

```javascript  theme={null}
{
    id: "example.color",
    name: "Example color setting",
    type: "color",
    defaultValue: "ff0000",
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Image

This lets the user upload an image.

The setting will be saved as a [data
URL](https://developer.mozilla.org/en-US/docs/Web/URI/Schemes/data).

Based on the [FileUpload PrimeVue
component](https://primevue.org/fileupload/).

```javascript  theme={null}
{
    id: "example.image",
    name: "Example image setting",
    type: "image",
    onChange: (newVal, oldVal) => {
        console.log(`Setting was changed from ${oldVal} to ${newVal}`);
    },
}
```

### Hidden

Hidden settings aren't displayed in the settings panel, but you can read and
write to them from your code.

```javascript  theme={null}
{
    id: "example.hidden",
    name: "Example hidden setting",
    type: "hidden",
}
```

## Other

### Categories

You can specify the categorisation of your setting separately to the `id`.
This means you can change the categorisation and naming without changing the
`id` and losing the values that have already been set by users.

```javascript  theme={null}
{
    id: "example.boolean",
    name: "Example boolean setting",
    type: "boolean",
    defaultValue: false,
````
Assistant

ðŸ› ï¸ read_file (call_MHxxYTBLWnFXRVBtM0RtN1lnbnM) {
  "endLine": 3600,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\COMFYUI_RAW_DOCS.md",
  "startLine": 2401
}
Tool
ðŸ› ï¸ call_MHxxYTBLWnFXRVBtM0RtN1lnbnM
File: `c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md`. Lines 2401 to 3600 (4378 lines total): 
````markdown
    category: ["Category name", "Section heading", "Setting label"],
}
```

### Tooltips

You can add extra contextual help with the `tooltip` field. This adds a small â„¹ï¸Ž
icon after the field name that will show the help text when the user hovers
over it.

```javascript  theme={null}
{
    id: "example.boolean",
    name: "Example boolean setting",
    type: "boolean",
    defaultValue: false,
    tooltip: "This is some helpful information",
}
```

# Dialog API

The Dialog API provides standardized dialogs that work consistently across desktop and web environments. Extension authors will find the prompt and confirm methods most useful.

## Basic Usage

### Prompt Dialog

```javascript  theme={null}
// Show a prompt dialog
app.extensionManager.dialog.prompt({
  title: "User Input",
  message: "Please enter your name:",
  defaultValue: "User"
}).then(result => {
  if (result !== null) {
    console.log(`Input: ${result}`);
  }
});
```

### Confirm Dialog

```javascript  theme={null}
// Show a confirmation dialog
app.extensionManager.dialog.confirm({
  title: "Confirm Action",
  message: "Are you sure you want to continue?",
  type: "default"
}).then(result => {
  console.log(result ? "User confirmed" : "User cancelled");
});
```

## API Reference

### Prompt

```javascript  theme={null}
app.extensionManager.dialog.prompt({
  title: string,             // Dialog title
  message: string,           // Message/question to display
  defaultValue?: string      // Initial value in the input field (optional)
}).then((result: string | null) => {
  // result is the entered text, or null if cancelled
});
```

### Confirm

```javascript  theme={null}
app.extensionManager.dialog.confirm({
  title: string,             // Dialog title
  message: string,           // Message to display
  type?: "default" | "overwrite" | "delete" | "dirtyClose" | "reinstall", // Dialog type (optional)
  itemList?: string[],       // List of items to display (optional)
  hint?: string              // Hint text to display (optional)
}).then((result: boolean | null) => {
  // result is true if confirmed, false if denied, null if cancelled
});
```

For other specialized dialogs available in ComfyUI, extension authors can refer to the `dialogService.ts` file in the source code.

# Toast API

The Toast API provides a way to display non-blocking notification messages to users. These are useful for providing feedback without interrupting workflow.

## Basic Usage

### Simple Toast

```javascript  theme={null}
// Display a simple info toast
app.extensionManager.toast.add({
  severity: "info",
  summary: "Information",
  detail: "Operation completed successfully",
  life: 3000
});
```

### Toast Types

```javascript  theme={null}
// Success toast
app.extensionManager.toast.add({
  severity: "success",
  summary: "Success",
  detail: "Data saved successfully",
  life: 3000
});

// Warning toast
app.extensionManager.toast.add({
  severity: "warn",
  summary: "Warning",
  detail: "This action may cause problems",
  life: 5000
});

// Error toast
app.extensionManager.toast.add({
  severity: "error",
  summary: "Error",
  detail: "Failed to process request",
  life: 5000
});
```

### Alert Helper

```javascript  theme={null}
// Shorthand for creating an alert toast
app.extensionManager.toast.addAlert("This is an important message");
```

## API Reference

### Toast Message

```javascript  theme={null}
app.extensionManager.toast.add({
  severity?: "success" | "info" | "warn" | "error" | "secondary" | "contrast", // Message severity level (default: "info")
  summary?: string,         // Short title for the toast
  detail?: any,             // Detailed message content
  closable?: boolean,       // Whether user can close the toast (default: true)
  life?: number,            // Duration in milliseconds before auto-closing
  group?: string,           // Group identifier for managing related toasts
  styleClass?: any,         // Style class of the message
  contentStyleClass?: any   // Style class of the content
});
```

### Alert Helper

```javascript  theme={null}
app.extensionManager.toast.addAlert(message: string);
```

### Additional Methods

```javascript  theme={null}
// Remove a specific toast
app.extensionManager.toast.remove(toastMessage);

// Remove all toasts
app.extensionManager.toast.removeAll();
```

# About Panel Badges

The About Panel Badges API allows extensions to add custom badges to the ComfyUI about page. These badges can display information about your extension and contain links to documentation, source code, or other resources.

## Basic Usage

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  aboutPageBadges: [
    {
      label: "Documentation",
      url: "https://example.com/docs",
      icon: "pi pi-file"
    },
    {
      label: "GitHub",
      url: "https://github.com/username/repo",
      icon: "pi pi-github"
    }
  ]
});
```

## Badge Configuration

Each badge requires all of these properties:

```javascript  theme={null}
{
  label: string,           // Text to display on the badge
  url: string,             // URL to open when badge is clicked
  icon: string             // Icon class (e.g., PrimeVue icon)
}
```

## Icon Options

Badge icons use PrimeVue's icon set. Here are some commonly used icons:

* Documentation: `pi pi-file` or `pi pi-book`
* GitHub: `pi pi-github`
* External link: `pi pi-external-link`
* Information: `pi pi-info-circle`
* Download: `pi pi-download`
* Website: `pi pi-globe`
* Discord: `pi pi-discord`

For a complete list of available icons, refer to the [PrimeVue Icons documentation](https://primevue.org/icons/).

## Example

```javascript  theme={null}
app.registerExtension({
  name: "BadgeExample",
  aboutPageBadges: [
    {
      label: "Website",
      url: "https://example.com",
      icon: "pi pi-home"
    },
    {
      label: "Donate",
      url: "https://example.com/donate",
      icon: "pi pi-heart"
    },
    {
      label: "Documentation",
      url: "https://example.com/docs",
      icon: "pi pi-book"
    }
  ]
});
```

Badges appear in the About panel of the Settings dialog, which can be accessed via the gear icon in the top-right corner of the ComfyUI interface.

# Bottom Panel Tabs

The Bottom Panel Tabs API allows extensions to add custom tabs to the bottom panel of the ComfyUI interface. This is useful for adding features like logs, debugging tools, or custom panels.

## Basic Usage

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  bottomPanelTabs: [
    {
      id: "customTab",
      title: "Custom Tab",
      type: "custom",
      render: (el) => {
        el.innerHTML = '<div>This is my custom tab content</div>';
      }
    }
  ]
});
```

## Tab Configuration

Each tab requires an `id`, `title`, and `type`, along with a render function:

```javascript  theme={null}
{
  id: string,              // Unique identifier for the tab
  title: string,           // Display title shown on the tab
  type: string,            // Tab type (usually "custom")
  icon?: string,           // Icon class (optional)
  render: (element) => void // Function that populates the tab content
}
```

The `render` function receives a DOM element where you should insert your tab's content.

## Interactive Elements

You can add interactive elements like buttons:

```javascript  theme={null}
app.registerExtension({
  name: "InteractiveTabExample",
  bottomPanelTabs: [
    {
      id: "controlsTab",
      title: "Controls",
      type: "custom",
      render: (el) => {
        el.innerHTML = `
          <div style="padding: 10px;">
            <button id="runBtn">Run Workflow</button>
          </div>
        `;
        
        // Add event listeners
        el.querySelector('#runBtn').addEventListener('click', () => {
          app.queuePrompt();
        });
      }
    }
  ]
});
```

## Using React Components

You can mount React components in bottom panel tabs:

```javascript  theme={null}
// Import React dependencies in your extension
import React from "react";
import ReactDOM from "react-dom/client";

// Simple React component
function TabContent() {
  const [count, setCount] = React.useState(0);
  
  return (
    <div style={{ padding: "10px" }}>
      <h3>React Component</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// Register the extension with React content
app.registerExtension({
  name: "ReactTabExample",
  bottomPanelTabs: [
    {
      id: "reactTab",
      title: "React Tab",
      type: "custom",
      render: (el) => {
        const container = document.createElement("div");
        container.id = "react-tab-container";
        el.appendChild(container);
        
        // Mount React component
        ReactDOM.createRoot(container).render(
          <React.StrictMode>
            <TabContent />
          </React.StrictMode>
        );
      }
    }
  ]
});
```

## Standalone Registration

You can also register tabs outside of `registerExtension`:

```javascript  theme={null}
app.extensionManager.registerBottomPanelTab({
  id: "standAloneTab",
  title: "Stand-Alone Tab",
  type: "custom",
  render: (el) => {
    el.innerHTML = '<div>This tab was registered independently</div>';
  }
});
```

# Sidebar Tabs

The Sidebar Tabs API allows extensions to add custom tabs to the sidebar of the ComfyUI interface. This is useful for adding features that require persistent visibility and quick access.

## Basic Usage

```javascript  theme={null}
app.extensionManager.registerSidebarTab({
  id: "customSidebar",
  icon: "pi pi-compass",
  title: "Custom Tab",
  tooltip: "My Custom Sidebar Tab",
  type: "custom",
  render: (el) => {
    el.innerHTML = '<div>This is my custom sidebar content</div>';
  }
});
```

## Tab Configuration

Each tab requires several properties:

```javascript  theme={null}
{
  id: string,              // Unique identifier for the tab
  icon: string,            // Icon class for the tab button
  title: string,           // Title text for the tab
  tooltip?: string,        // Tooltip text on hover (optional)
  type: string,            // Tab type (usually "custom")
  render: (element) => void // Function that populates the tab content
}
```

The `render` function receives a DOM element where you should insert your tab's content.

## Icon Options

Sidebar tab icons can use various icon sets:

* PrimeVue icons: `pi pi-[icon-name]` (e.g., `pi pi-home`)
* Material Design icons: `mdi mdi-[icon-name]` (e.g., `mdi mdi-robot`)
* Font Awesome icons: `fa-[style] fa-[icon-name]` (e.g., `fa-solid fa-star`)

Ensure the corresponding icon library is loaded before using these icons.

## Stateful Tab Example

You can create tabs that maintain state:

```javascript  theme={null}
app.extensionManager.registerSidebarTab({
  id: "statefulTab",
  icon: "pi pi-list",
  title: "Notes",
  type: "custom",
  render: (el) => {
    // Create elements
    const container = document.createElement('div');
    container.style.padding = '10px';
    
    const notepad = document.createElement('textarea');
    notepad.style.width = '100%';
    notepad.style.height = '200px';
    notepad.style.marginBottom = '10px';
    
    // Load saved content if available
    const savedContent = localStorage.getItem('comfyui-notes');
    if (savedContent) {
      notepad.value = savedContent;
    }
    
    // Auto-save content
    notepad.addEventListener('input', () => {
      localStorage.setItem('comfyui-notes', notepad.value);
    });
    
    // Assemble the UI
    container.appendChild(notepad);
    el.appendChild(container);
  }
});
```

## Using React Components

You can mount React components in sidebar tabs:

```javascript  theme={null}
// Import React dependencies in your extension
import React from "react";
import ReactDOM from "react-dom/client";

// Register sidebar tab with React content
app.extensionManager.registerSidebarTab({
  id: "reactSidebar",
  icon: "mdi mdi-react",
  title: "React Tab",
  type: "custom",
  render: (el) => {
    const container = document.createElement("div");
    container.id = "react-sidebar-container";
    el.appendChild(container);
    
    // Define a simple React component
    function SidebarContent() {
      const [count, setCount] = React.useState(0);
      
      return (
        <div style={{ padding: "10px" }}>
          <h3>React Sidebar</h3>
          <p>Count: {count}</p>
          <button onClick={() => setCount(count + 1)}>
            Increment
          </button>
        </div>
      );
    }
    
    // Mount React component
    ReactDOM.createRoot(container).render(
      <React.StrictMode>
        <SidebarContent />
      </React.StrictMode>
    );
  }
});
```

For a real-world example of a React application integrated as a sidebar tab, check out the [ComfyUI-Copilot project on GitHub](https://github.com/AIDC-AI/ComfyUI-Copilot).

## Dynamic Content Updates

You can update sidebar content in response to graph changes:

```javascript  theme={null}
app.extensionManager.registerSidebarTab({
  id: "dynamicSidebar",
  icon: "pi pi-chart-line",
  title: "Stats",
  type: "custom",
  render: (el) => {
    const container = document.createElement('div');
    container.style.padding = '10px';
    el.appendChild(container);
    
    // Function to update stats
    function updateStats() {
      const stats = {
        nodes: app.graph._nodes.length,
        connections: Object.keys(app.graph.links).length
      };
      
      container.innerHTML = `
        <h3>Workflow Stats</h3>
        <ul>
          <li>Nodes: ${stats.nodes}</li>
          <li>Connections: ${stats.connections}</li>
        </ul>
      `;
    }
    
    // Initial update
    updateStats();
    
    // Listen for graph changes
    const api = app.api;
    api.addEventListener("graphChanged", updateStats);
    
    // Clean up listeners when tab is destroyed
    return () => {
      api.removeEventListener("graphChanged", updateStats);
    };
  }
});
```

# Selection Toolbox

The Selection Toolbox API allows extensions to add custom action buttons that appear when nodes are selected on the canvas. This provides quick access to context-sensitive commands for selected items (nodes, groups, etc.).

## Basic Usage

To add commands to the selection toolbox, your extension needs to:

1. Define commands with the standard [command interface](https://docs.comfy.org/custom-nodes/js/javascript_commands_keybindings)
2. Implement the `getSelectionToolboxCommands` method to specify which commands appear in the toolbox

Note: The `getSelectionToolboxCommands` method is called for each item in the selection set whenever a new selection is made.

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  commands: [
    {
      id: "my-extension.duplicate-special",
      label: "Duplicate Special",
      icon: "pi pi-copy",
      function: (selectedItem) => {
        // Your command logic here
        console.log("Duplicating selected nodes with special behavior");
      }
    }
  ],
  getSelectionToolboxCommands: (selectedItem) => {
    // Return array of command IDs to show in the toolbox
    return ["my-extension.duplicate-special"];
  }
});
```

## Command Definition

Commands for the selection toolbox use the standard ComfyUI command interface:

```javascript  theme={null}
{
  id: string,          // Unique identifier for the command
  label: string,       // Display text for the button tooltip
  icon?: string,       // Icon class for the button (optional)
  function: (selectedItem) => void  // Function executed when clicked
}
```

The `function` receives the selected item(s) as a parameter, allowing you to perform actions on the current selection.

## Icon Options

Selection toolbox buttons support the same icon libraries as other UI elements:

* PrimeVue icons: `pi pi-[icon-name]` (e.g., `pi pi-star`)
* Material Design icons: `mdi mdi-[icon-name]` (e.g., `mdi mdi-content-copy`)

## Dynamic Command Visibility

The `getSelectionToolboxCommands` method is called each time the selection changes, allowing you to show different commands based on what's selected:

```javascript  theme={null}
app.registerExtension({
  name: "ContextualCommands",
  commands: [
    {
      id: "my-ext.align-nodes",
      label: "Align Nodes",
      icon: "pi pi-align-left",
      function: () => {
        // Align multiple nodes
      }
    },
    {
      id: "my-ext.configure-single",
      label: "Configure",
      icon: "pi pi-cog",
      function: () => {
        // Configure single node
      }
    }
  ],
  getSelectionToolboxCommands: (selectedItem) => {
    const selectedItems = app.canvas.selectedItems;
    const itemCount = selectedItems ? selectedItems.size : 0;
    
    if (itemCount > 1) {
      // Show alignment command for multiple items
      return ["my-ext.align-nodes"];
    } else if (itemCount === 1) {
      // Show configuration for single item
      return ["my-ext.configure-single"];
    }
    
    return [];
  }
});
```

## Working with Selected Items

Access information about selected items through the app's canvas object. The `selectedItems` property is a Set that includes nodes, groups, and other canvas elements:

```javascript  theme={null}
app.registerExtension({
  name: "SelectionInfo",
  commands: [
    {
      id: "my-ext.show-info",
      label: "Show Selection Info",
      icon: "pi pi-info-circle",
      function: () => {
        const selectedItems = app.canvas.selectedItems;
        
        if (selectedItems && selectedItems.size > 0) {
          console.log(`Selected ${selectedItems.size} items`);
          
          // Iterate through selected items
          selectedItems.forEach(item => {
            if (item.type) {
              console.log(`Item: ${item.type} (ID: ${item.id})`);
            }
          });
        }
      }
    }
  ],
  getSelectionToolboxCommands: () => ["my-ext.show-info"]
});
```

## Complete Example

Here's a simple example showing various selection toolbox features:

```javascript  theme={null}
app.registerExtension({
  name: "SelectionTools",
  commands: [
    {
      id: "selection-tools.count",
      label: "Count Selection",
      icon: "pi pi-hashtag",
      function: () => {
        const count = app.canvas.selectedItems?.size || 0;
        app.extensionManager.toast.add({
          severity: "info",
          summary: "Selection Count",
          detail: `You have ${count} item${count !== 1 ? 's' : ''} selected`,
          life: 3000
        });
      }
    },
    {
      id: "selection-tools.copy-ids",
      label: "Copy IDs",
      icon: "pi pi-copy",
      function: () => {
        const items = Array.from(app.canvas.selectedItems || []);
        const ids = items.map(item => item.id).filter(id => id !== undefined);
        
        if (ids.length > 0) {
          navigator.clipboard.writeText(ids.join(', '));
          app.extensionManager.toast.add({
            severity: "success",
            summary: "Copied",
            detail: `Copied ${ids.length} IDs to clipboard`,
            life: 2000
          });
        }
      }
    },
    {
      id: "selection-tools.log-types",
      label: "Log Types",
      icon: "pi pi-info-circle",
      function: () => {
        const items = Array.from(app.canvas.selectedItems || []);
        const typeCount = {};
        
        items.forEach(item => {
          const type = item.type || 'unknown';
          typeCount[type] = (typeCount[type] || 0) + 1;
        });
        
        console.log("Selection types:", typeCount);
      }
    }
  ],
  
  getSelectionToolboxCommands: (selectedItem) => {
    const selectedItems = app.canvas.selectedItems;
    const itemCount = selectedItems ? selectedItems.size : 0;
    
    if (itemCount === 0) return [];
    
    const commands = ["selection-tools.count", "selection-tools.log-types"];
    
    // Only show copy command if items have IDs
    const hasIds = Array.from(selectedItems).some(item => item.id !== undefined);
    if (hasIds) {
      commands.push("selection-tools.copy-ids");
    }
    
    return commands;
  }
});
```

## Notes

* The selection toolbox must be enabled in settings: `Comfy.Canvas.SelectionToolbox`
* Commands must be defined in the `commands` array before being referenced in `getSelectionToolboxCommands`
* The toolbox automatically updates when the selection changes
* The `getSelectionToolboxCommands` method is called for each item in the selection set whenever a new selection is made
* Use `app.canvas.selectedItems` (a Set) to access all selected items including nodes, groups, and other canvas elements
* For backward compatibility, `app.canvas.selected_nodes` still exists but only contains nodes

# Commands and Keybindings

The Commands and Keybindings API allows extensions to register custom commands and associate them with keyboard shortcuts. This enables users to quickly trigger actions without using the mouse.

## Basic Usage

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  // Register commands
  commands: [
    {
      id: "myCommand",
      label: "My Command",
      function: () => {
        console.log("Command executed!");
      }
    }
  ],
  // Associate keybindings with commands
  keybindings: [
    {
      combo: { key: "k", ctrl: true },
      commandId: "myCommand"
    }
  ]
});
```

## Command Configuration

Each command requires an `id`, `label`, and `function`:

```javascript  theme={null}
{
  id: string,              // Unique identifier for the command
  label: string,           // Display name for the command
  function: () => void     // Function to execute when command is triggered
}
```

## Keybinding Configuration

Each keybinding requires a `combo` and `commandId`:

```javascript  theme={null}
{
  combo: {                 // Key combination
    key: string,           // The main key (single character or special key)
    ctrl?: boolean,        // Require Ctrl key (optional)
    shift?: boolean,       // Require Shift key (optional)
    alt?: boolean,         // Require Alt key (optional)
    meta?: boolean         // Require Meta/Command key (optional)
  },
  commandId: string        // ID of the command to trigger
}
```

### Special Keys

For non-character keys, use one of these values:

* Arrow keys: `"ArrowUp"`, `"ArrowDown"`, `"ArrowLeft"`, `"ArrowRight"`
* Function keys: `"F1"` through `"F12"`
* Other special keys: `"Escape"`, `"Tab"`, `"Enter"`, `"Backspace"`, `"Delete"`, `"Home"`, `"End"`, `"PageUp"`, `"PageDown"`

## Command Examples

```javascript  theme={null}
app.registerExtension({
  name: "CommandExamples",
  commands: [
    {
      id: "runWorkflow",
      label: "Run Workflow",
      function: () => {
        app.queuePrompt();
      }
    },
    {
      id: "clearWorkflow",
      label: "Clear Workflow",
      function: () => {
        if (confirm("Clear the workflow?")) {
          app.graph.clear();
        }
      }
    },
    {
      id: "saveWorkflow",
      label: "Save Workflow",
      function: () => {
        app.graphToPrompt().then(workflow => {
          const blob = new Blob([JSON.stringify(workflow)], {type: "application/json"});
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "workflow.json";
          a.click();
          URL.revokeObjectURL(url);
        });
      }
    }
  ]
});
```

## Keybinding Examples

```javascript  theme={null}
app.registerExtension({
  name: "KeybindingExamples",
  commands: [
    /* Commands defined above */
  ],
  keybindings: [
    // Ctrl+R to run workflow
    {
      combo: { key: "r", ctrl: true },
      commandId: "runWorkflow"
    },
    // Ctrl+Shift+C to clear workflow
    {
      combo: { key: "c", ctrl: true, shift: true },
      commandId: "clearWorkflow"
    },
    // Ctrl+S to save workflow
    {
      combo: { key: "s", ctrl: true },
      commandId: "saveWorkflow"
    },
    // F5 to run workflow (alternative)
    {
      combo: { key: "F5" },
      commandId: "runWorkflow"
    }
  ]
});
```

## Notes and Limitations

* Keybindings defined in the ComfyUI core cannot be overwritten by extensions. Check the core keybindings in these source files:
  * [Core Commands](https://github.com/Comfy-Org/ComfyUI_frontend/blob/e76e9ec61a068fd2d89797762f08ee551e6d84a0/src/composables/useCoreCommands.ts)
  * [Core Menu Commands](https://github.com/Comfy-Org/ComfyUI_frontend/blob/e76e9ec61a068fd2d89797762f08ee551e6d84a0/src/constants/coreMenuCommands.ts)
  * [Core Keybindings](https://github.com/Comfy-Org/ComfyUI_frontend/blob/e76e9ec61a068fd2d89797762f08ee551e6d84a0/src/constants/coreKeybindings.ts)
  * [Reserved Key Combos](https://github.com/Comfy-Org/ComfyUI_frontend/blob/e76e9ec61a068fd2d89797762f08ee551e6d84a0/src/constants/reservedKeyCombos.ts)

* Some key combinations are reserved by the browser (like Ctrl+F for search) and cannot be overridden

* If multiple extensions register the same keybinding, the behavior is undefined

# Topbar Menu

The Topbar Menu API allows extensions to add custom menu items to the ComfyUI's top menu bar. This is useful for providing access to advanced features or less frequently used commands.

## Basic Usage

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  // Define commands
  commands: [
    { 
      id: "myCommand", 
      label: "My Command", 
      function: () => { alert("Command executed!"); } 
    }
  ],
  // Add commands to menu
  menuCommands: [
    { 
      path: ["Extensions", "My Extension"], 
      commands: ["myCommand"] 
    }
  ]
});
```

Command definitions follow the same pattern as in the [Commands and Keybindings API](./javascript_commands_keybindings). See that page for more detailed information about defining commands.

## Command Configuration

Each command requires an `id`, `label`, and `function`:

```javascript  theme={null}
{
  id: string,              // Unique identifier for the command
  label: string,           // Display name for the command
  function: () => void     // Function to execute when command is triggered
}
```

## Menu Configuration

The `menuCommands` array defines where to place commands in the menu structure:

```javascript  theme={null}
{
  path: string[],          // Array representing menu hierarchy
  commands: string[]       // Array of command IDs to add at this location
}
```

The `path` array specifies the menu hierarchy. For example, `["File", "Export"]` would add commands to the "Export" submenu under the "File" menu.

## Menu Examples

### Adding to Existing Menus

```javascript  theme={null}
app.registerExtension({
  name: "MenuExamples",
  commands: [
    { 
      id: "saveAsImage", 
      label: "Save as Image", 
      function: () => { 
        // Code to save canvas as image
      } 
    },
    { 
      id: "exportWorkflow", 
      label: "Export Workflow", 
      function: () => { 
        // Code to export workflow
      } 
    }
  ],
  menuCommands: [
    // Add to File menu
    { 
      path: ["File"], 
      commands: ["saveAsImage", "exportWorkflow"] 
    }
  ]
});
```

### Creating Submenu Structure

```javascript  theme={null}
app.registerExtension({
  name: "SubmenuExample",
  commands: [
    { 
      id: "option1", 
      label: "Option 1", 
      function: () => { console.log("Option 1"); } 
    },
    { 
      id: "option2", 
      label: "Option 2", 
      function: () => { console.log("Option 2"); } 
    },
    { 
      id: "suboption1", 
      label: "Sub-option 1", 
      function: () => { console.log("Sub-option 1"); } 
    }
  ],
  menuCommands: [
    // Create a nested menu structure
    { 
      path: ["Extensions", "My Tools"], 
      commands: ["option1", "option2"] 
    },
    { 
      path: ["Extensions", "My Tools", "Advanced"], 
      commands: ["suboption1"] 
    }
  ]
});
```

### Multiple Menu Locations

You can add the same command to multiple menu locations:

```javascript  theme={null}
app.registerExtension({
  name: "MultiLocationExample",
  commands: [
    { 
      id: "helpCommand", 
      label: "Get Help", 
      function: () => { window.open("https://docs.example.com", "_blank"); } 
    }
  ],
  menuCommands: [
    // Add to Help menu
    { 
      path: ["Help"], 
      commands: ["helpCommand"] 
    },
    // Also add to Extensions menu
    { 
      path: ["Extensions"], 
      commands: ["helpCommand"] 
    }
  ]
});
```

Commands can work with other ComfyUI APIs like settings. For more information about the Settings API, see the [Settings API](./javascript_settings) documentation.

# Context Menu Migration Guide

This guide helps you migrate from the deprecated monkey-patching approach to the new context menu extension API.

The old approach of monkey-patching `LGraphCanvas.prototype.getCanvasMenuOptions` and `nodeType.prototype.getExtraMenuOptions` is deprecated:

<Tip>If you see deprecation warnings in your browser console, your extension is using the old API and should be migrated.</Tip>

## Migrating Canvas Menus

### Old Approach (Deprecated)

The old approach modified the prototype during extension setup:

```javascript  theme={null}
import { app } from "../../scripts/app.js"

app.registerExtension({
  name: "MyExtension",
  async setup() {
    // âŒ OLD: Monkey-patching the prototype
    const original = LGraphCanvas.prototype.getCanvasMenuOptions
    LGraphCanvas.prototype.getCanvasMenuOptions = function() {
      const options = original.apply(this, arguments)

      options.push(null) // separator
      options.push({
        content: "My Custom Action",
        callback: () => {
          console.log("Action triggered")
        }
      })

      return options
    }
  }
})
```

### New Approach (Recommended)

The new approach uses a dedicated extension hook:

```javascript  theme={null}
import { app } from "../../scripts/app.js"

app.registerExtension({
  name: "MyExtension",
  // âœ… NEW: Use the getCanvasMenuItems hook
  getCanvasMenuItems(canvas) {
    return [
      null, // separator
      {
        content: "My Custom Action",
        callback: () => {
          console.log("Action triggered")
        }
      }
    ]
  }
})
```

### Key Differences

| Old Approach               | New Approach                     |
| -------------------------- | -------------------------------- |
| Modified in `setup()`      | Uses `getCanvasMenuItems()` hook |
| Wraps existing function    | Returns menu items directly      |
| Modifies `options` array   | Returns new array                |
| Canvas accessed via `this` | Canvas passed as parameter       |

## Migrating Node Menus

### Old Approach (Deprecated)

The old approach modified the node type prototype:

```javascript  theme={null}
import { app } from "../../scripts/app.js"

app.registerExtension({
  name: "MyExtension",
  async beforeRegisterNodeDef(nodeType, nodeData, app) {
    if (nodeType.comfyClass === "KSampler") {
      // âŒ OLD: Monkey-patching the node prototype
      const original = nodeType.prototype.getExtraMenuOptions
      nodeType.prototype.getExtraMenuOptions = function(canvas, options) {
        original?.apply(this, arguments)

        options.push({
          content: "Randomize Seed",
          callback: () => {
            const seedWidget = this.widgets.find(w => w.name === "seed")
            if (seedWidget) {
              seedWidget.value = Math.floor(Math.random() * 1000000)
            }
          }
        })
      }
    }
  }
})
```

### New Approach (Recommended)

The new approach uses a dedicated extension hook:

```javascript  theme={null}
import { app } from "../../scripts/app.js"

app.registerExtension({
  name: "MyExtension",
  // âœ… NEW: Use the getNodeMenuItems hook
  getNodeMenuItems(node) {
    const items = []

    // Add items only for specific node types
    if (node.comfyClass === "KSampler") {
      items.push({
        content: "Randomize Seed",
        callback: () => {
          const seedWidget = node.widgets.find(w => w.name === "seed")
````
Assistant

ðŸ› ï¸ read_file (call_MHxORDB4UUlCMzh0WEV5cDJ2SEg) {
  "endLine": 4378,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\COMFYUI_RAW_DOCS.md",
  "startLine": 3601
}
Tool
ðŸ› ï¸ call_MHxORDB4UUlCMzh0WEV5cDJ2SEg
````markdown
          if (seedWidget) {
            seedWidget.value = Math.floor(Math.random() * 1000000)
          }
        }
      })
    }

    return items
  }
})
```

### Key Differences

| Old Approach                          | New Approach                         |
| ------------------------------------- | ------------------------------------ |
| Modified in `beforeRegisterNodeDef()` | Uses `getNodeMenuItems()` hook       |
| Type-specific via `if` check          | Type-specific via `if` check in hook |
| Modifies `options` array              | Returns new array                    |
| Node accessed via `this`              | Node passed as parameter             |

## Common Patterns

### Conditional Menu Items

Both approaches support conditional items, but the new API is cleaner:

```javascript  theme={null}
// âœ… NEW: Clean conditional logic
getCanvasMenuItems(canvas) {
  const items = []

  if (canvas.selectedItems.size > 0) {
    items.push({
      content: `Process ${canvas.selectedItems.size} Selected Nodes`,
      callback: () => {
        // Process nodes
      }
    })
  }

  return items
}
```

### Adding Separators

Separators are added the same way in both approaches:

```javascript  theme={null}
getCanvasMenuItems(canvas) {
  return [
    null, // Separator (horizontal line)
    {
      content: "My Action",
      callback: () => {}
    }
  ]
}
```

### Creating Submenus

The recommended way to create submenus is using the declarative `submenu` property:

```javascript  theme={null}
getNodeMenuItems(node) {
  return [
    {
      content: "Advanced Options",
      submenu: {
        options: [
          { content: "Option 1", callback: () => {} },
          { content: "Option 2", callback: () => {} }
        ]
      }
    }
  ]
}
```

This declarative approach is cleaner and matches the patterns used throughout the ComfyUI codebase.

<Tip>While a callback-based approach with `has_submenu: true` and `new LiteGraph.ContextMenu()` is also supported, the declarative `submenu` property is preferred for better maintainability.</Tip>

### Accessing State

```javascript  theme={null}
// âœ… NEW: State access is clearer
getCanvasMenuItems(canvas) {
  // Access canvas properties
  const selectedCount = canvas.selectedItems.size
  const graphMousePos = canvas.graph_mouse

  return [/* menu items */]
}

getNodeMenuItems(node) {
  // Access node properties
  const nodeType = node.comfyClass
  const isDisabled = node.mode === 2
  const widgets = node.widgets

  return [/* menu items */]
}
```

## Troubleshooting

### How to Identify Old API Usage

Look for these patterns in your code:

```javascript  theme={null}
// âŒ Signs of old API:
LGraphCanvas.prototype.getCanvasMenuOptions = function() { /* ... */ }
nodeType.prototype.getExtraMenuOptions = function() { /* ... */ }
```

### Understanding Deprecation Warnings

If you see this warning in the console:

```
[DEPRECATED] Monkey-patching getCanvasMenuOptions is deprecated. (Extension: "MyExtension")
Please use the new context menu API instead.
See: https://docs.comfy.org/custom-nodes/js/context-menu-migration
```

Your extension is using the old approach and should be migrated.

### Verifying Migration Success

After migration:

1. Remove all prototype modifications from `setup()` and `beforeRegisterNodeDef()`
2. Add `getCanvasMenuItems()` and/or `getNodeMenuItems()` hooks
3. Test that your menu items still appear correctly
4. Verify no deprecation warnings appear in the console

### Complete Migration Example

**Before:**

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  async setup() {
    const original = LGraphCanvas.prototype.getCanvasMenuOptions
    LGraphCanvas.prototype.getCanvasMenuOptions = function() {
      const options = original.apply(this, arguments)
      options.push({ content: "Action", callback: () => {} })
      return options
    }
  },
  async beforeRegisterNodeDef(nodeType) {
    if (nodeType.comfyClass === "KSampler") {
      const original = nodeType.prototype.getExtraMenuOptions
      nodeType.prototype.getExtraMenuOptions = function(_, options) {
        original?.apply(this, arguments)
        options.push({ content: "Node Action", callback: () => {} })
      }
    }
  }
})
```

**After:**

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  getCanvasMenuItems(canvas) {
    return [
      { content: "Action", callback: () => {} }
    ]
  },
  getNodeMenuItems(node) {
    if (node.comfyClass === "KSampler") {
      return [
        { content: "Node Action", callback: () => {} }
      ]
    }
    return []
  }
})
```

## Additional Resources

* [Annotated Examples](./javascript_examples) - More examples using the new API
* [Extension Hooks](./javascript_hooks) - Complete list of available extension hooks
* [Commands and Keybindings](./javascript_commands_keybindings) - Add keyboard shortcuts to your menu actions

# Annotated Examples

A growing collection of fragments of example code...

## Right click menus

### Background menu

The main background menu (right-click on the canvas) is generated by a call to
`LGraphCanvas.getCanvasMenuOptions`. The standard way of editing this is to implement the `getCanvasMenuItems` method on your extension:

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  getCanvasMenuItems(canvas) {
    const items = []
    items.push(null) // inserts a divider
    items.push({
      content: "The text for the menu",
      callback: async () => {
        // do whatever
      }
    })
    return items
  }
});
```

### Node menu

When you right click on a node, the menu is similarly generated by `node.getExtraMenuOptions`.
The standard way is to implement the `getNodeMenuItems` method on your extension:

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  getNodeMenuItems(node) {
    const items = []

    // You can filter by node type if needed
    if (node.comfyClass === "MyNodeClass") {
      items.push({
        content: "Do something fun",
        callback: async () => {
          // fun thing
        }
      })
    }

    return items
  }
});
```

### Submenus

If you want a submenu, use the `submenu` property with an `options` array:

```javascript  theme={null}
app.registerExtension({
  name: "MyExtension",
  getCanvasMenuItems(canvas) {
    const items = []
    items.push({
      content: "Menu with options",
      submenu: {
        options: [
          {
            content: "option 1",
            callback: (v) => {
              // do something with v
            }
          },
          {
            content: "option 2",
            callback: (v) => {
              // do something with v
            }
          },
          {
            content: "option 3",
            callback: (v) => {
              // do something with v
            }
          }
        ]
      }
    })
    return items
  }
});
```

## Capture UI events

This works just like you'd expect - find the UI element in the DOM and
add an eventListener. `setup()` is a good place to do this, since the page
has fully loaded. For instance, to detect a click on the 'Queue' button:

```Javascript  theme={null}
function queue_button_pressed() { console.log("Queue button was pressed!") }
document.getElementById("queue-button").addEventListener("click", queue_button_pressed);
```

## Detect when a workflow starts

This is one of many `api` events:

```javascript  theme={null}
import { api } from "../../scripts/api.js";
/* in setup() */
    function on_execution_start() { 
        /* do whatever */
    }
    api.addEventListener("execution_start", on_execution_start);
```

## Detect an interrupted workflow

<Note>
  **Deprecated:** The API hijacking pattern shown below is deprecated and subject to change at any point in the near future. Use the official [extension hooks](/custom-nodes/js/javascript_hooks) and API event listeners where available.
</Note>

A simple example of hijacking the api:

```Javascript  theme={null}
import { api } from "../../scripts/api.js";
/* in setup() */
    const original_api_interrupt = api.interrupt;
    api.interrupt = function () {
        /* Do something before the original method is called */
        original_api_interrupt.apply(this, arguments);
        /* Or after */
    }
```

## Catch clicks on your node

<Note>
  **Deprecated:** The node method hijacking pattern shown below is deprecated and subject to change at any point in the near future. Use the official [extension hooks](/custom-nodes/js/javascript_hooks) where available.
</Note>

`node` has a mouseDown method you can hijack.
This time we're careful to pass on any return value.

```javascript  theme={null}
async nodeCreated(node) {
    if (node?.comfyClass === "My Node Name") {
        const original_onMouseDown = node.onMouseDown;
        node.onMouseDown = function( e, pos, canvas ) {
            alert("ouch!");
            return original_onMouseDown?.apply(this, arguments);
        }        
    }
}
```

# V3 Migration

> How to migrate your existing V1 nodes to the new V3 schema.

## Overview

The ComfyUI V3 schema introduces a more organized way of defining nodes, and future extensions to node features will only be added to V3 schema. You can use this guide to help you migrate your existing V1 nodes to the new V3 schema.

## Core Concepts

The V3 schema is kept on the new versioned Comfy API, meaning future revisions to the schema will be backwards compatible. `comfy_api.latest` will point to the latest numbered API that is still under development; the version before latest is what can be considered 'stable'. Version `v0_0_2` is the current (and first) API version so more changes will be made to it without warning. Once it is considered stable, a new version `v0_0_3` will be created for `latest` to point at.

```python  theme={null}
# use latest ComfyUI API
from comfy_api.latest import ComfyExtension, io, ui

# use a specific version of ComfyUI API
from comfy_api.v0_0_2 import ComfyExtension, io, ui
```

### V1 vs V3 Architecture

The biggest changes in V3 schema are:

* Inputs and Outputs defined by objects instead of a dictionary.
* The execution method is fixed to the name 'execute' and is a class method.
* `def comfy_entrypoint()` function that returns a ComfyExtension object defines exposed nodes instead of NODE\_CLASS\_MAPPINGS/NODE\_DISPLAY\_NAME\_MAPPINGS
* Node objects do not expose 'state' - `def __init__(self)` will have no effect on what is exposed in the node's functions, as all of them are class methods. The node class is sanitized before execution as well.

#### V1 (Legacy)

```python  theme={null}
class MyNode:
    @classmethod
    def INPUT_TYPES(s):
        return {"required": {...}}

    RETURN_TYPES = ("IMAGE",)
    FUNCTION = "execute"
    CATEGORY = "my_category"

    def execute(self, ...):
        return (result,)

NODE_CLASS_MAPPINGS = {"MyNode": MyNode}
```

#### V3 (Modern)

```python  theme={null}
from comfy_api.latest import ComfyExtension, io

class MyNode(io.ComfyNode):
    @classmethod
    def define_schema(cls) -> io.Schema:
        return io.Schema(
            node_id="MyNode",
            display_name="My Node",
            category="my_category",
            inputs=[...],
            outputs=[...]
        )

    @classmethod
    def execute(cls, ...) -> io.NodeOutput:
        return io.NodeOutput(result)

class MyExtension(ComfyExtension):
    async def get_node_list(self) -> list[type[io.ComfyNode]]:
        return [MyNode]

async def comfy_entrypoint() -> ComfyExtension:
    return MyExtension()
```

## Migration Steps

Going from V1 to V3 should be simple in most cases and is simply a syntax change.

### Step 1: Change Base Class

All V3 Schema nodes should inherit from `ComfyNode`. Multiple layers of inheritance are okay as long as at the top of the chain there is a `ComfyNode` parent.

**V1:**

```python  theme={null}
class Example:
    def __init__(self):
        pass
```

**V3:**

```python  theme={null}
from comfy_api.latest import io

class Example(io.ComfyNode):
    # No __init__ needed
```

### Step 2: Convert INPUT\_TYPES to define\_schema

Node properties like node id, display name, category, etc. that were assigned in different places in code such as dictionaries and class properties are now kept together via the `Schema` class.

The `define_schema(cls)` function is expected to return a `Schema` object in much the same way INPUT\_TYPES(s) worked in V1.

Supported core Input/Output types are stored and documented in `comfy_api/{version}` in `_io.py`, which is namespaced as `io` by default. Since Inputs/Outputs are defined by classes now instead of dictionaries or strings, custom types are supported by either defining your own class or using the helper function `Custom` in `io`.

Custom types are elaborated on in a section further below.

A type class has the following properties:

* `class Input` for Inputs (i.e. `Model.Input(...)`)
* `class Output` for Outputs (i.e. `Model.Output(...)`). Note that all types may not support being an output.
* `Type` for getting a typehint of the type (i.e. `Model.Type`). Note that some typehints are just `any`, which may be updated in the future. These typehints are not enforced and just act as useful documentation.

**V1:**

```python  theme={null}
@classmethod
def INPUT_TYPES(s):
    return {
        "required": {
            "image": ("IMAGE",),
            "int_field": ("INT", {
                "default": 0,
                "min": 0,
                "max": 4096,
                "step": 64,
                "display": "number"
            }),
            "string_field": ("STRING", {
                "multiline": False,
                "default": "Hello"
            }),
            # V1 handling of arbitrary types
            "custom_field": ("MY_CUSTOM_TYPE",),
        },
        "optional": {
            "mask": ("MASK",)
        }
    }
```

**V3:**

```python  theme={null}
@classmethod
def define_schema(cls) -> io.Schema:
    return io.Schema(
        node_id="Example",
        display_name="Example Node",
        category="examples",
        description="Node description here",
        inputs=[
            io.Image.Input("image"),
            io.Int.Input("int_field",
                default=0,
                min=0,
                max=4096,
                step=64,
                display_mode=io.NumberDisplay.number
            ),
            io.String.Input("string_field",
                default="Hello",
                multiline=False
            ),
            # V3 handling of arbitrary types
            io.Custom("my_custom_type").Input("custom_input"),
            io.Mask.Input("mask", optional=True)
        ],
        outputs=[
            io.Image.Output()
        ]
    )
```

### Step 3: Update Execute Method

All execution functions in v3 are named `execute` and are class methods.

**V1:**

```python  theme={null}
def test(self, image, string_field, int_field):
    # Process
    image = 1.0 - image
    return (image,)
```

**V3:**

```python  theme={null}
@classmethod
def execute(cls, image, string_field, int_field) -> io.NodeOutput:
    # Process
    image = 1.0 - image

    # Return with optional UI preview
    return io.NodeOutput(image, ui=ui.PreviewImage(image, cls=cls))
```

### Step 4: Convert Node Properties

Here are some examples of property names; see the source code in `comfy_api.latest._io` for more details.

| V1 Property    | V3 Schema Field             | Notes                       |
| -------------- | --------------------------- | --------------------------- |
| `RETURN_TYPES` | `outputs` in Schema         | List of Output objects      |
| `RETURN_NAMES` | `display_name` in Output    | Per-output display names    |
| `FUNCTION`     | Always `execute`            | Method name is standardized |
| `CATEGORY`     | `category` in Schema        | String value                |
| `OUTPUT_NODE`  | `is_output_node` in Schema  | Boolean flag                |
| `DEPRECATED`   | `is_deprecated` in Schema   | Boolean flag                |
| `EXPERIMENTAL` | `is_experimental` in Schema | Boolean flag                |

### Step 5: Handle Special Methods

The same special methods are supported as in v1, but either lowercased or renamed entirely to be more clear. Their usage remains the same.

#### Validation (V1 â†’ V3)

The input validation function was renamed to `validate_inputs`.

**V1:**

```python  theme={null}
@classmethod
def VALIDATE_INPUTS(s, **kwargs):
    # Validation logic
    return True
```

**V3:**

```python  theme={null}
@classmethod
def validate_inputs(cls, **kwargs) -> bool | str:
    # Return True if valid, error string if not
    if error_condition:
        return "Error message"
    return True
```

#### Lazy Evaluation (V1 â†’ V3)

The `check_lazy_status` function is class method, remains the same otherwise.

**V1:**

```python  theme={null}
def check_lazy_status(self, image, string_field, ...):
    if condition:
        return ["string_field"]
    return []
```

**V3:**

```python  theme={null}
@classmethod
def check_lazy_status(cls, image, string_field, ...):
    if condition:
        return ["string_field"]
    return []
```

#### Cache Control (V1 â†’ V3)

The functionality of cache control remains the same as in V1, but the original name was very misleading as to how it operated.

V1's `IS_CHANGED` function signals execution not to trigger rerunning the node if the return value is the SAME as the last time the node was ran.

Thus, the function `IS_CHANGED` was renamed to `fingerprint_inputs`. One of the most common mistakes by developers was thinking if you return `True`, the node would always re-run. Because `True` would always be returned, it would have the opposite effect of only making the node run once and reuse cached values.

An example of using this function is the LoadImage node. It returns the hash of the selected file, so that if the file changes, the node will be forced to rerun.

**V1:**

```python  theme={null}
@classmethod
def IS_CHANGED(s, **kwargs):
    return "unique_value"
```

**V3:**

```python  theme={null}
@classmethod
def fingerprint_inputs(cls, **kwargs):
    return "unique_value"
```

### Step 6: Create Extension and Entry Point

Instead of defining dictionaries to link node id to node class/display name, there is now a `ComfyExtension` class and an expected `comfy_entrypoint` function to be defined.

In the future, more functions may be added to ComfyExtension to register more than just nodes via `get_node_list`.

`comfy_entrypoint` can be either async or not, but `get_node_list` must be defined as async.

**V1:**

```python  theme={null}
NODE_CLASS_MAPPINGS = {
    "Example": Example
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "Example": "Example Node"
}
```

**V3:**

```python  theme={null}
from comfy_api.latest import ComfyExtension

class MyExtension(ComfyExtension):
    # must be declared as async
    async def get_node_list(self) -> list[type[io.ComfyNode]]:
        return [
            Example,
            # Add more nodes here
        ]

# can be declared async or not, both will work
async def comfy_entrypoint() -> MyExtension:
    return MyExtension()
```

## Input Type Reference

Already explained in step 2, but here are some type reference comparisons in V1 vs V3. See `comfy_api.latest._io` for the full type declarations.

### Basic Types

| V1 Type     | V3 Type              | Example                                                      |
| ----------- | -------------------- | ------------------------------------------------------------ |
| `"INT"`     | `io.Int.Input()`     | `io.Int.Input("count", default=1, min=0, max=100)`           |
| `"FLOAT"`   | `io.Float.Input()`   | `io.Float.Input("strength", default=1.0, min=0.0, max=10.0)` |
| `"STRING"`  | `io.String.Input()`  | `io.String.Input("text", multiline=True)`                    |
| `"BOOLEAN"` | `io.Boolean.Input()` | `io.Boolean.Input("enabled", default=True)`                  |

### ComfyUI Types

| V1 Type          | V3 Type                   | Example                                          |
| ---------------- | ------------------------- | ------------------------------------------------ |
| `"IMAGE"`        | `io.Image.Input()`        | `io.Image.Input("image", tooltip="Input image")` |
| `"MASK"`         | `io.Mask.Input()`         | `io.Mask.Input("mask", optional=True)`           |
| `"LATENT"`       | `io.Latent.Input()`       | `io.Latent.Input("latent")`                      |
| `"CONDITIONING"` | `io.Conditioning.Input()` | `io.Conditioning.Input("positive")`              |
| `"MODEL"`        | `io.Model.Input()`        | `io.Model.Input("model")`                        |
| `"VAE"`          | `io.VAE.Input()`          | `io.VAE.Input("vae")`                            |
| `"CLIP"`         | `io.CLIP.Input()`         | `io.CLIP.Input("clip")`                          |

### Combo (Dropdowns/Selection Lists)

Combo types in V3 require explicit class definition.

**V1:**

```python  theme={null}
"mode": (["option1", "option2", "option3"],)
```

**V3:**

```python  theme={null}
io.Combo.Input("mode", options=["option1", "option2", "option3"])
```

## Advanced Features

### UI Integration

V3 provides built-in UI helpers to avoid common boilerplate of saving files.

```python  theme={null}
from comfy_api.latest import ui

@classmethod
def execute(cls, images) -> io.NodeOutput:
    # Show preview in node
    return io.NodeOutput(images, ui=ui.PreviewImage(images, cls=cls))
```

### Output Nodes

For nodes that produce side effects (like saving files). Same as in V1, marking a node as output will display a `run` play button in the node's context window, allowing for partial execution of the graph.

```python  theme={null}
@classmethod
def define_schema(cls) -> io.Schema:
    return io.Schema(
        node_id="SaveNode",
        inputs=[...],
        outputs=[],  # Does not need to be empty.
        is_output_node=True  # Mark as output node
    )
```

### Custom Types

Create custom input/output types either via class definition of `Custom` helper function.

```python  theme={null}
from comfy_api.latest import io

# Method 1: Using decorator with class
@io.comfytype(io_type="MY_CUSTOM_TYPE")
class MyCustomType:
    Type = torch.Tensor  # Python type hint

    class Input(io.Input):
        def __init__(self, id: str, **kwargs):
            super().__init__(id, **kwargs)

    class Output(io.Output):
        def __init__(self, **kwargs):
            super().__init__(**kwargs)

# Method 2: Using Custom helper
# The helper can be used directly without saving to a variable first for convenience as well
MyCustomType = io.Custom("MY_CUSTOM_TYPE")
```

````
Assistant

ðŸ› ï¸ create_directory (call_MHx2QWVLV3NPakp0UzJ6ekRDYlY) {
  "dirPath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS_DOC"
}
Tool
ðŸ› ï¸ call_MHx2QWVLV3NPakp0UzJ6ekRDYlY
Created directory at c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC
Assistant

ðŸ› ï¸ create_file (call_MHxZTzI2aHlST3BjZnBTZ0hITFg) {
  "content": "# ComfyUI Custom Node Development - Overview & Setup

## Architecture Overview

ComfyUI operates on a **Client-Server model**:
- **Server (Python)**: Handles data processing, model execution, and image generation. Built on `aiohttp` and `asyncio`.
- **Client (Javascript)**: Handles the user interface, graph manipulation, and workflow submission.

Custom nodes can be:
1.  **Server-side only**: Most common. Defines logic to process inputs and produce outputs.
2.  **Client-side only**: UI modifications.
3.  **Hybrid**: Custom server logic with custom UI elements (widgets, etc.).

## Project Structure

A custom node project is a Python module (directory with `__init__.py`) located in the `custom_nodes` folder of ComfyUI.

Recommended structure:
```
My_Custom_Node/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ my_node.py          # Node definitions
â”œâ”€â”€ web/
â”‚   â””â”€â”€ js/
â”‚       â””â”€â”€ my_extension.js # Client-side code
â””â”€â”€ requirements.txt    # Python dependencies
```

## Node Lifecycle & Registration

When ComfyUI starts, it scans `custom_nodes` and imports modules.

### `__init__.py` (V1 / Legacy)

Must export `NODE_CLASS_MAPPINGS` and optionally `NODE_DISPLAY_NAME_MAPPINGS` and `WEB_DIRECTORY`.

```python
from .my_node import MyNode

NODE_CLASS_MAPPINGS = {
    \"MyNodeID\": MyNode
}

NODE_DISPLAY_NAME_MAPPINGS = {
    \"MyNodeID\": \"My Cool Node\"
}

WEB_DIRECTORY = \"./web/js\" # Optional: for client-side extensions

__all__ = [\"NODE_CLASS_MAPPINGS\", \"NODE_DISPLAY_NAME_MAPPINGS\", \"WEB_DIRECTORY\"]
```

### `__init__.py` (V3 / Modern)

Uses `ComfyExtension` and an entry point function.

```python
from comfy_api.latest import ComfyExtension
from .my_node import MyNode

class MyExtension(ComfyExtension):
    async def get_node_list(self) -> list[type[io.ComfyNode]]:
        return [MyNode]

async def comfy_entrypoint() -> ComfyExtension:
    return MyExtension()
```

## V3 Migration Note

ComfyUI is moving towards a V3 schema (`comfy_api`).
- **V1**: Dictionary-based configuration (`INPUT_TYPES`), `NODE_CLASS_MAPPINGS`.
- **V3**: Class-based schema (`define_schema`), `ComfyExtension`.

New development should consider V3, but V1 is still widely used. This documentation covers both, noting differences where applicable.
",
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS_DOC\\01_Overview_and_Setup.md"
}
Tool
ðŸ› ï¸ call_MHxZTzI2aHlST3BjZnBTZ0hITFg
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC\01_Overview_and_Setup.md

Assistant

ðŸ› ï¸ create_file (call_MHxBbEtUQWRXalVOVlNvMWVyczU) {
  "content": "# Node Definition

## V1 (Legacy) Node Structure

A V1 custom node is a Python class with specific attributes and methods.

```python
class MyNode:
    @classmethod
    def INPUT_TYPES(s):
        return {
            \"required\": {
                \"image\": (\"IMAGE\",),
                \"int_val\": (\"INT\", {\"default\": 0, \"min\": 0, \"max\": 10}),
            },
            \"optional\": {
                \"mask\": (\"MASK\",),
            },
            \"hidden\": {
                \"unique_id\": \"UNIQUE_ID\",
            }
        }

    RETURN_TYPES = (\"IMAGE\",)
    RETURN_NAMES = (\"output_image\",) # Optional
    FUNCTION = \"execute\"
    CATEGORY = \"MyCategory\"
    
    # Optional: Set to True if this node saves files or interacts with outside world
    OUTPUT_NODE = False 

    def execute(self, image, int_val, mask=None, unique_id=None):
        # Processing logic
        return (image,)
```

### Key Attributes (V1)
- **`INPUT_TYPES` (@classmethod)**: Returns a dict defining inputs.
    - Keys: `required`, `optional`, `hidden`.
    - Values: Dict of `name: (Type, {options})`.
- **`RETURN_TYPES`**: Tuple of strings defining output types. **Must be a tuple** (add trailing comma for single item).
- **`FUNCTION`**: String name of the method to call for execution.
- **`CATEGORY`**: String path for the node menu (e.g., \"image/processing\").
- **`OUTPUT_NODE`**: Boolean. If `True`, node is always executed (like SaveImage).
- **`IS_CHANGED`**: (Renamed to `fingerprint_inputs` in V3). Controls caching.

## V3 (Modern) Node Structure

Inherits from `io.ComfyNode` and uses `define_schema`.

```python
from comfy_api.latest import io, ui

class MyNode(io.ComfyNode):
    @classmethod
    def define_schema(cls) -> io.Schema:
        return io.Schema(
            node_id=\"MyNode\",
            display_name=\"My Node\",
            category=\"MyCategory\",
            inputs=[
                io.Image.Input(\"image\"),
                io.Int.Input(\"int_val\", default=0, min=0, max=10),
                io.Mask.Input(\"mask\", optional=True)
            ],
            outputs=[
                io.Image.Output()
            ]
        )

    @classmethod
    def execute(cls, image, int_val, mask=None) -> io.NodeOutput:
        # Processing logic
        return io.NodeOutput(image)
```

### Key Differences (V3)
- **Base Class**: Must inherit from `io.ComfyNode`.
- **Schema**: `define_schema` replaces `INPUT_TYPES`, `RETURN_TYPES`, `CATEGORY`, etc.
- **Execution**: Method is always named `execute` and is a `@classmethod`.
- **Return**: Returns `io.NodeOutput` object instead of a tuple.

## Caching Control (`IS_CHANGED` / `fingerprint_inputs`)

By default, ComfyUI caches results. It re-runs a node only if inputs change.

### V1: `IS_CHANGED`
Returns a value (usually a string/hash) representing the state. If the return value differs from the previous run, the node re-runs.
- To force re-run every time: `return float(\"NaN\")`
- To check file hash (e.g., LoadImage): Return hash of file content.

```python
@classmethod
def IS_CHANGED(s, image, **kwargs):
    return float(\"NaN\") # Always re-run
```

### V3: `fingerprint_inputs`
Same concept, renamed.

```python
@classmethod
def fingerprint_inputs(cls, **kwargs):
    return \"unique_hash\"
```
",
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS_DOC\\02_Node_Definition.md"
}
Tool
ðŸ› ï¸ call_MHxBbEtUQWRXalVOVlNvMWVyczU
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC\02_Node_Definition.md

Assistant

ðŸ› ï¸ create_file (call_MHxXMjRIdFNJWHRkZXpOdFhoQzE) {
  "content": "# Data Types and Tensors

## Standard Data Types

These types are used in `INPUT_TYPES` (V1) or `io.*.Input` (V3).

| Type | Python Type | V1 Definition | V3 Definition | Notes |
| :--- | :--- | :--- | :--- | :--- |
| **INT** | `int` | `(\"INT\", {\"default\": 0, \"min\": 0, \"max\": 10})` | `io.Int.Input(...)` | |
| **FLOAT** | `float` | `(\"FLOAT\", {\"default\": 1.0, \"step\": 0.1})` | `io.Float.Input(...)` | |
| **STRING** | `str` | `(\"STRING\", {\"multiline\": True})` | `io.String.Input(...)` | |
| **BOOLEAN** | `bool` | `(\"BOOLEAN\", {\"default\": True})` | `io.Boolean.Input(...)` | |
| **COMBO** | `str` | `([\"opt1\", \"opt2\"],)` | `io.Combo.Input(options=[\"...\"])` | Dropdown list |

## Tensor Data Types

ComfyUI uses `torch.Tensor` for heavy data.

### IMAGE
- **Shape**: `[B, H, W, C]` (Batch, Height, Width, Channels)
- **Channels**: Usually 3 (RGB).
- **Range**: 0.0 to 1.0 (float32).
- **Note**: Channel-last format (unlike standard PyTorch `[B, C, H, W]`).

### MASK
- **Shape**: `[H, W]` or `[B, H, W]` or `[B, H, W, C]` (C=1).
- **Range**: 0.0 to 1.0.
- **Usage**: 0.0 is masked out, 1.0 is active (or vice versa depending on operation).

### LATENT
- **Type**: `dict`
- **Key `samples`**: `torch.Tensor` with shape `[B, C, H, W]`.
    - **Channels**: 4 (for SD1.5/SDXL).
    - **Dimensions**: H and W are 1/8th of pixel space.
- **Note**: Channel-first format.

## Tensor Manipulation Tips

- **Batch Dimension**: Always handle the batch dimension `B`. Even a single image is `[1, H, W, C]`.
- **Squeeze/Unsqueeze**:
    - `unsqueeze(0)`: Add batch dim (`[H,W,C]` -> `[1,H,W,C]`).
    - `unsqueeze(-1)`: Add channel dim (`[H,W]` -> `[H,W,1]`).
- **PIL Conversion**:
    - Tensor to PIL: `Image.fromarray(np.clip(255. * tensor.cpu().numpy(), 0, 255).astype(np.uint8))`
    - PIL to Tensor: `torch.from_numpy(np.array(image).astype(np.float32) / 255.0)[None,]`

## Custom Types

You can define arbitrary types (e.g., `MODEL`, `VAE`, `CLIP`, `MY_CUSTOM_TYPE`).
- **V1**: Just use the string name. `(\"MY_TYPE\",)`
- **V3**: Use `io.Custom(\"MY_TYPE\").Input(...)`.

## Flexible Inputs (Wildcards)

- **`*`**: Matches any type.
    - V1: `(\"*\" , {})`
    - Note: Requires `VALIDATE_INPUTS` to skip type checking.
",
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS_DOC\\03_Data_Types_and_Tensors.md"
}
Tool
ðŸ› ï¸ call_MHxXMjRIdFNJWHRkZXpOdFhoQzE
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC\03_Data_Types_and_Tensors.md

Assistant

ðŸ› ï¸ create_file (call_MHxNWElMRnVWck5VVHZ5WTZwRzE) {
  "content": "# Communication and API

## Server-Client Communication

### Sending Messages (Server -> Client)

Use `PromptServer` to send events to the frontend.

```python
from server import PromptServer

# In your execute method:
PromptServer.instance.send_sync(\"my.custom.event\", {\"data\": \"hello\", \"node\": node_id})
```

### Receiving Messages (Client)

In your Javascript extension (`setup`):

```javascript
import { api } from \"../../scripts/api.js\";

api.addEventListener(\"my.custom.event\", (event) => {
    console.log(event.detail.data); // \"hello\"
});
```

## Hidden Inputs

To get context information in your `execute` method, request hidden inputs in `INPUT_TYPES`.

```python
@classmethod
def INPUT_TYPES(s):
    return {
        \"required\": {...},
        \"hidden\": {
            \"unique_id\": \"UNIQUE_ID\",       # The node's ID
            \"prompt\": \"PROMPT\",             # The full workflow prompt
            \"extra_pnginfo\": \"EXTRA_PNGINFO\" # Metadata to save with images
        }
    }

def execute(self, ..., unique_id=None, prompt=None):
    # Use unique_id to send specific messages
    pass
```

## Custom API Routes

You can add HTTP endpoints to the ComfyUI server.

```python
from server import PromptServer
from aiohttp import web

@PromptServer.instance.routes.post(\"/my_custom_route\")
async def my_route_handler(request):
    data = await request.json()
    return web.json_response({\"status\": \"ok\"})
```

Client-side call:
```javascript
import { api } from \"../../scripts/api.js\";

api.fetchApi(\"/my_custom_route\", {
    method: \"POST\",
    body: JSON.stringify({ foo: \"bar\" })
});
```
",
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS_DOC\\04_Communication_and_API.md"
}
Tool
ðŸ› ï¸ call_MHxNWElMRnVWck5VVHZ5WTZwRzE
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC\04_Communication_and_API.md

Assistant

ðŸ› ï¸ create_file (call_MHxkaFY0SkhkWDlSUjFsdnBscXY) {
  "content": "# Advanced Topics

## Input Validation (`VALIDATE_INPUTS`)

Allows custom validation logic before execution.

```python
@classmethod
def VALIDATE_INPUTS(cls, input_name, **kwargs):
    if input_name > 100:
        return \"Value too high!\"
    return True
```

- **`input_types` argument**: If accepted, receives a dict of connected types. Useful for `*` inputs.

## Lazy Evaluation

Avoid processing inputs if they aren't needed (e.g., a Switch node).

1.  Mark input as lazy in `INPUT_TYPES`: `(\"IMAGE\", {\"lazy\": True})`.
2.  Implement `check_lazy_status`.

```python
def check_lazy_status(self, switch_val, image1, image2):
    needed = []
    if switch_val == \"on\":
        needed.append(\"image1\")
    else:
        needed.append(\"image2\")
    return needed
```

## List Processing

Handle batches or lists of inputs manually.

- **`INPUT_IS_LIST = True`**: The `execute` method receives lists for all inputs. You must handle iteration.
- **`OUTPUT_IS_LIST = (True,)`**: The output is a list of items to be processed sequentially by the next node, not a single batch tensor.

```python
INPUT_IS_LIST = True
OUTPUT_IS_LIST = (True,)

def execute(self, images):
    # images is list[torch.Tensor]
    results = []
    for img in images:
        results.append(process(img))
    return (results,)
```

## Node Expansion

Allows a node to expand into a subgraph at runtime (e.g., for loops).
Requires returning a dictionary with `result` and `expand`.

```python
return {
    \"result\": (output,),
    \"expand\": graph_object
}
```
(See `GraphBuilder` documentation for details).
",
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS_DOC\\05_Advanced_Topics.md"
}
Tool
ðŸ› ï¸ call_MHxkaFY0SkhkWDlSUjFsdnBscXY
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC\05_Advanced_Topics.md

Assistant

ðŸ› ï¸ create_file (call_MHxhVkdhWTBGbXl5QmhIc1Y0VG4) {
  "content": "# Frontend Development

## Javascript Extensions

Place `.js` files in the directory exported by `WEB_DIRECTORY` in `__init__.py`.

### Registration

```javascript
import { app } from \"../../scripts/app.js\";

app.registerExtension({
    name: \"My.Extension.Name\",
    async setup() {
        // Called after page load
    },
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        // Modify node definitions
        if (nodeData.name === \"MyNode\") {
            // ...
        }
    },
    async nodeCreated(node) {
        // Called when a node instance is created
    }
});
```

## Context Menus

Use the new API hooks (do not monkey-patch prototypes).

### Canvas Menu (Right-click on background)

```javascript
getCanvasMenuItems(canvas) {
    return [
        {
            content: \"My Action\",
            callback: () => { ... }
        }
    ];
}
```

### Node Menu (Right-click on node)

```javascript
getNodeMenuItems(node) {
    if (node.comfyClass === \"MyNode\") {
        return [
            {
                content: \"My Node Action\",
                callback: () => { ... }
            }
        ];
    }
    return [];
}
```

## UI Components

### Settings
Register settings in `registerExtension`.

```javascript
settings: [
    {
        id: \"my.setting\",
        name: \"My Setting\",
        type: \"boolean\",
        defaultValue: false
    }
]
```

### Dialogs & Toasts
Use `app.extensionManager`.

```javascript
app.extensionManager.toast.add({ severity: \"info\", summary: \"Hello\" });
app.extensionManager.dialog.confirm({ title: \"Confirm\", message: \"Sure?\" });
```

### Sidebar / Bottom Panel
Register custom tabs.

```javascript
app.extensionManager.registerSidebarTab({
    id: \"myTab\",
    icon: \"pi pi-star\",
    title: \"My Tab\",
    type: \"custom\",
    render: (el) => { el.innerHTML = \"Content\"; }
});
```
",
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS_DOC\\06_Frontend_Development.md"
}
Tool
ðŸ› ï¸ call_MHxhVkdhWTBGbXl5QmhIc1Y0VG4
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC\06_Frontend_Development.md

Assistant

ðŸ› ï¸ read_file (call_MHxSZG45OUJzNHlOblRwM2s3aHk) {
  "endLine": 10,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS.md",
  "startLine": 1
}
Tool
ðŸ› ï¸ call_MHxSZG45OUJzNHlOblRwM2s3aHk
```markdown
# ComfyUI Custom Node - Hvppy Nodes Development Guide

ë‚´ê°€ ComfyUIë¥¼ ì‚¬ìš©í•˜ë©´ì„œ í•„ìš”í•œ ë…¸ë“œë¥¼ ì§ì ‘ ê°œë°œí•˜ê¸° ìœ„í•œ ë ˆí¬ì§€í† ë¦¬ì´ë‹¤.
ì´ ë ˆí¬ì§€í† ë¦¬ëŠ” Hvppy Nodesë¼ëŠ” ì´ë¦„ìœ¼ë¡œ, ComfyUIì˜ ê¸°ëŠ¥ì„ í™•ìž¥í•˜ëŠ” ë‹¤ì–‘í•œ ì»¤ìŠ¤í…€ ë…¸ë“œë¥¼ í¬í•¨í•˜ê³  ìžˆë‹¤.

## Developing ComfyUI Custom Nodes


```
Assistant

ðŸ› ï¸ replace_string_in_file (call_MHxXVUgzeEJvUWdrY1VvZ29Wek8) {
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\AGENTS.md",
  "newString": "## Developing ComfyUI Custom Nodes

Detailed documentation for developing custom nodes can be found in the [AGENTS_DOC](./AGENTS_DOC) folder.

- [01 Overview and Setup](./AGENTS_DOC/01_Overview_and_Setup.md)
- [02 Node Definition](./AGENTS_DOC/02_Node_Definition.md)
- [03 Data Types and Tensors](./AGENTS_DOC/03_Data_Types_and_Tensors.md)
- [04 Communication and API](./AGENTS_DOC/04_Communication_and_API.md)
- [05 Advanced Topics](./AGENTS_DOC/05_Advanced_Topics.md)
- [06 Frontend Development](./AGENTS_DOC/06_Frontend_Development.md)
",
  "oldString": "## Developing ComfyUI Custom Nodes"
}
Tool
ðŸ› ï¸ call_MHxXVUgzeEJvUWdrY1VvZ29Wek8
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS.md

Assistant
ìš”ì²­í•˜ì‹  ëŒ€ë¡œ `COMFYUI_RAW_DOCS.md`ì˜ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬, í–¥í›„ Agentê°€ ì»¤ìŠ¤í…€ ë…¸ë“œ ê°œë°œ ì‹œ ì°¸ê³ í•  ìˆ˜ ìžˆë„ë¡ ì²´ê³„ì ì¸ ë¬¸ì„œë¡œ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.

`AGENTS_DOC` í´ë”ë¥¼ ìƒì„±í•˜ê³ , ì£¼ì œë³„ë¡œ 6ê°œì˜ íŒŒì¼ë¡œ ë‚˜ëˆ„ì–´ ìž‘ì„±í–ˆìŠµë‹ˆë‹¤.

### ðŸ“‚ ìƒì„±ëœ ë¬¸ì„œ êµ¬ì¡° (`AGENTS_DOC/`)

1.  **[01_Overview_and_Setup.md](AGENTS_DOC/01_Overview_and_Setup.md)**
    *   ComfyUI í´ë¼ì´ì–¸íŠ¸-ì„œë²„ ì•„í‚¤í…ì²˜ ê°œìš”
    *   í”„ë¡œì íŠ¸ í´ë” êµ¬ì¡° ë° `__init__.py` ì„¤ì • (V1 ë° V3 ë°©ì‹)
2.  **[02_Node_Definition.md](AGENTS_DOC/02_Node_Definition.md)**
    *   ë…¸ë“œ í´ëž˜ìŠ¤ ì •ì˜ ë°©ë²• (V1 `INPUT_TYPES` vs V3 `define_schema`)
    *   ì‹¤í–‰ í•¨ìˆ˜(`execute`) ë° ì£¼ìš” ì†ì„±(`OUTPUT_NODE`, ìºì‹± ì œì–´)
3.  **[03_Data_Types_and_Tensors.md](AGENTS_DOC/03_Data_Types_and_Tensors.md)**
    *   í‘œì¤€ ë°ì´í„° íƒ€ìž… (INT, FLOAT, STRING ë“±)
    *   Tensor ë°ì´í„° íƒ€ìž… (IMAGE, MASK, LATENT) ë° Shape ì²˜ë¦¬ (`[B,H,W,C]`)
4.  **[04_Communication_and_API.md](AGENTS_DOC/04_Communication_and_API.md)**
    *   ì„œë²„-í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ í†µì‹  (`PromptServer`)
    *   Hidden Inputs (`UNIQUE_ID`, `PROMPT`) í™œìš©
    *   ì»¤ìŠ¤í…€ API ë¼ìš°íŠ¸ ì¶”ê°€ ë°©ë²•
5.  **[05_Advanced_Topics.md](AGENTS_DOC/05_Advanced_Topics.md)**
    *   ìž…ë ¥ ìœ íš¨ì„± ê²€ì‚¬ (`VALIDATE_INPUTS`)
    *   Lazy Evaluation (ë¶ˆí•„ìš”í•œ ì—°ì‚° ë°©ì§€)
    *   List Processing (ë°°ì¹˜ ì²˜ë¦¬) ë° Node Expansion
6.  **[06_Frontend_Development.md](AGENTS_DOC/06_Frontend_Development.md)**
    *   Javascript í™•ìž¥ (`WEB_DIRECTORY`)
    *   Context Menu (ìš°í´ë¦­ ë©”ë‰´) ì¶”ê°€ (New API)
    *   Settings, Dialogs, Sidebar ë“± UI ì»´í¬ë„ŒíŠ¸ í™œìš©

ë˜í•œ, ê¸°ì¡´ `AGENTS.md` íŒŒì¼ì— ìœ„ ë¬¸ì„œë“¤ì— ëŒ€í•œ ë§í¬ë¥¼ ì¶”ê°€í•˜ì—¬ ì‰½ê²Œ ì ‘ê·¼í•  ìˆ˜ ìžˆë„ë¡ ì—…ë°ì´íŠ¸í–ˆìŠµë‹ˆë‹¤. ì´ì œ AgentëŠ” ì´ ë¬¸ì„œë“¤ì„ ì°¸ì¡°í•˜ì—¬ ì •í™•í•œ ì»¤ìŠ¤í…€ ë…¸ë“œ ì½”ë“œë¥¼ ìž‘ì„±í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
There have been some changes between the last request and now.
Some edits were made, by the user or possibly by a formatter or another automated tool, to:
- c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS.md
So be sure to check the current file contents before making any new edits.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS.md. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
class ImageScaleToTotalPixels(io.ComfyNode):
    upscale_methods = ["nearest-exact", "bilinear", "area", "bicubic", "lanczos"]
    crop_methods = ["disabled", "center"]

    @classmethod
    def define_schema(cls):
        return io.Schema(
            node_id="ImageScaleToTotalPixels",
            category="image/upscaling",
            inputs=[
                io.Image.Input("image"),
                io.Combo.Input("upscale_method", options=cls.upscale_methods),
                io.Float.Input("megapixels", default=1.0, min=0.01, max=16.0, step=0.01),
                io.Int.Input("resolution_steps", default=1, min=1, max=256),
            ],
            outputs=[
                io.Image.Output(),
            ],
        )

    @classmethod
    def execute(cls, image, upscale_method, megapixels, resolution_steps) -> io.NodeOutput:
        samples = image.movedim(-1,1)
        total = megapixels * 1024 * 1024

        scale_by = math.sqrt(total / (samples.shape[3] * samples.shape[2]))
        width = round(samples.shape[3] * scale_by / resolution_steps) * resolution_steps
        height = round(samples.shape[2] * scale_by / resolution_steps) * resolution_steps

        s = comfy.utils.common_upscale(samples, int(width), int(height), upscale_method, "disabled")
        s = s.movedim(1,-1)
        return io.NodeOutput(s)

ì´ ë…¸ë“œ ë¶„ì„í•´ì¤˜. rsolution_stepsê°€ ë­ì•¼?
</userRequest>

Assistant
ì œê³µí•´ì£¼ì‹  `ImageScaleToTotalPixels` ë…¸ë“œ ì½”ë“œë¥¼ ë¶„ì„í•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

### 1. ë…¸ë“œ ê¸°ëŠ¥ ìš”ì•½
ì´ ë…¸ë“œëŠ” ìž…ë ¥ëœ ì´ë¯¸ì§€ë¥¼ **ì§€ì •ëœ ì´ í”½ì…€ ìˆ˜(Megapixels)**ì— ë§žì¶° ë¦¬ì‚¬ì´ì§•(Upscale/Downscale)í•˜ëŠ” ê¸°ëŠ¥ì„ í•©ë‹ˆë‹¤. ë‹¨ìˆœížˆ ê°€ë¡œ/ì„¸ë¡œ ê¸¸ì´ë¥¼ ì§€ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì´ë¯¸ì§€ì˜ ë¹„ìœ¨ì„ ìœ ì§€í•˜ë©´ì„œ ì „ì²´ ë©´ì (í”½ì…€ ìˆ˜)ì„ ëª©í‘œì¹˜ì— ë§žì¶¥ë‹ˆë‹¤.

### 2. `resolution_steps`ëž€ ë¬´ì—‡ì¸ê°€ìš”?

`resolution_steps`ëŠ” **ìµœì¢… ê³„ì‚°ëœ ë„ˆë¹„(Width)ì™€ ë†’ì´(Height)ê°€ íŠ¹ì • ìˆ«ìžì˜ ë°°ìˆ˜ê°€ ë˜ë„ë¡ ê°•ì œí•˜ëŠ” ê°’**ìž…ë‹ˆë‹¤.

ì½”ë“œì˜ í•µì‹¬ ë¡œì§ì„ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```python
width = round(samples.shape[3] * scale_by / resolution_steps) * resolution_steps
height = round(samples.shape[2] * scale_by / resolution_steps) * resolution_steps
```

*   **ìˆ˜ì‹ì˜ ì˜ë¯¸**: `round(ê°’ / N) * N` ì€ **ê°’ì„ ê°€ìž¥ ê°€ê¹Œìš´ Nì˜ ë°°ìˆ˜ë¡œ ë°˜ì˜¬ë¦¼**í•˜ëŠ” ê³µì‹ìž…ë‹ˆë‹¤.
*   **ì—­í• **: ìµœì¢… ì´ë¯¸ì§€ì˜ í•´ìƒë„ê°€ `resolution_steps`ë¡œ ë‚˜ëˆ„ì–´ë–¨ì–´ì§€ê²Œ ë§Œë“­ë‹ˆë‹¤.

### 3. ì™œ í•„ìš”í•œê°€ìš”? (ì‚¬ìš© ëª©ì )

Stable Diffusionê³¼ ê°™ì€ Latent Diffusion Modelë“¤ì€ ì´ë¯¸ì§€ í•´ìƒë„ì— ì œì•½ì´ ìžˆìŠµë‹ˆë‹¤.

1.  **VAE ì••ì¶• í˜¸í™˜ì„±**: ëŒ€ë¶€ë¶„ì˜ ëª¨ë¸ì€ ì´ë¯¸ì§€ë¥¼ Latent ê³µê°„ìœ¼ë¡œ ì••ì¶•í•  ë•Œ 8ë°°, 16ë°°, 32ë°° ë“±ìœ¼ë¡œ ì¶•ì†Œí•©ë‹ˆë‹¤. ë”°ë¼ì„œ ìž…ë ¥ ì´ë¯¸ì§€ì˜ í•´ìƒë„ê°€ ì´ ìˆ«ìžì˜ ë°°ìˆ˜ê°€ ì•„ë‹ˆë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê±°ë‚˜ ê°€ìž¥ìžë¦¬ê°€ ìž˜ë¦´ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
    *   SD 1.5: ë³´í†µ 8ì˜ ë°°ìˆ˜ ê¶Œìž¥
    *   SDXL: ë³´í†µ 32 ë˜ëŠ” 64ì˜ ë°°ìˆ˜ ê¶Œìž¥
2.  **íƒ€ì¼ë§/ìµœì í™”**: íŠ¹ì • í•˜ë“œì›¨ì–´ë‚˜ ì–´í…ì…˜ ì—°ì‚°ì—ì„œ 64ì˜ ë°°ìˆ˜ì¼ ë•Œ ì„±ëŠ¥ì´ ìµœì í™”ë˜ëŠ” ê²½ìš°ê°€ ìžˆìŠµë‹ˆë‹¤.

### 4. ì˜ˆì‹œ

ë§Œì•½ ê³„ì‚°ëœ ëª©í‘œ í•´ìƒë„ê°€ **1000 x 1000** í”½ì…€ì´ê³ , `resolution_steps`ê°€ **64**ë¼ë©´:

1.  1000 / 64 = 15.625
2.  ë°˜ì˜¬ë¦¼í•˜ë©´ **16**
3.  16 * 64 = **1024**

ê²°ê³¼ì ìœ¼ë¡œ ì´ë¯¸ì§€ëŠ” **1024 x 1024**ë¡œ ë¦¬ì‚¬ì´ì§•ë©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ 64ë¡œ ê¹”ë”í•˜ê²Œ ë‚˜ëˆ„ì–´ë–¨ì–´ì§€ëŠ” í•´ìƒë„ë¥¼ ì–»ì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
ë§Œì•½ì— ë¹„ìœ¨ì´ ì• ë§¤í•˜ê²Œ ì•ˆë‚˜ëˆ ë–¨ì–´ì§€ë©´ ì–´ë–»ê²Œ ë¼?
</userRequest>

Assistant
ë¹„ìœ¨ì´ ì• ë§¤í•˜ê²Œ ë–¨ì–´ì§ˆ ê²½ìš°, **ì´ë¯¸ì§€ì˜ ë¹„ìœ¨ì´ ì•„ì£¼ ë¯¸ì„¸í•˜ê²Œ ê¹¨ì§€ê²Œ ë©ë‹ˆë‹¤ (Stretch/Squash).**

ì½”ë“œì˜ ë™ìž‘ ë°©ì‹ì„ ë‹¨ê³„ë³„ë¡œ ë³´ë©´ ê·¸ ì´ìœ ë¥¼ ì•Œ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

### ë™ìž‘ ì›ë¦¬

1.  **ë…ë¦½ì ì¸ ë°˜ì˜¬ë¦¼**: ê°€ë¡œ(Width)ì™€ ì„¸ë¡œ(Height)ë¥¼ **ê°ê° ë”°ë¡œ** ê³„ì‚°í•´ì„œ `resolution_steps`ì˜ ë°°ìˆ˜ë¡œ ë§žì¶¥ë‹ˆë‹¤.
    ```python
    width = round(ì›ë³¸ê°€ë¡œ * ë¹„ìœ¨ / steps) * steps
    height = round(ì›ë³¸ì„¸ë¡œ * ë¹„ìœ¨ / steps) * steps
    ```
2.  **ê°•ì œ ë¦¬ì‚¬ì´ì§•**: `comfy.utils.common_upscale` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ `crop="disabled"` ì˜µì…˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
    ```python
    s = comfy.utils.common_upscale(..., upscale_method, "disabled")
    ```
    ì´ ì˜µì…˜ì€ "ìžë¥´ê¸°(Crop)"ë¥¼ í•˜ì§€ ì•Šê³ , ì§€ì •ëœ ê°€ë¡œ/ì„¸ë¡œ í”½ì…€ì— ë§žì¶° ì´ë¯¸ì§€ë¥¼ **ëŠ˜ë¦¬ê±°ë‚˜ ì¤„ì—¬ì„œ ê½‰ ì±„ìš´ë‹¤**ëŠ” ëœ»ìž…ë‹ˆë‹¤.

### ì˜ˆì‹œ ìƒí™©

*   **ëª©í‘œ**: ê°€ë¡œ 150px, ì„¸ë¡œ 165pxë¡œ í‚¤ìš°ê³  ì‹¶ìŒ
*   **resolution_steps**: 64

ê³„ì‚° ê²°ê³¼:
*   **ê°€ë¡œ**: 150ì€ 64ì˜ ë°°ìˆ˜ ì¤‘ **128**ì— ê°€ê¹Œì›€ (128ë¡œ ê²°ì •)
*   **ì„¸ë¡œ**: 165ëŠ” 64ì˜ ë°°ìˆ˜ ì¤‘ **192**ì— ê°€ê¹Œì›€ (192ë¡œ ê²°ì •)

**ê²°ê³¼**:
*   ì›ëž˜ ë¹„ìœ¨: 150 : 165 (ì•½ 1 : 1.1)
*   ìµœì¢… ë¹„ìœ¨: 128 : 192 (1 : 1.5)

ê°€ë¡œëŠ” ì¤„ì–´ë“¤ê³  ì„¸ë¡œëŠ” ëŠ˜ì–´ë‚¬ê¸° ë•Œë¬¸ì—, ê²°ê³¼ì ìœ¼ë¡œ ì´ë¯¸ì§€ê°€ **í™€ì­‰í•˜ê²Œ ì°Œê·¸ëŸ¬ì§€ê²Œ(Distortion)** ë©ë‹ˆë‹¤.

### ê²°ë¡ 

`resolution_steps`ê°€ í´ìˆ˜ë¡(ì˜ˆ: 64, 128), ê·¸ë¦¬ê³  ì´ë¯¸ì§€ í•´ìƒë„ê°€ ìž‘ì„ìˆ˜ë¡ ë¹„ìœ¨ ì™œê³¡ì´ ëˆˆì— ëŒ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì¼ë°˜ì ì¸ ê³ í•´ìƒë„ ìƒì„± ìž‘ì—…(1024px ì´ìƒ)ì—ì„œ 8ì´ë‚˜ 16 ì •ë„ì˜ stepsë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ì™œê³¡ì´ ê±°ì˜ ëˆˆì— ë„ì§€ ì•ŠìŠµë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
class ImageResizeKJv2:
    upscale_methods = ["nearest-exact", "bilinear", "area", "bicubic", "lanczos"]
    @classmethod
    def INPUT_TYPES(s):
        return {
            "required": {
                "image": ("IMAGE",),
                "width": ("INT", { "default": 512, "min": 0, "max": MAX_RESOLUTION, "step": 1, }),
                "height": ("INT", { "default": 512, "min": 0, "max": MAX_RESOLUTION, "step": 1, }),
                "upscale_method": (s.upscale_methods,),
                "keep_proportion": (["stretch", "resize", "pad", "pad_edge", "pad_edge_pixel", "crop", "pillarbox_blur", "total_pixels"], { "default": False }),
                "pad_color": ("STRING", { "default": "0, 0, 0", "tooltip": "Color to use for padding."}),
                "crop_position": (["center", "top", "bottom", "left", "right"], { "default": "center" }),
                "divisible_by": ("INT", { "default": 2, "min": 0, "max": 512, "step": 1, }),
            },
            "optional" : {
                "mask": ("MASK",),
                "device": (["cpu", "gpu"],),
                #"per_batch": ("INT", { "default": 0, "min": 0, "max": MAX_RESOLUTION, "step": 1, "tooltip": "Process images in sub-batches to reduce memory usage. 0 disables sub-batching."}),
            },
             "hidden": {
                "unique_id": "UNIQUE_ID",
            },
        }

    RETURN_TYPES = ("IMAGE", "INT", "INT", "MASK",)
    RETURN_NAMES = ("IMAGE", "width", "height", "mask",)
    FUNCTION = "resize"
    CATEGORY = "KJNodes/image"
    DESCRIPTION = """
Resizes the image to the specified width and height.  
Size can be retrieved from the input.

Keep proportions keeps the aspect ratio of the image, by  
highest dimension.  
"""

    def resize(self, image, width, height, keep_proportion, upscale_method, divisible_by, pad_color, crop_position, unique_id, device="cpu", mask=None, per_batch=64):
        B, H, W, C = image.shape

        if device == "gpu":
            if upscale_method == "lanczos":
                raise Exception("Lanczos is not supported on the GPU")
            device = model_management.get_torch_device()
        else:
            device = torch.device("cpu")

        pillarbox_blur = keep_proportion == "pillarbox_blur"
        
        # Initialize padding variables
        pad_left = pad_right = pad_top = pad_bottom = 0

        if keep_proportion in ["resize", "total_pixels"] or keep_proportion.startswith("pad") or pillarbox_blur:
            if keep_proportion == "total_pixels":
                total_pixels = width * height
                aspect_ratio = W / H
                new_height = int(math.sqrt(total_pixels / aspect_ratio))
                new_width = int(math.sqrt(total_pixels * aspect_ratio))
                
            # If one of the dimensions is zero, calculate it to maintain the aspect ratio
            elif width == 0 and height == 0:
                new_width = W
                new_height = H
            elif width == 0 and height != 0:
                ratio = height / H
                new_width = round(W * ratio)
                new_height = height
            elif height == 0 and width != 0:
                ratio = width / W
                new_width = width
                new_height = round(H * ratio)
            elif width != 0 and height != 0:
                ratio = min(width / W, height / H)
                new_width = round(W * ratio)
                new_height = round(H * ratio)
            else:
                new_width = width
                new_height = height

            if keep_proportion.startswith("pad") or pillarbox_blur:
                # Calculate padding based on position
                if crop_position == "center":
                    pad_left = (width - new_width) // 2
                    pad_right = width - new_width - pad_left
                    pad_top = (height - new_height) // 2
                    pad_bottom = height - new_height - pad_top
                elif crop_position == "top":
                    pad_left = (width - new_width) // 2
                    pad_right = width - new_width - pad_left
                    pad_top = 0
                    pad_bottom = height - new_height
                elif crop_position == "bottom":
                    pad_left = (width - new_width) // 2
                    pad_right = width - new_width - pad_left
                    pad_top = height - new_height
                    pad_bottom = 0
                elif crop_position == "left":
                    pad_left = 0
                    pad_right = width - new_width
                    pad_top = (height - new_height) // 2
                    pad_bottom = height - new_height - pad_top
                elif crop_position == "right":
                    pad_left = width - new_width
                    pad_right = 0
                    pad_top = (height - new_height) // 2
                    pad_bottom = height - new_height - pad_top

            width = new_width
            height = new_height
        else:
            if width == 0:
                width = W
            if height == 0:
                height = H

        if divisible_by > 1:
            width = width - (width % divisible_by)
            height = height - (height % divisible_by)

        # Preflight estimate (log-only when batching is active)
        if per_batch != 0 and B > per_batch:
            try:
                bytes_per_elem = image.element_size()  # typically 4 for float32
                est_total_bytes = B * height * width * C * bytes_per_elem
                est_mb = est_total_bytes / (1024 * 1024)
                msg = f"<tr><td>Resize v2</td><td>estimated output ~{est_mb:.2f} MB; batching {per_batch}/{B}</td></tr>"
                if unique_id and PromptServer is not None:
                    try:
                        PromptServer.instance.send_progress_text(msg, unique_id)
                    except:
                        pass
                else:
                    print(f"[ImageResizeKJv2] estimated output ~{est_mb:.2f} MB; batching {per_batch}/{B}")
            except:
                pass

        def _process_subbatch(in_image, in_mask, pad_left, pad_right, pad_top, pad_bottom):
            # Avoid unnecessary clones; only move if needed
            out_image = in_image if in_image.device == device else in_image.to(device)
            out_mask = None if in_mask is None else (in_mask if in_mask.device == device else in_mask.to(device))

            # Crop logic
            if keep_proportion == "crop":
                old_height = out_image.shape[-3]
                old_width = out_image.shape[-2]
                old_aspect = old_width / old_height
                new_aspect = width / height
                if old_aspect > new_aspect:
                    crop_w = round(old_height * new_aspect)
                    crop_h = old_height
                else:
                    crop_w = old_width
                    crop_h = round(old_width / new_aspect)
                if crop_position == "center":
                    x = (old_width - crop_w) // 2
                    y = (old_height - crop_h) // 2
                elif crop_position == "top":
                    x = (old_width - crop_w) // 2
                    y = 0
                elif crop_position == "bottom":
                    x = (old_width - crop_w) // 2
                    y = old_height - crop_h
                elif crop_position == "left":
                    x = 0
                    y = (old_height - crop_h) // 2
                elif crop_position == "right":
                    x = old_width - crop_w
                    y = (old_height - crop_h) // 2
                out_image = out_image.narrow(-2, x, crop_w).narrow(-3, y, crop_h)
                if out_mask is not None:
                    out_mask = out_mask.narrow(-1, x, crop_w).narrow(-2, y, crop_h)

            out_image = common_upscale(out_image.movedim(-1,1), width, height, upscale_method, crop="disabled").movedim(1,-1)
            if out_mask is not None:
                if upscale_method == "lanczos":
                    out_mask = common_upscale(out_mask.unsqueeze(1).repeat(1, 3, 1, 1), width, height, upscale_method, crop="disabled").movedim(1,-1)[:, :, :, 0]
                else:
                    out_mask = common_upscale(out_mask.unsqueeze(1), width, height, upscale_method, crop="disabled").squeeze(1)

            # Pad logic
            if (keep_proportion.startswith("pad") or pillarbox_blur) and (pad_left > 0 or pad_right > 0 or pad_top > 0 or pad_bottom > 0):
                padded_width = width + pad_left + pad_right
                padded_height = height + pad_top + pad_bottom
                if divisible_by > 1:
                    width_remainder = padded_width % divisible_by
                    height_remainder = padded_height % divisible_by
                    if width_remainder > 0:
                        extra_width = divisible_by - width_remainder
                        pad_right += extra_width
                    if height_remainder > 0:
                        extra_height = divisible_by - height_remainder
                        pad_bottom += extra_height

                pad_mode = (
                    "pillarbox_blur" if pillarbox_blur else
                    "edge" if keep_proportion == "pad_edge" else
                    "edge_pixel" if keep_proportion == "pad_edge_pixel" else
                    "color"
                )
                out_image, out_mask = ImagePadKJ.pad(self, out_image, pad_left, pad_right, pad_top, pad_bottom, 0, pad_color, pad_mode, mask=out_mask)

            return out_image, out_mask

        # If batching disabled (per_batch==0) or batch fits, process whole batch
        if per_batch == 0 or B <= per_batch:
            out_image, out_mask = _process_subbatch(image, mask, pad_left, pad_right, pad_top, pad_bottom)
        else:
            chunks = []
            mask_chunks = [] if mask is not None else None
            total_batches = (B + per_batch - 1) // per_batch
            current_batch = 0
            for start_idx in range(0, B, per_batch):
                current_batch += 1
                end_idx = min(start_idx + per_batch, B)
                sub_img = image[start_idx:end_idx]
                sub_mask = mask[start_idx:end_idx] if mask is not None else None
                sub_out_img, sub_out_mask = _process_subbatch(sub_img, sub_mask, pad_left, pad_right, pad_top, pad_bottom)
                chunks.append(sub_out_img.cpu())
                if mask is not None:
                    mask_chunks.append(sub_out_mask.cpu() if sub_out_mask is not None else None)
                # Per-batch progress update
                if unique_id and PromptServer is not None:
                    try:
                        PromptServer.instance.send_progress_text(
                            f"<tr><td>Resize v2</td><td>batch {current_batch}/{total_batches} Â· images {end_idx}/{B}</td></tr>",
                            unique_id
                        )
                    except:
                        pass
                else:
                    try:
                        print(f"[ImageResizeKJv2] batch {current_batch}/{total_batches} Â· images {end_idx}/{B}")
                    except:
                        pass
            out_image = torch.cat(chunks, dim=0)
            if mask is not None and any(m is not None for m in mask_chunks):
                out_mask = torch.cat([m for m in mask_chunks if m is not None], dim=0)
            else:
                out_mask = None

        # Progress UI
        if unique_id and PromptServer is not None:
            try:
                num_elements = out_image.numel()
                element_size = out_image.element_size()
                memory_size_mb = (num_elements * element_size) / (1024 * 1024)
                PromptServer.instance.send_progress_text(
                    f"<tr><td>Output: </td><td><b>{out_image.shape[0]}</b> x <b>{out_image.shape[2]}</b> x <b>{out_image.shape[1]} | {memory_size_mb:.2f}MB</b></td></tr>",
                    unique_id
                )
            except:
                pass

        return (out_image.cpu(), out_image.shape[2], out_image.shape[1], out_mask.cpu() if out_mask is not None else torch.zeros(64,64, device=torch.device("cpu"), dtype=torch.float32))


ì´ ë…¸ë“œë„ ì„¤ëª…í•´ì¤˜
</userRequest>

Assistant
`ImageResizeKJv2` ë…¸ë“œëŠ” ì´ë¯¸ì§€ë¥¼ ë¦¬ì‚¬ì´ì§•í•˜ëŠ” ë§¤ìš° ê°•ë ¥í•˜ê³  ë‹¤ì–‘í•œ ì˜µì…˜ì„ ì œê³µí•˜ëŠ” ë…¸ë“œìž…ë‹ˆë‹¤. ë‹¨ìˆœí•œ í¬ê¸° ì¡°ì ˆë¿ë§Œ ì•„ë‹ˆë¼ ë¹„ìœ¨ ìœ ì§€, íŒ¨ë”©(ì—¬ë°± ì±„ìš°ê¸°), ìžë¥´ê¸°(Crop), ë°°ì¹˜ ì²˜ë¦¬ ë“± ê³ ê¸‰ ê¸°ëŠ¥ì„ í¬í•¨í•˜ê³  ìžˆìŠµë‹ˆë‹¤.

### ì£¼ìš” ê¸°ëŠ¥ ìš”ì•½

1.  **ë‹¤ì–‘í•œ ë¦¬ì‚¬ì´ì§• ëª¨ë“œ (`keep_proportion`)**:
    *   `False` (ê¸°ë³¸ê°’): ì§€ì •ëœ `width`, `height`ë¡œ ê°•ì œ ë³€í™˜ (ë¹„ìœ¨ ê¹¨ì§).
    *   `stretch`: `False`ì™€ ë™ì¼ (ëŠ˜ë¦¬ê¸°).
    *   `resize`: ë¹„ìœ¨ì„ ìœ ì§€í•˜ë©´ì„œ ì§€ì •ëœ í¬ê¸° ì•ˆì— ë“¤ì–´ì˜¤ë„ë¡ ë¦¬ì‚¬ì´ì§• (ë¹ˆ ê³µê°„ ì—†ìŒ, í¬ê¸°ê°€ ìž‘ì•„ì§ˆ ìˆ˜ ìžˆìŒ).
    *   `pad`: ë¹„ìœ¨ì„ ìœ ì§€í•˜ë©° ë¦¬ì‚¬ì´ì§•í•˜ê³ , ë‚¨ëŠ” ê³µê°„ì„ ì§€ì •ëœ ìƒ‰(`pad_color`)ìœ¼ë¡œ ì±„ì›€.
    *   `pad_edge`: ë‚¨ëŠ” ê³µê°„ì„ ì´ë¯¸ì§€ì˜ ê°€ìž¥ìžë¦¬ ìƒ‰ìœ¼ë¡œ ì±„ì›€.
    *   `pad_edge_pixel`: ë‚¨ëŠ” ê³µê°„ì„ ê°€ìž¥ìžë¦¬ í”½ì…€ í•˜ë‚˜ë¥¼ ëŠ˜ë ¤ì„œ ì±„ì›€.
    *   `crop`: ë¹„ìœ¨ì„ ìœ ì§€í•˜ë©° ë¦¬ì‚¬ì´ì§•í•˜ë˜, ì§€ì •ëœ í¬ê¸°ë¥¼ ê½‰ ì±„ìš°ë„ë¡ í™•ëŒ€í•œ í›„ ë„˜ì¹˜ëŠ” ë¶€ë¶„ì„ ìž˜ë¼ëƒ„.
    *   `pillarbox_blur`: ë‚¨ëŠ” ê³µê°„ì„ ì›ë³¸ ì´ë¯¸ì§€ë¥¼ íë¦¬ê²Œ ì²˜ë¦¬í•˜ì—¬ ì±„ì›€ (ìœ íŠœë¸Œ ì„¸ë¡œ ì˜ìƒ ì¢Œìš° ì—¬ë°± ì²˜ë¦¬ ë°©ì‹).
    *   `total_pixels`: ê°€ë¡œ/ì„¸ë¡œ ê¸¸ì´ë¥¼ ì§ì ‘ ì§€ì •í•˜ëŠ” ëŒ€ì‹ , ì´ í”½ì…€ ìˆ˜(ë©´ì )ë¥¼ ìœ ì§€í•˜ë©´ì„œ ë¹„ìœ¨ì— ë§žì¶° ë¦¬ì‚¬ì´ì§•.

2.  **í¬ê¸° ë° ë¹„ìœ¨ ì œì–´**:
    *   `width`, `height`: ëª©í‘œ í•´ìƒë„. 0ìœ¼ë¡œ ì„¤ì •í•˜ë©´ ì›ë³¸ í¬ê¸° ìœ ì§€ ë˜ëŠ” ë¹„ìœ¨ì— ë§žì¶° ìžë™ ê³„ì‚°.
    *   `divisible_by`: ìµœì¢… í•´ìƒë„ê°€ íŠ¹ì • ìˆ«ìžì˜ ë°°ìˆ˜ê°€ ë˜ë„ë¡ ê°•ì œ (ì˜ˆ: 64ì˜ ë°°ìˆ˜).
    *   `crop_position`: `crop` ë˜ëŠ” `pad` ëª¨ë“œì¼ ë•Œ ì´ë¯¸ì§€ì˜ ìœ„ì¹˜ (ì¤‘ì•™, ìƒí•˜ì¢Œìš°).

3.  **ì„±ëŠ¥ ë° ìµœì í™”**:
    *   `upscale_method`: ë¦¬ì‚¬ì´ì§• ì•Œê³ ë¦¬ì¦˜ ì„ íƒ (nearest, bilinear, bicubic, lanczos ë“±).
    *   `device`: CPU ë˜ëŠ” GPU ì„ íƒ ê°€ëŠ¥.
    *   `per_batch`: ë©”ëª¨ë¦¬ ë¶€ì¡± ë°©ì§€ë¥¼ ìœ„í•´ í° ë°°ì¹˜ë¥¼ ë‚˜ëˆ„ì–´ì„œ ì²˜ë¦¬í•˜ëŠ” ê¸°ëŠ¥.

4.  **ë§ˆìŠ¤í¬ ì²˜ë¦¬**:
    *   ì´ë¯¸ì§€ì™€ í•¨ê»˜ ë§ˆìŠ¤í¬(`mask`)ë„ ë™ì¼í•˜ê²Œ ë¦¬ì‚¬ì´ì§•/ë³€í˜•í•˜ì—¬ ì¶œë ¥.

### ì½”ë“œ ë¶„ì„ í¬ì¸íŠ¸

*   **ë¹„ìœ¨ ê³„ì‚° ë¡œì§**: `keep_proportion` ì˜µì…˜ì— ë”°ë¼ `new_width`, `new_height`ë¥¼ ê³„ì‚°í•˜ê³ , í•„ìš”í•œ ê²½ìš° `pad_left`, `pad_top` ë“±ì˜ íŒ¨ë”© ê°’ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
*   **ë°°ì¹˜ ì²˜ë¦¬ (`_process_subbatch`)**: ë©”ëª¨ë¦¬ íš¨ìœ¨ì„ ìœ„í•´ ì „ì²´ ë°°ì¹˜ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬í•˜ì§€ ì•Šê³ , `per_batch` ê°œìˆ˜ë§Œí¼ ë‚˜ëˆ„ì–´ ì²˜ë¦¬í•œ ë’¤ ë‹¤ì‹œ í•©ì¹©ë‹ˆë‹¤(`torch.cat`).
*   **UI í”¼ë“œë°±**: `PromptServer`ë¥¼ í†µí•´ í˜„ìž¬ ì§„í–‰ ìƒí™©(ë°°ì¹˜ ì²˜ë¦¬ í˜„í™©)ê³¼ ì˜ˆìƒ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ComfyUI ì¸í„°íŽ˜ì´ìŠ¤ì— í‘œì‹œí•©ë‹ˆë‹¤.

### ê²°ë¡ 

ì´ ë…¸ë“œëŠ” ë‹¨ìˆœ ë¦¬ì‚¬ì´ì§•ì´ ì•„ë‹ˆë¼, **"ì›í•˜ëŠ” í•´ìƒë„ë¡œ ë§žì¶”ë˜, ë¹„ìœ¨ì´ ì•ˆ ë§žì„ ë•Œ ì–´ë–»ê²Œ ì²˜ë¦¬í•  ê²ƒì¸ê°€?"**ì— ëŒ€í•œ ëª¨ë“  ì†”ë£¨ì…˜ì„ ì œê³µí•˜ëŠ” ì˜¬ì¸ì› ë¦¬ì‚¬ì´ì§• ë…¸ë“œìž…ë‹ˆë‹¤. í•™ìŠµ ë°ì´í„° ì „ì²˜ë¦¬ë‚˜ ë‹¤ì–‘í•œ ë¹„ìœ¨ì˜ ì´ë¯¸ì§€ë¥¼ ê³ ì •ëœ í•´ìƒë„ë¡œ ë§žì¶œ ë•Œ ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
768x768 ì´ë¯¸ì§€ë¥¼ crop 512, 320, divisible_by 16ìœ¼ë¡œ í•˜ë‹ˆ

```
  File "C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI\execution.py", line 516, in execute
    output_data, output_ui, has_subgraph, has_pending_tasks = await get_output_data(prompt_id, unique_id, obj, input_data_all, execution_block_cb=execution_block_cb, pre_execute_cb=pre_execute_cb, v3_data=v3_data)
                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI\execution.py", line 330, in get_output_data
    return_values = await _async_map_node_over_list(prompt_id, unique_id, obj, input_data_all, obj.FUNCTION, allow_interrupt=True, execution_block_cb=execution_block_cb, pre_execute_cb=pre_execute_cb, v3_data=v3_data)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI\execution.py", line 304, in _async_map_node_over_list
    await process_inputs(input_dict, i)

  File "C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI\execution.py", line 292, in process_inputs
    result = f(**inputs)
             ^^^^^^^^^^^

  File "C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI\custom_nodes\comfyui-kjnodes\nodes\image_nodes.py", line 2755, in resize
    out_image, out_mask = _process_subbatch(image, mask, pad_left, pad_right, pad_top, pad_bottom)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI\custom_nodes\comfyui-kjnodes\nodes\image_nodes.py", line 2720, in _process_subbatch
    out_mask = out_mask.narrow(-1, x, crop_w).narrow(-2, y, crop_h)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ì´ëŸ° ì—ëŸ¬ê°€ ë‚˜ëŠ” ì´ìœ 
</userRequest>

Assistant
ì´ ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ” ê°€ìž¥ ìœ ë ¥í•œ ì›ì¸ì€ **ìž…ë ¥ëœ ë§ˆìŠ¤í¬(Mask)ì˜ í•´ìƒë„ê°€ ìž…ë ¥ ì´ë¯¸ì§€(Image)ì˜ í•´ìƒë„(768x768)ì™€ ë‹¤ë¥´ê¸° ë•Œë¬¸**ìž…ë‹ˆë‹¤.

### ìƒì„¸ ë¶„ì„

1.  **ì—ëŸ¬ ë°œìƒ ì§€ì **:
    ```python
    out_mask = out_mask.narrow(-1, x, crop_w).narrow(-2, y, crop_h)
    ```
    ì´ ì½”ë“œëŠ” ì´ë¯¸ì§€ì—ì„œ ê³„ì‚°ëœ "ìž˜ë¼ë‚¼ ì˜ì—­(Crop Region)"ì„ ë§ˆìŠ¤í¬ì—ë„ ë˜‘ê°™ì´ ì ìš©í•˜ì—¬ ìžë¥´ëŠ” ë¶€ë¶„ìž…ë‹ˆë‹¤.

2.  **ê³„ì‚°ëœ ìžë¥´ê¸° ì˜ì—­**:
    *   ìž…ë ¥ ì´ë¯¸ì§€: 768x768
    *   ëª©í‘œ ë¹„ìœ¨: 512x320 (1.6 : 1)
    *   `crop` ëª¨ë“œ ë¡œì§ì— ë”°ë¼, 768x768 ì´ë¯¸ì§€ì—ì„œ **768x480** í¬ê¸°ì˜ ì˜ì—­ì„ ìž˜ë¼ë‚´ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤.
        *   ê°€ë¡œ(`crop_w`): 768 (ê½‰ ì±„ì›€)
        *   ì„¸ë¡œ(`crop_h`): 480 (ë¹„ìœ¨ì— ë§žì¶¤)

3.  **ì›ì¸**:
    *   ë…¸ë“œëŠ” **ì´ë¯¸ì§€ì˜ í¬ê¸°(768x768)**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ "ê°€ë¡œ 768ë§Œí¼, ì„¸ë¡œ 480ë§Œí¼ ìž˜ë¼ë¼"ë¼ê³  ëª…ë ¹ì„ ë‚´ë¦½ë‹ˆë‹¤.
    *   ê·¸ëŸ°ë° ë§Œì•½ **ì—°ê²°ëœ ë§ˆìŠ¤í¬ì˜ í¬ê¸°ê°€ 768x768ë³´ë‹¤ ìž‘ë‹¤ë©´** (ì˜ˆ: 512x512 ë§ˆìŠ¤í¬ê°€ ì—°ê²°ë˜ì–´ ìžˆë‹¤ë©´), ë§ˆìŠ¤í¬ì—ì„œ 768ë§Œí¼ì„ ìž˜ë¼ë‚¼ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `narrow` í•¨ìˆ˜ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ë‹¤ëŠ” ì—ëŸ¬ë¥¼ ë±‰ê²Œ ë©ë‹ˆë‹¤.

### í•´ê²° ë°©ë²•

ì—°ê²°ëœ **`mask` í•€ì— ë“¤ì–´ì˜¤ëŠ” ë§ˆìŠ¤í¬ì˜ í•´ìƒë„ë¥¼ í™•ì¸**í•´ë³´ì„¸ìš”.
ìž…ë ¥ ì´ë¯¸ì§€(768x768)ì™€ ë™ì¼í•œ í¬ê¸°ì˜ ë§ˆìŠ¤í¬ê°€ ë“¤ì–´ì™€ì•¼ ì •ìƒì ìœ¼ë¡œ ìž‘ë™í•©ë‹ˆë‹¤. ë§Œì•½ ë‹¤ë¥¸ ê³³ì—ì„œ ìƒì„±ëœ ìž‘ì€ ë§ˆìŠ¤í¬ë¥¼ ì—°ê²°í–ˆë‹¤ë©´, ë§ˆìŠ¤í¬ë¥¼ ë¨¼ì € ì´ë¯¸ì§€ í¬ê¸°ì— ë§žì¶° ë¦¬ì‚¬ì´ì¦ˆ(Upscale)í•œ í›„ ì—°ê²°í•´ì•¼ í•©ë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\COMFYUI_RAW_DOCS.md. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
Load Image Nodeì—ì„œ ë§ˆìŠ¤í¬ë¥¼ ì•ˆê·¸ë¦¬ë©´ ê·¸ëƒ¥ 64x64ì˜ ê¹Œë§Œ ë§ˆìŠ¤í¬ê°€ ë¦¬í„´ì´ ë˜ë„¤.
ì´ê±´ ì¢€ ë²„ê·¸ ê°™ì€ë°...

ê·¸ëŸ¬ë©´ ì´ëŸ° ë…¸ë“œë¥¼ ë§Œë“¤ì–´ì¤˜.
ì´ë¯¸ì§€ì™€ ë§ˆìŠ¤í¬ë¥¼ ìž…ë ¥ë°›ì•„ì„œ ì´ë¯¸ì§€ í¬ê¸°ì˜ ë§ˆìŠ¤í¬ í¬ê¸°ê°€ ë‹¤ë¥´ë©´ ê·¸ëƒ¥ ì´ë¯¸ì§€ í¬ê¸°ì˜ ê¹Œë§Œ ë§ˆìŠ¤í¬ë¡œ ë¦¬í„´, ì´ë¯¸ì§€ëŠ” ê·¸ëŒ€ë¡œ ë¦¬í„´
</userRequest>

Assistant

ðŸ› ï¸ read_file (call_MHxhTjVxUkZzNXlLMXZKcTBqYW8) {
  "endLine": 50,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\hvppy_mask_nodes.py",
  "startLine": 1
}
Tool
ðŸ› ï¸ call_MHxhTjVxUkZzNXlLMXZKcTBqYW8
```python
import torch

MAX_RESOLUTION = 8192

class CreateFullMask:
    @classmethod
    def INPUT_TYPES(s):
        return {
            "required": {
                "width": ("INT", {"default": 512, "min": 1, "max": MAX_RESOLUTION, "step": 1}),
                "height": ("INT", {"default": 512, "min": 1, "max": MAX_RESOLUTION, "step": 1}),
            }
        }

    RETURN_TYPES = ("MASK",)
    FUNCTION = "create_mask"
    CATEGORY = "Hvppy/Masking"
    DESCRIPTION = "Creates a full (white) mask of the specified dimensions."

    def create_mask(self, width, height):
        # Create a mask of shape (1, height, width) filled with 1.0
        # ComfyUI masks are typically (B, H, W) float32 in range [0, 1]
        mask = torch.ones((1, height, width), dtype=torch.float32, device="cpu")
        return (mask,)

```
Assistant

ðŸ› ï¸ read_file (call_MHxQY3VHdnNpZHlaYUN6NzUybHg) {
  "endLine": 20,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\__init__.py",
  "startLine": 1
}
Tool
ðŸ› ï¸ call_MHxQY3VHdnNpZHlaYUN6NzUybHg
```python
from .hvppy_mask_nodes import CreateFullMask

NODE_CLASS_MAPPINGS = {
    "HvppyCreateFullMask": CreateFullMask
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "HvppyCreateFullMask": "Create Full Mask"
}

__all__ = ["NODE_CLASS_MAPPINGS", "NODE_DISPLAY_NAME_MAPPINGS"]

```
Assistant

ðŸ› ï¸ read_file (call_MHxFWTFnVG5XSXB1NUFORDd0blE) {
  "endLine": 100,
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\hvppy_mask_nodes.py",
  "startLine": 1
}
Tool
ðŸ› ï¸ call_MHxFWTFnVG5XSXB1NUFORDd0blE
```python
import torch

MAX_RESOLUTION = 8192

class CreateFullMask:
    @classmethod
    def INPUT_TYPES(s):
        return {
            "required": {
                "width": ("INT", {"default": 512, "min": 1, "max": MAX_RESOLUTION, "step": 1}),
                "height": ("INT", {"default": 512, "min": 1, "max": MAX_RESOLUTION, "step": 1}),
            }
        }

    RETURN_TYPES = ("MASK",)
    FUNCTION = "create_mask"
    CATEGORY = "Hvppy/Masking"
    DESCRIPTION = "Creates a full (white) mask of the specified dimensions."

    def create_mask(self, width, height):
        # Create a mask of shape (1, height, width) filled with 1.0
        # ComfyUI masks are typically (B, H, W) float32 in range [0, 1]
        mask = torch.ones((1, height, width), dtype=torch.float32, device="cpu")
        return (mask,)

```
Assistant

ðŸ› ï¸ replace_string_in_file (call_MHwzVTN4c2dXTUdsZDhjNWJUcDk) {
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\hvppy_mask_nodes.py",
  "newString": "    def create_mask(self, width, height):
        # Create a mask of shape (1, height, width) filled with 1.0
        # ComfyUI masks are typically (B, H, W) float32 in range [0, 1]
        mask = torch.ones((1, height, width), dtype=torch.float32, device=\"cpu\")
        return (mask,)


class MaskSizeMatch:
    @classmethod
    def INPUT_TYPES(s):
        return {
            \"required\": {
                \"image\": (\"IMAGE\",),
            },
            \"optional\": {
                \"mask\": (\"MASK\",),
            }
        }

    RETURN_TYPES = (\"IMAGE\", \"MASK\")
    FUNCTION = \"match\"
    CATEGORY = \"Hvppy/Masking\"
    DESCRIPTION = \"Checks if the mask matches the image size. If not (or if mask is missing), returns a black mask of the image size.\"

    def match(self, image, mask=None):
        # image shape: [B, H, W, C]
        B, H, W, C = image.shape
        
        if mask is None:
            # Create black mask [B, H, W]
            new_mask = torch.zeros((B, H, W), dtype=torch.float32, device=image.device)
            return (image, new_mask)
            
        # mask shape can be [H, W] or [B, H, W]
        # Check dimensions
        m_h = mask.shape[-2]
        m_w = mask.shape[-1]
        
        if m_h != H or m_w != W:
            print(f\"[MaskSizeMatch] Mask size ({m_w}x{m_h}) does not match image size ({W}x{H}). Returning black mask.\")
            new_mask = torch.zeros((B, H, W), dtype=torch.float32, device=image.device)
            return (image, new_mask)
            
        return (image, mask)
",
  "oldString": "    def create_mask(self, width, height):
        # Create a mask of shape (1, height, width) filled with 1.0
        # ComfyUI masks are typically (B, H, W) float32 in range [0, 1]
        mask = torch.ones((1, height, width), dtype=torch.float32, device=\"cpu\")
        return (mask,)
"
}
Tool
ðŸ› ï¸ call_MHwzVTN4c2dXTUdsZDhjNWJUcDk
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\hvppy_mask_nodes.py

Assistant

ðŸ› ï¸ replace_string_in_file (call_MHxVRkhEREVvejNYQkFjc05IQjM) {
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\__init__.py",
  "newString": "from .hvppy_mask_nodes import CreateFullMask, MaskSizeMatch

NODE_CLASS_MAPPINGS = {
    \"HvppyCreateFullMask\": CreateFullMask,
    \"HvppyMaskSizeMatch\": MaskSizeMatch
}

NODE_DISPLAY_NAME_MAPPINGS = {
    \"HvppyCreateFullMask\": \"Create Full Mask\",
    \"HvppyMaskSizeMatch\": \"Mask Size Match (Image)\"
}
",
  "oldString": "from .hvppy_mask_nodes import CreateFullMask

NODE_CLASS_MAPPINGS = {
    \"HvppyCreateFullMask\": CreateFullMask
}

NODE_DISPLAY_NAME_MAPPINGS = {
    \"HvppyCreateFullMask\": \"Create Full Mask\"
}
"
}
Tool
ðŸ› ï¸ call_MHxVRkhEREVvejNYQkFjc05IQjM
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\__init__.py

Assistant
ìš”ì²­í•˜ì‹  ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ëŠ” `Mask Size Match (Image)` ë…¸ë“œë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.

### ì¶”ê°€ëœ ë…¸ë“œ ì •ë³´
*   **ë…¸ë“œ ì´ë¦„**: `Mask Size Match (Image)` (ë‚´ë¶€ ID: `HvppyMaskSizeMatch`)
*   **ì¹´í…Œê³ ë¦¬**: `Hvppy/Masking`
*   **ê¸°ëŠ¥**:
    *   `image`ì™€ `mask`ë¥¼ ìž…ë ¥ë°›ìŠµë‹ˆë‹¤.
    *   ë§Œì•½ `mask`ê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ê±°ë‚˜, `mask`ì˜ í¬ê¸°ê°€ `image`ì˜ í¬ê¸°ì™€ ë‹¤ë¥¼ ê²½ìš°:
        *   ì´ë¯¸ì§€ í¬ê¸°ì™€ ë™ì¼í•œ **ê²€ì€ìƒ‰(0) ë§ˆìŠ¤í¬**ë¥¼ ìƒì„±í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
        *   ì´ë¯¸ì§€ëŠ” ê·¸ëŒ€ë¡œ í†µê³¼ì‹œí‚µë‹ˆë‹¤.
    *   ë§Œì•½ `mask`ì˜ í¬ê¸°ê°€ `image`ì™€ ê°™ë‹¤ë©´:
        *   ìž…ë ¥ëœ ë§ˆìŠ¤í¬ë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

ì´ì œ ComfyUIë¥¼ ìž¬ì‹œìž‘í•˜ì‹œë©´ í•´ë‹¹ ë…¸ë“œë¥¼ ì‚¬ìš©í•˜ì‹¤ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. `Load Image` ë…¸ë“œ ë’¤ì— ì´ ë…¸ë“œë¥¼ ì—°ê²°í•˜ë©´ ë§ˆìŠ¤í¬ í¬ê¸° ë¶ˆì¼ì¹˜ë¡œ ì¸í•œ ì—ëŸ¬ë¥¼ ë°©ì§€í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS.md. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
ì¢‹ì•„. ì´ì œ ì•žì—ì„œ ë§í•œ
ImageScaleToTotalPixelsì™€ Resize Image v2ì˜ ê¸°ëŠ¥ì„ í•©ì¹œ ë…¸ë“œë¥¼ ë§Œë“¤ê³  ì‹¶ì–´.

ê¸°ë³¸ì ì¸ ë™ìž‘ì€ ImageScaleToTotalPixelsì™€ ê°™ì•„.
megapixelsë¥¼ ìž…ë ¥ë°›ì•„ ìµœëŒ€í•œ proportionì„ ìœ ì§€í•˜ë©° divisible_by(resolution_steps)ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ê²Œ ë§žì¶œê±°ì•¼.
ê·¸ ë•Œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ì§€ ì•ŠëŠ” ë¶€ë¶„ì€ crop centerë¥¼ ê¸°ë³¸ìœ¼ë¡œ ë„£ì–´ì£¼ê³ , ë‚˜ë¨¸ì§€ ë‹¤ë¥¸ ìœ ìš©í•œ ë°©ì‹ë“¤ë„ ì„ íƒí•  ìˆ˜ ìžˆê²Œ ë„£ì–´ì¤˜. ë‹¨, PADëŠ” êµ³ì´ í•„ìš” ì—†ì„ ê²ƒ ê°™ì•„.

ë‚´ê°€ ìƒê°í•˜ëŠ” ì¸í’‹ì€ ë‹¤ìŒê³¼ ê°™ì•„.
ë…¸ë“œëª…: HP - Scale Image
- image
- mask
- upscale_method: ë‹¨,ê°€ìž¥ ì¢‹ì€ í€„ë¦¬í‹° ë°©ë²•ì„ ê¸°ë³¸ìœ¼ë¡œ ì„ íƒë˜ê²Œ
- megapixels
- divisible_by:
- proportion_by: crop, stretch
- crop_position: center ê¸°ë³¸

ë¦¬í„´:
- IMAGE
- MASK
</userRequest>

Assistant

ðŸ› ï¸ create_file (call_MHxYVmF5dVNkWHFFQmg5U29iOWs) {
  "content": "import torch
import math
import comfy.utils

class ScaleImage:
    upscale_methods = [\"nearest-exact\", \"bilinear\", \"area\", \"bicubic\", \"lanczos\"]
    crop_positions = [\"center\", \"top\", \"bottom\", \"left\", \"right\"]

    @classmethod
    def INPUT_TYPES(s):
        return {
            \"required\": {
                \"image\": (\"IMAGE\",),
                \"upscale_method\": (s.upscale_methods, {\"default\": \"bicubic\"}),
                \"megapixels\": (\"FLOAT\", {\"default\": 1.0, \"min\": 0.01, \"max\": 16.0, \"step\": 0.01}),
                \"divisible_by\": (\"INT\", {\"default\": 64, \"min\": 1, \"max\": 512, \"step\": 1}),
                \"proportion_by\": ([\"crop\", \"stretch\"], {\"default\": \"crop\"}),
                \"crop_position\": (s.crop_positions, {\"default\": \"center\"}),
            },
            \"optional\": {
                \"mask\": (\"MASK\",),
            }
        }

    RETURN_TYPES = (\"IMAGE\", \"MASK\")
    FUNCTION = \"scale\"
    CATEGORY = \"Hvppy/Image\"
    DESCRIPTION = \"Scales image to target megapixels while keeping aspect ratio and divisibility.\"

    def scale(self, image, upscale_method, megapixels, divisible_by, proportion_by, crop_position, mask=None):
        # image: [B, H, W, C]
        B, H, W, C = image.shape
        
        # Target dimensions calculation
        total_pixels = megapixels * 1024 * 1024
        scale_by = math.sqrt(total_pixels / (W * H))
        
        target_width = round(W * scale_by / divisible_by) * divisible_by
        target_height = round(H * scale_by / divisible_by) * divisible_by
        
        # Ensure at least divisible_by size
        if target_width == 0: target_width = divisible_by
        if target_height == 0: target_height = divisible_by

        # Process Image
        # Move to channel first for common_upscale: [B, C, H, W]
        samples = image.movedim(-1, 1)
        
        # Prepare Mask if exists
        if mask is not None:
            # Mask: [B, H, W] -> [B, 1, H, W] for upscale
            mask_samples = mask.unsqueeze(1)
        else:
            mask_samples = None

        if proportion_by == \"stretch\":
            # Just resize to target
            s = comfy.utils.common_upscale(samples, target_width, target_height, upscale_method, \"disabled\")
            
            if mask_samples is not None:
                m = comfy.utils.common_upscale(mask_samples, target_width, target_height, upscale_method, \"disabled\")
                out_mask = m.squeeze(1)
            else:
                out_mask = torch.zeros((B, target_height, target_width), dtype=torch.float32, device=\"cpu\")

        else: # crop
            # Calculate intermediate size to cover target while maintaining aspect ratio
            target_ratio = target_width / target_height
            current_ratio = W / H
            
            if target_ratio > current_ratio:
                # Target is wider. Match width, height will be larger than target.
                resize_width = target_width
                resize_height = round(target_width / current_ratio)
            else:
                # Target is taller. Match height, width will be larger than target.
                resize_width = round(target_height * current_ratio)
                resize_height = target_height
                
            # 1. Resize to intermediate size
            s = comfy.utils.common_upscale(samples, resize_width, resize_height, upscale_method, \"disabled\")
            
            if mask_samples is not None:
                m = comfy.utils.common_upscale(mask_samples, resize_width, resize_height, upscale_method, \"disabled\")
            
            # 2. Crop to target size
            # s is [B, C, H, W]
            current_h = s.shape[2]
            current_w = s.shape[3]
            
            crop_w = target_width
            crop_h = target_height
            
            if crop_position == \"center\":
                x = (current_w - crop_w) // 2
                y = (current_h - crop_h) // 2
            elif crop_position == \"top\":
                x = (current_w - crop_w) // 2
                y = 0
            elif crop_position == \"bottom\":
                x = (current_w - crop_w) // 2
                y = current_h - crop_h
            elif crop_position == \"left\":
                x = 0
                y = (current_h - crop_h) // 2
            elif crop_position == \"right\":
                x = current_w - crop_w
                y = (current_h - crop_h) // 2
            
            # Clamp x, y to be safe
            x = max(0, min(x, current_w - crop_w))
            y = max(0, min(y, current_h - crop_h))
            
            s = s.narrow(3, x, crop_w).narrow(2, y, crop_h)
            
            if mask_samples is not None:
                m = m.narrow(3, x, crop_w).narrow(2, y, crop_h)
                out_mask = m.squeeze(1)
            else:
                out_mask = torch.zeros((B, target_height, target_width), dtype=torch.float32, device=\"cpu\")

        # Clamp values to valid range
        s = torch.clamp(s, 0.0, 1.0)
        if mask is not None: # Only clamp mask if it was processed from input
            out_mask = torch.clamp(out_mask, 0.0, 1.0)

        # Move back to [B, H, W, C]
        out_image = s.movedim(1, -1)
        
        return (out_image, out_mask)
",
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\hvppy_image_nodes.py"
}
Tool
ðŸ› ï¸ call_MHxYVmF5dVNkWHFFQmg5U29iOWs
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\hvppy_image_nodes.py

Assistant

ðŸ› ï¸ replace_string_in_file (call_MHx1MUlLdEtvdU1sQmNIWjAxeUw) {
  "filePath": "c:\\Workbench\\20_Projects\\custom_nodes\\Hvppy-Nodes\\__init__.py",
  "newString": "from .hvppy_mask_nodes import CreateFullMask, MaskSizeMatch
from .hvppy_image_nodes import ScaleImage

NODE_CLASS_MAPPINGS = {
    \"HvppyCreateFullMask\": CreateFullMask,
    \"HvppyMaskSizeMatch\": MaskSizeMatch,
    \"HvppyScaleImage\": ScaleImage
}

NODE_DISPLAY_NAME_MAPPINGS = {
    \"HvppyCreateFullMask\": \"HP - Create Full Mask\",
    \"HvppyMaskSizeMatch\": \"HP - Mask Size Match (Image)\",
    \"HvppyScaleImage\": \"HP - Scale Image\"
}
",
  "oldString": "from .hvppy_mask_nodes import CreateFullMask, MaskSizeMatch

NODE_CLASS_MAPPINGS = {
    \"HvppyCreateFullMask\": CreateFullMask,
    \"HvppyMaskSizeMatch\": MaskSizeMatch
}

NODE_DISPLAY_NAME_MAPPINGS = {
    \"HvppyCreateFullMask\": \"Create Full Mask\",
    \"HvppyMaskSizeMatch\": \"Mask Size Match (Image)\"
}
"
}
Tool
ðŸ› ï¸ call_MHx1MUlLdEtvdU1sQmNIWjAxeUw
The following files were successfully edited:
c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\__init__.py

Assistant
ìš”ì²­í•˜ì‹  `HP - Scale Image` ë…¸ë“œë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤.

### ë…¸ë“œ ì •ë³´
*   **ë…¸ë“œ ì´ë¦„**: `HP - Scale Image` (ë‚´ë¶€ ID: `HvppyScaleImage`)
*   **ì¹´í…Œê³ ë¦¬**: `Hvppy/Image`
*   **ê¸°ëŠ¥**:
    *   `megapixels`ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ë¯¸ì§€ í¬ê¸°ë¥¼ ì¡°ì ˆí•©ë‹ˆë‹¤.
    *   `divisible_by`ë¡œ ì§€ì •ëœ ìˆ«ìžì˜ ë°°ìˆ˜ë¡œ í•´ìƒë„ë¥¼ ë§žì¶¥ë‹ˆë‹¤.
    *   `proportion_by` ì˜µì…˜ìœ¼ë¡œ ë¹„ìœ¨ ì²˜ë¦¬ ë°©ì‹ì„ ì„ íƒí•©ë‹ˆë‹¤.
        *   `crop`: ë¹„ìœ¨ì„ ìœ ì§€í•˜ë©° ê½‰ ì±„ìš´ í›„ ë„˜ì¹˜ëŠ” ë¶€ë¶„ì„ ìž˜ë¼ëƒ…ë‹ˆë‹¤. (`crop_position`ìœ¼ë¡œ ìœ„ì¹˜ ì¡°ì •)
        *   `stretch`: ë¹„ìœ¨ì„ ë¬´ì‹œí•˜ê³  ê°•ì œë¡œ ëŠ˜ë¦½ë‹ˆë‹¤.
    *   `mask`ê°€ ìž…ë ¥ë˜ë©´ ì´ë¯¸ì§€ì™€ ë™ì¼í•˜ê²Œ ë¦¬ì‚¬ì´ì§•/í¬ë¡­ë©ë‹ˆë‹¤. ë§ˆìŠ¤í¬ê°€ ì—†ìœ¼ë©´ ê²°ê³¼ í¬ê¸°ì— ë§žëŠ” ê²€ì€ ë§ˆìŠ¤í¬ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    *   `upscale_method`ëŠ” `bicubic`ì´ ê¸°ë³¸ê°’ìž…ë‹ˆë‹¤.

### íŒŒì¼ ë³€ê²½ ì‚¬í•­
1.  `hvppy_image_nodes.py` íŒŒì¼ì„ ìƒˆë¡œ ìƒì„±í•˜ì—¬ ë…¸ë“œ ë¡œì§ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
2.  `__init__.py`ì— ìƒˆ ë…¸ë“œë¥¼ ë“±ë¡í•˜ê³ , ê¸°ì¡´ ë…¸ë“œë“¤ì˜ ì´ë¦„ë„ ê·œì¹™(`HP - ` ì ‘ë‘ì‚¬)ì— ë§žì¶° í†µì¼í–ˆìŠµë‹ˆë‹¤.
    *   `Create Full Mask` -> `HP - Create Full Mask`
    *   `Mask Size Match (Image)` -> `HP - Mask Size Match (Image)`

ì´ì œ ComfyUIë¥¼ ìž¬ì‹œìž‘í•˜ì—¬ ì‚¬ìš©í•˜ì‹¤ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\hvppy_image_nodes.py. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
ê·¼ë° comfyui restart í•˜ëŠ”ë²• ì—†ë‚˜ engine ë¶€ë¶„ 
</userRequest>

Assistant
ComfyUIì˜ **Python ì½”ë“œ(ë°±ì—”ë“œ)**ë¥¼ ìˆ˜ì •í–ˆì„ ë•ŒëŠ” **ì„œë²„ í”„ë¡œì„¸ìŠ¤ë¥¼ ì™„ì „ížˆ ê»ë‹¤ê°€ ë‹¤ì‹œ ì¼œì•¼** ë³€ê²½ ì‚¬í•­ì´ ë°˜ì˜ë©ë‹ˆë‹¤. (Javascript ìˆ˜ì •ì€ ë¸Œë¼ìš°ì € ìƒˆë¡œê³ ì¹¨ë§Œìœ¼ë¡œ ê°€ëŠ¥)

ì•„ì‰½ê²Œë„ ComfyUI ìžì²´ì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì¸ Python ì—”ì§„ë§Œ "í•« ë¦¬ë¡œë“œ(Hot Reload)"í•˜ëŠ” ê¸°ëŠ¥ì€ ê¸°ë³¸ì ìœ¼ë¡œ ì œê³µë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

### ìž¬ì‹œìž‘ ë°©ë²•

1.  **í„°ë¯¸ë„ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° (ê°€ìž¥ ê¶Œìž¥)**
    *   ì‹¤í–‰ ì¤‘ì¸ í„°ë¯¸ë„ì—ì„œ `Ctrl + C`ë¥¼ ëˆŒëŸ¬ ì„œë²„ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.
    *   ë‹¤ì‹œ ì‹¤í–‰ ëª…ë ¹ì–´ë¥¼ ìž…ë ¥í•©ë‹ˆë‹¤. (ì˜ˆ: `python main.py` ë˜ëŠ” `.\run_nvidia_gpu.bat`)

2.  **ComfyUI Manager ì‚¬ìš© ì‹œ**
    *   ComfyUI Managerê°€ ì„¤ì¹˜ë˜ì–´ ìžˆë‹¤ë©´, ë©”ë‰´ì— **"Restart"** ë²„íŠ¼ì´ ìžˆìŠµë‹ˆë‹¤. ì´ë¥¼ ëˆ„ë¥´ë©´ ì„œë²„ê°€ ìž¬ì‹œìž‘ë©ë‹ˆë‹¤.

3.  **VS Code í„°ë¯¸ë„ì—ì„œ ë°”ë¡œ ìž¬ì‹œìž‘í•˜ê¸°**
    *   ë§Œì•½ VS Code ë‚´ í„°ë¯¸ë„ì—ì„œ ì„œë²„ë¥¼ ëŒë¦¬ê³  ê³„ì‹œë‹¤ë©´, ì•„ëž˜ ëª…ë ¹ì–´ë¡œ ë¹ ë¥´ê²Œ ìž¬ì‹œìž‘í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. (ê²½ë¡œëŠ” ì—ëŸ¬ ë¡œê·¸ ê¸°ë°˜ìœ¼ë¡œ ì¶”ì •í–ˆìŠµë‹ˆë‹¤)

```bash
# ì„œë²„ ì¢…ë£Œ (Ctrl+C) í›„ ì•„ëž˜ ëª…ë ¹ì–´ ì‹¤í–‰
cd C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI
python main.py --auto-launch
```

**íŒ**: ê°œë°œ ì¤‘ì—ëŠ” ë§¤ë²ˆ ê»ë‹¤ ì¼œê¸° ê·€ì°®ìœ¼ë¯€ë¡œ, VS Code í„°ë¯¸ë„ì—ì„œ `Up Arrow`(ìœ„ í™”ì‚´í‘œ) í‚¤ë¥¼ ëˆŒëŸ¬ ì´ì „ ëª…ë ¹ì–´ë¥¼ ë¶ˆëŸ¬ì™€ ë°”ë¡œ ì—”í„°ë¥¼ ì¹˜ëŠ” ë°©ì‹ì„ ì¶”ì²œí•©ë‹ˆë‹¤.
User
<context>
The current date is 2025ë…„ 12ì›” 27ì¼.
Terminals:
Terminal: bash

</context>
<editorContext>
The user's current file is c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\hvppy_image_nodes.py. 
</editorContext>
<reminderInstructions>
When using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.

</reminderInstructions>
<userRequest>
ComfyUI ë§¤ë‹ˆì € ìµœì‹  ë²„ì ¼ì€ ê·¸ëŸ°ê²Œ ì—†ë„¤.
</userRequest>

Assistant
ComfyUI Managerì˜ ìž¬ì‹œìž‘ ê¸°ëŠ¥ì€ ComfyUIê°€ ì–´ë–»ê²Œ ì‹¤í–‰ë˜ì—ˆëŠ”ì§€(ë°°ì¹˜ íŒŒì¼ ëž˜í¼ ë“±)ì— ë”°ë¼ í™œì„±í™”ë˜ì§€ ì•Šì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

ê°œë°œ ì¤‘ì—ëŠ” **VS Code ë‚´ë¶€ í„°ë¯¸ë„**ì—ì„œ ComfyUIë¥¼ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ ê°€ìž¥ íš¨ìœ¨ì ìž…ë‹ˆë‹¤. ì½”ë“œë¥¼ ìˆ˜ì •í•  ë•Œë§ˆë‹¤ ë¹ ë¥´ê²Œ ê»ë‹¤ ì¼¤ ìˆ˜ ìžˆê³ , ì—ëŸ¬ ë¡œê·¸ë„ ë°”ë¡œ í™•ì¸í•  ìˆ˜ ìžˆê¸° ë•Œë¬¸ìž…ë‹ˆë‹¤.

VS Code í•˜ë‹¨ í„°ë¯¸ë„(`Ctrl + \``)ì„ ì—´ê³  ì•„ëž˜ ëª…ë ¹ì–´ë¥¼ ìž…ë ¥í•˜ì—¬ ì‹¤í–‰í•´ ë³´ì„¸ìš”. (ì•„ê¹Œ ì—ëŸ¬ ë¡œê·¸ì— ìžˆë˜ ê²½ë¡œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìž‘ì„±í–ˆìŠµë‹ˆë‹¤.)

```powershell
# 1. ComfyUI í´ë”ë¡œ ì´ë™
cd C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI

# 2. ì‹¤í–‰ (ë¸Œë¼ìš°ì € ìžë™ ì‹¤í–‰ ì˜µì…˜ í¬í•¨)
python main.py --auto-launch
```

**ê°œë°œ ë£¨í‹´:**
1.  ì½”ë“œ ìˆ˜ì • ë° ì €ìž¥
2.  í„°ë¯¸ë„ í´ë¦­ í›„ `Ctrl + C` (ì„œë²„ ì¢…ë£Œ)
3.  `â†‘` (ìœ„ í™”ì‚´í‘œ í‚¤) ëˆ„ë¥´ê³  `Enter` (ìž¬ì‹¤í–‰)

ì´ ë°©ì‹ì´ ìµìˆ™í•´ì§€ë©´ ë²„íŠ¼ì„ ì°¾ëŠ” ê²ƒë³´ë‹¤ í›¨ì”¬ ë¹ ë¦…ë‹ˆë‹¤.
User
Summarize the conversation history so far, paying special attention to the most recent agent commands and tool results that triggered this summarization. Structure your summary using the enhanced format provided in the system message.
Focus particularly on:
- The specific agent commands/tools that were just executed
- The results returned from these recent tool calls (truncate if very long but preserve key information)
- What the agent was actively working on when the token budget was exceeded
- How these recent operations connect to the overall user goals
Include all important tool calls and their results as part of the appropriate sections, with special emphasis on the most recent operations.
Response
Assistant
<analysis>
[Chronological Review: The user initiated a request to organize ComfyUI documentation into a reference for the Agent. The Agent created an `AGENTS_DOC` folder and populated it with 6 markdown files covering setup, node definition, data types, API, advanced topics, and frontend dev. The Agent then updated `AGENTS.md` to link to these docs. Subsequently, the user asked for analysis of a specific node (`ImageScaleToTotalPixels`) and its `resolution_steps` parameter. The user then requested a new node combining features of `ImageScaleToTotalPixels` and `ImageResizeKJv2`. The Agent created `hvppy_image_nodes.py` with `ScaleImage` class and updated `__init__.py`. Finally, the user asked about restarting ComfyUI, and the Agent explained manual restart methods as ComfyUI Manager didn't show the option.]

[Intent Mapping:
1. "Create documentation for Agent reference": Implemented via `AGENTS_DOC` folder.
2. "Analyze `ImageScaleToTotalPixels` and `resolution_steps`": Explained as ensuring dimensions are multiples of a number (e.g., 64) for model compatibility.
3. "Create a node combining scaling and resizing features": Implemented `HP - Scale Image` in `hvppy_image_nodes.py`.
4. "How to restart ComfyUI engine?": User wanted a hot-reload or button; Agent explained manual restart via terminal.]

[Technical Inventory:
- **ComfyUI Custom Nodes**: Python-based server extensions.
- **Frameworks**: `torch` (tensors), `comfy.utils` (upscaling).
- **Node Logic**: `megapixels` calculation, `divisible_by` logic, `crop` vs `stretch` resizing.
- **File Structure**: `hvppy_image_nodes.py`, `hvppy_mask_nodes.py`, `__init__.py`.
- **Environment**: Windows path `C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI`.]

[Code Archaeology:
- `c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\AGENTS_DOC\*.md`: Documentation files created.
- `c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\hvppy_mask_nodes.py`: Contains `CreateFullMask` and `MaskSizeMatch`.
- `c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\hvppy_image_nodes.py`: **New file** containing `ScaleImage` class.
- `c:\Workbench\20_Projects\custom_nodes\Hvppy-Nodes\__init__.py`: Updated to register `HvppyScaleImage` and rename others with `HP - ` prefix.]

[Progress Assessment:
- Documentation: Completed.
- Mask Nodes: Completed (`HP - Create Full Mask`, `HP - Mask Size Match (Image)`).
- Image Node: Completed (`HP - Scale Image`).
- Restart Issue: Addressed informationally (manual restart required).]

[Context Validation: The user is currently in a discussion about restarting the server to apply changes. The code for the new image node is written but likely not yet loaded by the running server.]

[Recent Commands Analysis: The Agent did not execute tools in the very last turn (it was a conversational response about restarting). Prior to that, it used `create_file` for `hvppy_image_nodes.py` and `replace_string_in_file` for `__init__.py`.]

</analysis>

<summary>
1. Conversation Overview:
- Primary Objectives: "Create a comprehensive summary of the entire conversation... to seamlessly continue the work" and specifically "Create a node combining ImageScaleToTotalPixels and Resize Image v2 features."
- Session Context: The session began with organizing ComfyUI documentation for the Agent. It transitioned into analyzing existing custom nodes, debugging mask size mismatches, and creating new custom nodes (`MaskSizeMatch` and `ScaleImage`).
- User Intent Evolution: Started with documentation -> moved to specific node analysis -> requested bug fix (mask size) -> requested feature implementation (Scale Image node) -> asked about workflow efficiency (server restart).

2. Technical Foundation:
- ComfyUI: Custom node development environment.
- PyTorch: Used for tensor manipulations (`torch.Tensor`, `movedim`, `unsqueeze`, `clamp`).
- Comfy Utils: `comfy.utils.common_upscale` used for resizing logic.
- Environment: Windows-based ComfyUI installation at `C:\Workbench\20_Projects\ComfyUI_windows_v0.6.0\ComfyUI`.

3. Codebase Status:
- `hvppy_image_nodes.py`:
    - Purpose: Contains image manipulation nodes.
    - Current State: Created with `ScaleImage` class.
    - Key Code Segments: `scale` method implementing megapixels calculation, `divisible_by` logic, and `crop`/`stretch` handling.
- `hvppy_mask_nodes.py`:
    - Purpose: Contains mask manipulation nodes.
    - Current State: Contains `CreateFullMask` and `MaskSizeMatch`.
- `__init__.py`:
    - Purpose: Registers nodes with ComfyUI.
    - Current State: Updated to import `ScaleImage` and register it as `HvppyScaleImage` with display name `HP - Scale Image`. Also renamed mask nodes to have `HP - ` prefix.
- `AGENTS_DOC/`:
    - Purpose: Reference documentation for the Agent.
    - Current State: Contains 6 markdown files covering setup, definitions, types, API, advanced topics, and frontend.

4. Problem Resolution:
- Issues Encountered: User reported an error when cropping images with mismatched mask sizes (`RuntimeError` in `narrow`).
- Solutions Implemented: Created `HP - Mask Size Match (Image)` node to return a black mask if sizes don't match.
- Debugging Context: User asked about `resolution_steps` (explained as `divisible_by`) and what happens if ratios don't align (explained as distortion/cropping).

5. Progress Tracking:
- Completed Tasks: [Documentation generation], [Mask Size Match node creation], [Scale Image node creation], [Node registration].
- Validated Outcomes: Code files are written. User needs to restart server to verify functionality.

6. Active Work State:
- Current Focus: Discussing how to restart the ComfyUI server to apply the Python code changes.
- Recent Context: The user asked if there is a way to restart the engine without closing the terminal. The Agent explained that Python backend changes require a full process restart and suggested using `Ctrl+C` and `Up Arrow` in the terminal.
- Working Code: `hvppy_image_nodes.py` was just created.
- Immediate Context: The user noted the ComfyUI Manager restart button was missing.

7. Recent Operations:
- Last Agent Commands: `create_file` (for `hvppy_image_nodes.py`), `replace_string_in_file` (for `__init__.py`).
- Tool Results Summary: Files successfully created/edited.
- Pre-Summary State: The Agent provided instructions on how to manually restart the server via the VS Code terminal.
- Operation Context: The user needs to restart the server to load the newly created `HP - Scale Image` node.

8. Continuation Plan:
- [Pending Task 1]: "Restart ComfyUI server" (User action required to load new nodes).
- [Pending Task 2]: "Verify `HP - Scale Image` node functionality" (Test if it correctly handles megapixels, cropping, and masking).
- [Priority Information]: The Python code changes are saved but not active until restart.
- [Next Action]: Wait for user to confirm restart or ask for further node refinements.

</summary>
